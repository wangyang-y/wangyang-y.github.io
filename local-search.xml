<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker基础</title>
    <link href="/2020/06/07/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/07/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Docker 学习</p><ul><li><p>Docker概述</p></li><li><p>Docker安装</p></li><li><p>Docker命令</p><ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li><p>Docker镜像！</p></li><li><p>容器数据卷！</p></li><li><p>DockerFile</p></li><li><p>Docker网络原理</p></li><li><p>IDEA整合Docker</p></li><li><p>集群 DockerCompose</p></li><li><p>Docker Swarm</p></li><li><p>CI\CD Jenkins</p></li></ul><h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么出现？"><a href="#Docker为什么出现？" class="headerlink" title="Docker为什么出现？"></a>Docker为什么出现？</h2><p>一款产品：开发–上线 两套环境！应用环境，应用配置</p><p>开发 —运维。经常会出现这种问题，在我的电脑上可以运行？到你那里就不可以运行了！版本更新，导致服务不可用！</p><p>环境配置是十分麻烦的，每一机器都要配置环境，特别麻烦浪费时间。</p><p>发布一个项目以前是发布一个jar,但是它需要运行环境。我们好需要去配置运行环境。</p><p>那么我们可以让jar + 开发环境（Redis Mysql jdk ES） 打包部署，就不需要麻烦的配置了。</p><p>之前服务器配置了一个应用环境Redis Mysql jdk ES Hadoop，配置起来很麻烦，而且还不能跨平台。那么 没换一个服务就又得重新配置一边。</p><p>传统开发： 开发jar ,运维来做部署！</p><p>现在，开发打包部署上线，一套流程做完！</p><p>我们使用java开发一个项目—&gt; 打包的时候带上环境（镜像）—&gt;将它放到Docker仓库—–&gt;下载我们发布的镜像—&gt;直接运行即可</p><p><strong>Docker 给以上的问题，提出了解决方案</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker.jpg" srcset="/img/loading.gif" alt></p><p><code>Docker的思想就来源于集装箱！</code></p><p>隔离: Docker核心思想！打包装箱！每个箱子是相互隔离的。</p><p>Docker通过隔离机制，可以将服务器运用到极致。</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>2010，几个搞IT的年轻人，在美国成立了一公司<code>dotCloud</code></p><p>做一些pass的云计算服务！linux中虚拟机有关的容器技术!</p><p>他们将自己的技术（容器化技术）命名就是Docker!</p><p>Docker刚刚诞生的时候，没有引起行业的注意！dotCloud，就活不下去了，他们想到了开源，<code>开放源代码</code>。</p><p>2013年，Docker开源！以至于越来越多的人了解，发现好用。就被广泛使用。发展的越来越好！</p><p><strong>Docker为什么这么火？</strong></p><p>虚拟机也是属于虚拟化技术，Docker容器技术，也是一种虚拟化技术。</p><p>在容器化技术发展起来的时候，我们一直使用的即使虚拟机技术。</p><p>虚拟机：在windows中装一个Vmware，通过这个软件让我们虚拟出来一个或多个电脑！但是它非常笨重。</p><div class="hljs"><pre><code class="hljs shell">vm ： linux centos原生镜像（一个电脑）几十个G的大小，启动时间久。docker ： 隔离，镜像（最核心的环境）十分的小巧，运行镜像就可以了！启动非常快</code></pre></div><blockquote><p>聊聊Docker</p></blockquote><p>Docker是基于Go语言开发的！开源项目！</p><p>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/Docs.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/mv.jpg" srcset="/img/loading.gif" alt></p><p><strong>虚拟机技术缺点：</strong></p><p>1、资源占用什么多</p><p>2、冗余步骤多</p><p>3、启动很慢</p><blockquote><p>容器化技术</p></blockquote><p>比较Docker和虚拟机技术的不同：</p><ul><li><p>传统虚拟机，直接虚拟出一个硬件，运行一个完成的操作系统，然后在这个系统上安装运行软件。</p></li><li><p>容器内的应用直接运行在宿主机的内核上，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了很多</p></li><li><p>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响。</p></li></ul><blockquote><p>DevOps（开发运维）使用Docker后的好处</p></blockquote><p><strong>应用更快捷的交付和部署</strong></p><p>传统：运维时，要看一堆帮助文档，安装程序</p><p>Docker:  打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩容</strong></p><p>项目打包成一个镜像，扩展服务器A ！服务器B</p><p><strong>更简单的系统运维</strong></p><p>容器化后，我们的开发，测试环境都高度的一致</p><p><strong>更高效的计算资源利用</strong></p><p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的实例容器，服务器的性能可以内利用到极致。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker的基本组成</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="Docker架构图"></p><p><strong>镜像（image）</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，可以创建多个容器，最终项目就运行在这些容器中</p><p><strong>容器（container）</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>目前可以把容器理解为是一个简易的linux系统</p><p><strong>仓库（repository）</strong></p><p>仓库就是来存放镜像的地方</p><p>仓库可以分为公有仓库和私有仓库</p><p>Docker Hub</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote><p>环境准备</p><p>1.需要回点Linux基础</p><p>2.CentOS7</p><p>3.使用Xshell连接远程服务进行操作</p></blockquote><blockquote><p>环境查看 uname -r</p></blockquote><p><strong>查看系统内核版本</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# uname -r4.18.0-147.8.1.el8_1.x86_64</code></pre></div><p><strong>查看linux系统版本</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# cat /etc/os-releaseNAME="CentOS Linux"VERSION="8 (Core)"ID="centos"ID_LIKE="rhel fedora"VERSION_ID="8"PLATFORM_ID="platform:el8"PRETTY_NAME="CentOS Linux 8 (Core)"ANSI_COLOR="0;31"CPE_NAME="cpe:/o:centos:centos:8"HOME_URL="https://www.centos.org/"BUG_REPORT_URL="https://bugs.centos.org/"CENTOS_MANTISBT_PROJECT="CentOS-8"CENTOS_MANTISBT_PROJECT_VERSION="8"REDHAT_SUPPORT_PRODUCT="centos"REDHAT_SUPPORT_PRODUCT_VERSION="8"</code></pre></div><blockquote><p>安装</p></blockquote> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧的版本</span>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine                  <span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置仓库的镜像</span><span class="hljs-meta">#</span><span class="bash"> 默认使用的是国外的，访问很慢，我们使用阿里云的</span>yum-config-manager \    --add-repo \http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 建议更新yum软件索引包</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4.安装docker ce 社区版 ee 企业版</span>yum install docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 5.启动docker</span>systemctl start docker</code></pre></div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 6.查看是否安装成功</span>docker version</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8Bdocker%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7.测试 通过运行hello-world 映像来验证是否正确安装了Docker Engine </span>docker run hello-world</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker-helloworld.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 8.查看一下下载的这个镜像</span>docker images</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/hello-image.jpg" srcset="/img/loading.gif" alt></p><blockquote><p><strong>了解</strong>  卸载docker  docker的默认工作路径<strong>/var/lib/docker</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.删除docker依赖</span>yum remove docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 2.删除目录</span>rm -rf /var/lib/docker</code></pre></div><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><h3 id="1-登录阿里云找到镜像服务"><a href="#1-登录阿里云找到镜像服务" class="headerlink" title="1. 登录阿里云找到镜像服务"></a>1. 登录阿里云找到镜像服务</h3><h3 id="2-找到每个人的镜像加速地址"><a href="#2-找到每个人的镜像加速地址" class="headerlink" title="2. 找到每个人的镜像加速地址"></a>2. 找到每个人的镜像加速地址</h3><h3 id="3-在镜像中心找到镜像加速器，配置使用"><a href="#3-在镜像中心找到镜像加速器，配置使用" class="headerlink" title="3. 在镜像中心找到镜像加速器，配置使用"></a>3. 在镜像中心找到镜像加速器，配置使用</h3><blockquote><p>每个人都有自己的地址</p></blockquote><div class="hljs"><pre><code class="hljs shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;  "registry-mirrors": ["https://xxxxxxxx.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><h2 id="回顾HelloWord流程"><a href="#回顾HelloWord流程" class="headerlink" title="回顾HelloWord流程"></a>回顾HelloWord流程</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/hello-world%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt="Hello world流程"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker-run.jpg" srcset="/img/loading.gif" alt="docker run"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker 是怎么工作的？</strong></p><p>Docekr是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！（类似mysql）</p><p>DockerServer接收到Docker-Clinet的指令，就会执行这个命令。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" alt></p><p><strong>Docker为什么比VM快？</strong></p><p>1、Docker有着比虚拟机更少的抽象层</p><p>2、Docker利用的是宿主机的内核，vm需要自己的Guest OS</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/vm--docker%E5%8C%BA%E5%88%AB.jpg" srcset="/img/loading.gif" alt></p><p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS 分钟级别的。而Docker是利用宿主机的操作系统，省略了这个复杂的过程，启动时秒机的。</p><h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><div class="hljs"><pre><code class="hljs shell">docekr version  # 查看docekr的版本信息docker info# 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help  # 帮助命令</code></pre></div><p><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">命令帮助文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p><strong>docker images</strong>  查看所有本地主机上的镜像</p></blockquote><div class="hljs"><pre><code class="hljs shell">root@iZbp1baf0xyn152a53kixrZ ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        5 months ago        13.3kB<span class="hljs-meta">#</span><span class="bash"> 解释</span>REPOSITORY 仓库名字TAG        标签指定版本IMAGE ID   镜像idCREATED    创建时间SIZE       大小<span class="hljs-meta">#</span><span class="bash"> 可选项</span>Options:  -a, --all             Show all images (default hides intermediate images) ## 常用  查看所有      --digests         Show digests  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print images using a Go template      --no-trunc        Don't truncate output  -q, --quiet           Only show numeric IDs   ## 常用  查看id</code></pre></div><blockquote><p><strong>docker search 搜索镜像</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker search 镜像名字</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search mysqlNAME     DESCRIPTION      STARS    OFFICIAL    AUTOMATEDmysql    MySQL is a widely used, open-source relation… 9587 [OK]mariadb   MariaDB is a community-developed fork of MyS…   3486   [OK]<span class="hljs-meta">#</span><span class="bash"> 按照星数过滤</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search mysql --filter=STARS=3000NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql               MySQL is a widely used, open-source relation…   9587                [OK]                mariadb             MariaDB is a community-developed fork of MyS…   3486                [OK]</code></pre></div><blockquote><p>docker  pull 下载镜像</p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysqlUsing default tag: latest  # 如果不写tag ,默认是下载最先版的latest: Pulling from library/mysqlafb6ec6fdc1c: Pull complete  # 分层下载 docker image 核心0bdc5971ba40: Pull complete 97ae94a2c729: Pull complete f777521d340e: Pull complete 1393ff7fc871: Pull complete a499b89994d9: Pull complete 7ebe8eefbafe: Pull complete 597069368ef1: Pull complete ce39a5501878: Pull complete 7d545bca14bf: Pull complete 211e5bb2ae7b: Pull complete 5914e537c077: Pull complete Digest: sha256:a31a277d8d39450220c722c1302a345c84206e7fd4cdb619e7face046e89031d # 防伪签名Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest  <span class="hljs-meta">#</span><span class="bash">  真实地址  docker pull mysql 等价于 docker pull docker.io/library/mysql:latest</span><span class="hljs-meta">#</span><span class="bash"> 指定版本下载</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysql:5.75.7: Pulling from library/mysqlafb6ec6fdc1c: Already exists  # 已经存在的分层0bdc5971ba40: Already exists 97ae94a2c729: Already exists f777521d340e: Already exists 1393ff7fc871: Already exists a499b89994d9: Already exists 7ebe8eefbafe: Already exists 4eec965ae405: Pull complete a531a782d709: Pull complete 270aeddb45e3: Pull complete b25569b61008: Pull complete Digest: sha256:d16d9ef7a4ecb29efcd1ba46d5a82bda3c28bd18c0f1e3b86ba54816211e1ac4Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 查看帮助命令</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull --helpUsage:docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions:  -a, --all-tags                Download all tagged images in the repository      --disable-content-trust   Skip image verification (default true)      --platform string         Set platform if server is multi-platform capable  -q, --quiet                   Suppress verbose output</code></pre></div><blockquote><p><strong>docker rmi</strong> 删除docker image </p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除指定的镜像</span>docekr rmi -f 镜像id<span class="hljs-meta">#</span><span class="bash"> 删除多个镜像</span>docker  rmi -f 镜像id 镜像id 镜像id 镜像id<span class="hljs-meta">#</span><span class="bash"> 批量删除   $(docker images -aq)作为参数</span>docker rmi -f $(docker images -aq)</code></pre></div><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><code>我们有了镜像之后，才可以创建容器，使用linux下载一个镜像来学习测试</code></p><div class="hljs"><pre><code class="hljs shell">docker pull centos</code></pre></div><blockquote><p>新建容器并启动 <code>docker run -it centos /bin/bash</code></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动容器，并进入容器</span>docker run -it centos /bin/bash[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it centos /bin/bash[root@e214ca179c15 /]# lsbin  etc   lib  lost+found  mnt  proc  run   srv  tmp  vardev  home  lib64  media       opt  root  sbin  sys  usr<span class="hljs-meta">#</span><span class="bash"> 容器停止并退出</span>[root@e214ca179c15 /]# exitexit</code></pre></div><blockquote><p><strong>退出容器</strong></p><p>容器停止并退出<br>[root@e214ca179c15 /]# exit<br>exit</p><p>容器不停止退出容器</p><p>Ctrl + P + Q</p></blockquote><blockquote><p>查看正在运行的容器 <code>docker ps</code></p><p>查看曾经运行过的容器 <code>docker ps -a</code></p><p>参数</p><p>​    无参：    列出当前正在运行的容器</p><p>​    -a :             列出当前正在运行的容器，以及停止运行的容器</p><p>​    -n=?         显示最近运行的容器 ？ 指定个数</p><p>​    -q            只显示容器编号</p></blockquote><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre></div><blockquote><p><strong>删除容器</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell">docker rm 容器id  # 删除指定容器docker rm  -f $(docker ps -aq)   #删除所有容器 docker ps -a -q | xargs docker rm -f  # 删除所有的容器</code></pre></div><blockquote><p>启动和停止容器</p></blockquote><div class="hljs"><pre><code class="hljs shell">docker start 容器id# 启动容器docker restart 容器id# 重启容器docker stop 容器id# 停止当前正在容器docker kill 容器id        # 强制停止当前运行的容器</code></pre></div><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1、后台启动命令"><a href="#1、后台启动命令" class="headerlink" title="1、后台启动命令"></a>1、后台启动命令</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker run -d 镜像名    后台启动容器</span><span class="hljs-meta">#</span><span class="bash"> 问题 docker ps， 发现容器停止了</span><span class="hljs-meta">#</span><span class="bash"> dockek容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止。</span></code></pre></div><h3 id="2、查看日志"><a href="#2、查看日志" class="headerlink" title="2、查看日志"></a>2、查看日志</h3><div class="hljs"><pre><code class="hljs shell">docker logs -ft --tail n  # 查看日志的后几条<span class="hljs-meta">#</span><span class="bash"> 显示日志</span>-tf     # 时间戳和格式--tail number    #显示日志后几条</code></pre></div><h3 id="3、查看容器中的进程命令"><a href="#3、查看容器中的进程命令" class="headerlink" title="3、查看容器中的进程命令"></a>3、查看容器中的进程命令</h3><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker top 1b4cdaa8b5aeUID    PID   PPID   C   STIME    TTY    TIME   CMDroot  20878   20862  0  08:48   pts/0 00:00:00  /bin/bash</code></pre></div><h3 id="4、查看容器的元数据"><a href="#4、查看容器的元数据" class="headerlink" title="4、查看容器的元数据"></a>4、查看容器的元数据</h3><div class="hljs"><pre><code class="hljs shell">docker inspect 容器id[root@iZbp1baf0xyn152a53kixrZ ~]# docker inspect 1b4cdaa8b5ae[    &#123;        "Id": "1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee",        "Created": "2020-06-06T07:20:02.258890351Z",        "Path": "/bin/bash",        "Args": [],        "State": &#123;            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 20878,            "ExitCode": 0,            "Error": "",            "StartedAt": "2020-06-07T00:48:12.344223612Z",            "FinishedAt": "2020-06-06T07:23:34.064971347Z"        &#125;,        "Image": "sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee",        "ResolvConfPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/resolv.conf",        "HostnamePath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/hostname",        "HostsPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/hosts",        "LogPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee-json.log",        "Name": "/heuristic_davinci",        "RestartCount": 0,        "Driver": "overlay2",        "Platform": "linux",        "MountLabel": "",        "ProcessLabel": "",        "AppArmorProfile": "",        "ExecIDs": null,        "HostConfig": &#123;            "Binds": null,            "ContainerIDFile": "",            "LogConfig": &#123;                "Type": "json-file",                "Config": &#123;&#125;            &#125;,            "NetworkMode": "default",            "PortBindings": &#123;&#125;,            "RestartPolicy": &#123;                "Name": "no",                "MaximumRetryCount": 0            &#125;,            "AutoRemove": false,            "VolumeDriver": "",            "VolumesFrom": null,            "CapAdd": null,            "CapDrop": null,            "Capabilities": null,            "Dns": [],            "DnsOptions": [],            "DnsSearch": [],            "ExtraHosts": null,            "GroupAdd": null,            "IpcMode": "private",            "Cgroup": "",            "Links": null,            "OomScoreAdj": 0,            "PidMode": "",            "Privileged": false,            "PublishAllPorts": false,            "ReadonlyRootfs": false,            "SecurityOpt": null,            "UTSMode": "",            "UsernsMode": "",            "ShmSize": 67108864,            "Runtime": "runc",            "ConsoleSize": [                0,                0            ],            "Isolation": "",            "CpuShares": 0,            "Memory": 0,            "NanoCpus": 0,            "CgroupParent": "",            "BlkioWeight": 0,            "BlkioWeightDevice": [],            "BlkioDeviceReadBps": null,            "BlkioDeviceWriteBps": null,            "BlkioDeviceReadIOps": null,            "BlkioDeviceWriteIOps": null,            "CpuPeriod": 0,            "CpuQuota": 0,            "CpuRealtimePeriod": 0,            "CpuRealtimeRuntime": 0,            "CpusetCpus": "",            "CpusetMems": "",            "Devices": [],            "DeviceCgroupRules": null,            "DeviceRequests": null,            "KernelMemory": 0,            "KernelMemoryTCP": 0,            "MemoryReservation": 0,            "MemorySwap": 0,            "MemorySwappiness": null,            "OomKillDisable": false,            "PidsLimit": null,            "Ulimits": null,            "CpuCount": 0,            "CpuPercent": 0,            "IOMaximumIOps": 0,            "IOMaximumBandwidth": 0,            "MaskedPaths": [                "/proc/asound",                "/proc/acpi",                "/proc/kcore",                "/proc/keys",                "/proc/latency_stats",                "/proc/timer_list",                "/proc/timer_stats",                "/proc/sched_debug",                "/proc/scsi",                "/sys/firmware"            ],            "ReadonlyPaths": [                "/proc/bus",                "/proc/fs",                "/proc/irq",                "/proc/sys",                "/proc/sysrq-trigger"            ]        &#125;,        "GraphDriver": &#123;            "Data": &#123;                "LowerDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72-init/diff:/var/lib/docker/overlay2/5a6f50a98473d927999ddc03f2b6b8670059cceef16c833cafb050a59fcc479c/diff",                "MergedDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/merged",                "UpperDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/diff",                "WorkDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/work"            &#125;,            "Name": "overlay2"        &#125;,        "Mounts": [],        "Config": &#123;            "Hostname": "1b4cdaa8b5ae",            "Domainname": "",            "User": "",            "AttachStdin": true,            "AttachStdout": true,            "AttachStderr": true,            "Tty": true,            "OpenStdin": true,            "StdinOnce": true,            "Env": [                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"            ],            "Cmd": [                "/bin/bash"            ],            "Image": "centos",            "Volumes": null,            "WorkingDir": "",            "Entrypoint": null,            "OnBuild": null,            "Labels": &#123;                "org.label-schema.build-date": "20200114",                "org.label-schema.license": "GPLv2",                "org.label-schema.name": "CentOS Base Image",                "org.label-schema.schema-version": "1.0",                "org.label-schema.vendor": "CentOS",                "org.opencontainers.image.created": "2020-01-14 00:00:00-08:00",                "org.opencontainers.image.licenses": "GPL-2.0-only",                "org.opencontainers.image.title": "CentOS Base Image",                "org.opencontainers.image.vendor": "CentOS"            &#125;        &#125;,        "NetworkSettings": &#123;            "Bridge": "",            "SandboxID": "438bb0e752375594c48f8ba55f4374214bd3b36cf1e9ebbc06bb8cb471f79381",            "HairpinMode": false,            "LinkLocalIPv6Address": "",            "LinkLocalIPv6PrefixLen": 0,            "Ports": &#123;&#125;,            "SandboxKey": "/var/run/docker/netns/438bb0e75237",            "SecondaryIPAddresses": null,            "SecondaryIPv6Addresses": null,            "EndpointID": "f9881ae9d0d82f56ce686875465a0b919929bf4b6a094a90f3eecf95418be7d7",            "Gateway": "172.17.0.1",            "GlobalIPv6Address": "",            "GlobalIPv6PrefixLen": 0,            "IPAddress": "172.17.0.2",            "IPPrefixLen": 16,            "IPv6Gateway": "",            "MacAddress": "02:42:ac:11:00:02",            "Networks": &#123;                "bridge": &#123;                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "abe6f173e52133983efc00c41f8b3125612c37489f7eba4898ef1fc1b1a570b5",                    "EndpointID": "f9881ae9d0d82f56ce686875465a0b919929bf4b6a094a90f3eecf95418be7d7",                    "Gateway": "172.17.0.1",                    "IPAddress": "172.17.0.2",                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:11:00:02",                    "DriverOpts": null                &#125;            &#125;        &#125;    &#125;]</code></pre></div><h3 id="5、进入当前正在运行的容器（重要）"><a href="#5、进入当前正在运行的容器（重要）" class="headerlink" title="5、进入当前正在运行的容器（重要）"></a>5、进入当前正在运行的容器（<code>重要</code>）</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通常容器都是使用后台方式运行的，我们需要进入容器，修改一些配置</span><span class="hljs-meta">#</span><span class="bash"> 方式一</span>docker exec -it 容器id /bin/bashroot@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it 1b4cdaa8b5ae /bin/bash[root@1b4cdaa8b5ae /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@1b4cdaa8b5ae /]# read escape sequence<span class="hljs-meta">#</span><span class="bash"> 方式二</span>docker attach 容器id[root@iZbp1baf0xyn152a53kixrZ ~]# docker attach 1b4cdaa8b5ae[root@1b4cdaa8b5ae /]# ls<span class="hljs-meta">#</span><span class="bash"> 区别</span><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">exec</span>  进入容器后开启一个新的终端，再在里面操作（常用）</span><span class="hljs-meta">#</span><span class="bash"> docker attach  进入容器正在执行的终端</span></code></pre></div><h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker cp 容器id:/文件所在的路径  /要复制到主机的哪个位置</span><span class="hljs-meta">#</span><span class="bash"> 注意复制时 需要退出容器</span></code></pre></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93.jpg" srcset="/img/loading.gif" alt></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="1、部署Nginx"><a href="#1、部署Nginx" class="headerlink" title="1、部署Nginx"></a>1、部署Nginx</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、搜索镜像 建议去docker Hub上搜索，可以看见版本号</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search nginx --filter=stars=10000NAME                DESCRIPTION                STARS               OFFICIAL            AUTOMATEDnginx               Official build of Nginx.   13299               [OK]<span class="hljs-meta">#</span><span class="bash"> 2、下载镜像</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxafb6ec6fdc1c: Pull complete dd3ac8106a0b: Pull complete 8de28bdda69b: Pull complete a2c431ac2669: Pull complete e070d03fd1b5: Pull complete Digest: sha256:c870bf53de0357813af37b9500cb1c2ff9fb4c00120d5fe1d75c21591293c34dStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest<span class="hljs-meta">#</span><span class="bash"> 3、启动容器 docker run -d --name nginx01 -p 3344:80 nginx</span><span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span><span class="hljs-meta">#</span><span class="bash"> --name 给容器起名字</span><span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d --name nginx01 -p 3344:80 nginx2f2205692302e8d08a27d2a6476fa50034dd2eaa3114fd422de025febe072930[root@iZbp1baf0xyn152a53kixrZ ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES2f2205692302        nginx               "/docker-entrypoint.…"   6 seconds ago       Up 4 seconds        0.0.0.0:3344-&gt;80/tcp   nginx01 <span class="hljs-meta">#</span><span class="bash"> curl localhost:端口号查看是否启动成功</span>[root@iZbp1baf0xyn152a53kixrZ ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body &#123;        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><h2 id="2、部署Tomcat"><a href="#2、部署Tomcat" class="headerlink" title="2、部署Tomcat"></a>2、部署Tomcat</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.搜素镜像</span>docker search tomcat<span class="hljs-meta">#</span><span class="bash"> 2.下载镜像</span>docker pull tomcat:9.0<span class="hljs-meta">#</span><span class="bash"> 3.创建容器，并启动，主机和容器的端口映射</span>docker run -d -name tomcat01 -p 3355:8080 tomcat:9.0<span class="hljs-meta">#</span><span class="bash"> 4.测试</span>curl localhost:8080<span class="hljs-meta">#</span><span class="bash"> 在外网访问 容器中的tomcat 会报404，解决：可以将webapps.dist下的文件复制到 webapps 下</span><span class="hljs-meta">#</span><span class="bash"> 发现问题</span><span class="hljs-meta">#</span><span class="bash"> a.容器中Tomcat的命令少了</span><span class="hljs-meta">#</span><span class="bash"> b.没有webapps.这是由于阿里云镜像的原因，默认是最小的镜像，剔除了不必要的，只保证最小的可运行环境，是一个阉割版的Tomcat</span></code></pre></div><h2 id="3、部署-ES-Kibana"><a href="#3、部署-ES-Kibana" class="headerlink" title="3、部署 ES + Kibana"></a>3、部署 ES + Kibana</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多</span><span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span><span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span><span class="hljs-meta">#</span><span class="bash"> 启动</span><span class="hljs-meta">$</span><span class="bash"> docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e <span class="hljs-string">"discovery.type=single-node"</span> elasticsearch:7.7.1</span><span class="hljs-meta">#</span><span class="bash"> 启动就很卡 docker stats 查看 cpu状态</span><span class="hljs-meta">#</span><span class="bash"> 测试完就赶紧停掉，他是非常吃内存的</span><span class="hljs-meta">#</span><span class="bash">修改配置文件 -e 环境配置</span>docker run -d --name elasticsearch02  -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.7.1</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/ES%2BKibana.jpg" srcset="/img/loading.gif" alt></p><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><ul><li>portainer(先使用这)</li></ul><div class="hljs"><pre><code class="hljs shell">docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code></pre></div><ul><li>Rancher(CI/CD再用)</li></ul><p><strong>什么是portainer?</strong></p><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p><div class="hljs"><pre><code class="hljs shell">docker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div><p>访问测试 ：<a href="http://ip:8088" target="_blank" rel="noopener">http://ip:8088</a></p><ul><li>登录页面</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer%E7%99%BB%E5%BD%95.jpg" srcset="/img/loading.gif" alt="portainer登录"></p><ul><li>进入之后选择local</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer%E9%80%89%E6%8B%A9local.jpg" srcset="/img/loading.gif" alt="portainer选择local"></p><ul><li>进来之后就可以看见我们安装的一些容器，镜像</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer01.jpg" srcset="/img/loading.gif" alt="portainer01"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer02.jpg" srcset="/img/loading.gif" alt="portainer02"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer03.jpg" srcset="/img/loading.gif" alt="portainer03"></p><h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p><code>镜像就是一种轻量级、可执行的独软件包</code>。用来打包软件运行环境和基于运行环境开的软件，它包含运行某个如那件所需要的所有内容，包括代码、运行时库、环境变量和配置文件。</p><p>所有的应用直接打包成docker镜像，就直接跑起来了。</p><p><strong>如何得到镜像：</strong></p><ul><li>从远程仓库下载</li><li>别人拷给你</li><li>自己制作一个DockerFile</li></ul><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82.jpg" srcset="/img/loading.gif" alt="docker镜像分层"></p><h2 id="如何提交一个自己的镜像commit-镜像"><a href="#如何提交一个自己的镜像commit-镜像" class="headerlink" title="如何提交一个自己的镜像commit 镜像"></a>如何提交一个自己的镜像commit 镜像</h2><div class="hljs"><pre><code class="hljs shell">docker commit 提交容器称为一个新的镜像docker commit -m="提价的描述信息" -a="作者" 容器id 目标镜像名:[tag]</code></pre></div><p><strong>实战测试</strong> </p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动一个默认的tomcat</span><span class="hljs-meta">#</span><span class="bash"> 发现这个默认的tomcat webapps中的文件夹是空的，原因是官方镜像剔除了不必要的文件</span><span class="hljs-meta">#</span><span class="bash"> 将webapps.dist 中的拷贝到webapps中</span><span class="hljs-meta">#</span><span class="bash"> 将我们操作过的镜像通过commit提交为一个镜像</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E7%9A%84image.jpg" srcset="/img/loading.gif" alt="提交自己的image"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84image.jpg" srcset="/img/loading.gif" alt="修改过的image"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%88%86%E5%B1%82%E6%93%8D%E4%BD%9C.jpg" srcset="/img/loading.gif" alt="分层操作"></p><div class="note note-primary">            <p><strong>到这里 才是入门docker</strong></p>          </div>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test02</title>
    <link href="/2020/06/04/test02/"/>
    <url>/2020/06/04/test02/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.qfeng.online/imgs/test-02.PNG" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test 图片</title>
    <link href="/2020/06/04/test-%E5%9B%BE%E7%89%87/"/>
    <url>/2020/06/04/test-%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/06/04/test-%E5%9B%BE%E7%89%87/E:%5CBlog%5Csource_posts%5Ctest-%E5%9B%BE%E7%89%87%5CSnipaste_2020-06-04_10-06-52.jpg" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot完整笔记</title>
    <link href="/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot-入门"><a href="#一、Spring-Boot-入门" class="headerlink" title="一、Spring Boot 入门"></a>一、Spring Boot 入门</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><blockquote><p>Spring Boot来简化Spring应用开发的框架</p><p>整个Spring技术栈的一个大整合</p><p>J2EE开发的一站式解决方案</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>微服务：一种架构风格</p><p>一个应用应该是一组小型服务；可以通过HTTP的方法是进行互通；</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软禁单元；</p><h2 id="3、Hello-World"><a href="#3、Hello-World" class="headerlink" title="3、Hello World"></a>3、Hello World</h2><p>浏览器发送hello请求，服务器接收请求并处理，响应Hello World字符串。</p><h3 id="1、创建一个maven工程"><a href="#1、创建一个maven工程" class="headerlink" title="1、创建一个maven工程"></a>1、创建一个maven工程</h3><h3 id="2、导入Spring相关依赖"><a href="#2、导入Spring相关依赖" class="headerlink" title="2、导入Spring相关依赖"></a>2、导入Spring相关依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="3、编写一个主程序，启动Spring应用"><a href="#3、编写一个主程序，启动Spring应用" class="headerlink" title="3、编写一个主程序，启动Spring应用"></a>3、编写一个主程序，启动Spring应用</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//来标注一个主程序类，表示这是一个Spring Boot的应用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Spring 应用启动起来</span>        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Spring Boot"</span>;    &#125;&#125;</code></pre></div><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--简化部署，这个插件可以将应用打包成一个可执行的jar包--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><h2 id="4、Hello-World-分析"><a href="#4、Hello-World-分析" class="headerlink" title="4、Hello World 分析"></a>4、Hello World 分析</h2><h3 id="1、POM"><a href="#1、POM" class="headerlink" title="1、POM"></a>1、POM</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><blockquote><p>​    上面的项目的父项目</p></blockquote><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>在这个项目里面真正管理了Spring Boot应用的所有依赖版本</code></pre></div><blockquote><p>Spring Boot的版本仲裁中心</p><p>以后我们导入项目默认是不需要写版本号的，当然没有在dependencies中管理的依赖还是需要声明版本号的</p></blockquote><h4 id="2、导入的依赖，启动器"><a href="#2、导入的依赖，启动器" class="headerlink" title="2、导入的依赖，启动器"></a>2、导入的依赖，启动器</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>Spring-boot-starter-web</strong></p><p>​        spirng-boot-starter ：spring-boot场景启动器；帮我们导入了web模块正常运行所需要的依赖组件</p><p> Spring Boot将所有的功能场景都抽取出来了，做成了一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p><h3 id="2、主程序类、主入口类"><a href="#2、主程序类、主入口类" class="headerlink" title="2、主程序类、主入口类"></a>2、主程序类、主入口类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//来标注一个主程序类，表示这是一个Spring Boot的应用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Spring 应用启动起来</span>        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p><code>@SpringBootApplication</code> : SpringBootApplication标注在某个类上面，就表示这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动Spring应用 </p><h2 id="5、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#5、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="5、使用Spring Initializer快速创建Spring Boot项目"></a>5、使用Spring Initializer快速创建Spring Boot项目</h2><h1 id="二、Spring-Boot-配置"><a href="#二、Spring-Boot-配置" class="headerlink" title="二、Spring Boot 配置"></a>二、Spring Boot 配置</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><blockquote><p>SpringBoot 使用一个全局的配置文件，配置文件的名是固定的</p></blockquote><p><code>application.properties</code></p><p><code>application.yml</code></p><p>配置文件的作用：修改SpringBoot自动配置的默认值；</p><p>YAML（YANL Ain’t Markup Languge）</p><p>标记语言</p><p>​        以前的配置文件；大多都使用的是 xxx.xml文件；</p><p>​        YAML ：以数据为中心，比json,xml等更加合适做配置文件</p><p>YAML:</p><div class="hljs"><pre><code class="hljs xml">server:  port: 8003</code></pre></div><p>XML:</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>        8003    <span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre></div><h2 id="2、YAML基本语法"><a href="#2、YAML基本语法" class="headerlink" title="2、YAML基本语法"></a>2、YAML基本语法</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k: （空格)v ：表示一对键值对（空格必须有）</p><p>一<strong>空格</strong>的缩进来控制层级关系；只要是左对其的一列数据，都是同一个层级</p><div class="hljs"><pre><code class="hljs xml">serverport: 8081path: /hello</code></pre></div><p><code>属性和值也是大小写敏感的</code></p><h3 id="2、指的写法"><a href="#2、指的写法" class="headerlink" title="2、指的写法"></a>2、指的写法</h3><p><strong>字面量 : 普通的值（数字，字符串，布尔）</strong></p><p>​        k:v ：字面直接来写；</p><p>​                字符串默认不用加上单引号或者双引号</p><p>​                “” : 双引号；会转义转义字符串里面的特殊字符</p><p>​                                name:    “wangyang\n lisi”    输出 wangyang 换行 lisi</p><p>​                ‘’：单引号；不会转义字符串里面的特殊字符，会原样输出字符串中的内容</p><p>​                                name:    “wangyang\n lisi”    输出 wangyang\n lisi</p><p><strong>对象、Map(属性和值) (键值对)</strong></p><p>​        k:    v ： 在下一行来写对象的属性和值的关系；注意缩进</p><p>​                对象还是K : v的方式</p><div class="hljs"><pre><code class="hljs xml">student: name: zhangsanage: 20</code></pre></div><p><strong>行内写法：</strong></p><div class="hljs"><pre><code class="hljs xml">student: &#123;name: zhangsan,age: 20&#125;</code></pre></div><p><strong>数组（List、Set）</strong>    </p><p>值表示数组中的一个元素</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">pets:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><span class="hljs-bullet">-</span> <span class="hljs-string">pig</span></code></pre></div><p>行内写法</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">pets:</span> <span class="hljs-string">[cat,dog,pig]</span></code></pre></div><h3 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h3><p>配置文件</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">wangyang</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>  <span class="hljs-attr">salary:</span> <span class="hljs-number">20000</span>  <span class="hljs-attr">map:</span>    <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>    <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>  <span class="hljs-attr">list:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">a</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">b</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">c</span>  <span class="hljs-attr">dog:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">hehe</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">3</span></code></pre></div><p>JavaBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;        ...getter setter&#125;</code></pre></div><p>可以导入一个配置文件处理器，以后编写配置文件就会有提示了</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="1、properties配置文件在idea中默认utf-8可能会乱码"><a href="#1、properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="1、properties配置文件在idea中默认utf-8可能会乱码"></a>1、properties配置文件在idea中默认utf-8可能会乱码</h4><h4 id="2、-value和ConfigurationProperties获取值比较、Environment"><a href="#2、-value和ConfigurationProperties获取值比较、Environment" class="headerlink" title="2、@value和ConfigurationProperties获取值比较、Environment"></a>2、@value和ConfigurationProperties获取值比较、Environment</h4><p><strong>@value获取配置文件中的值</strong>(简单类型的数据绑定)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.name&#125;"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.age&#125;"</span>)<span class="hljs-keyword">private</span> Integer age;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.salary&#125;"</span>) <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;</code></pre></div><p><strong>@ConfigurationProperties获取属性值，（批量注入配置文件中的属性）</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;        ...getter setter&#125;</code></pre></div><table><thead><tr><th align="center"></th><th align="center">@ConfigUrationProperties</th><th align="center">@value</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">批量注入配置文件中的属性</td><td align="center">一个一个注入</td></tr><tr><td align="center">松散绑定</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">SqEl</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">JSR303数据校验</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center"></td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><blockquote><p>如果是在业务逻辑中只需要获取一下配置文件中某项的值那么就使用@Value</p><p>如果我们专门编写了一个javabean来和配置文件映射，我们就直接使用@ConfigurationProperties</p></blockquote><h4 id="3、配置文件注入值校验"><a href="#3、配置文件注入值校验" class="headerlink" title="3、配置文件注入值校验"></a>3、配置文件注入值校验</h4><p><code>使用@ConfigurationProperties获取配置文件值，并校验@Validated写在需要校验的属性上</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)<span class="hljs-meta">@Validated</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;   <span class="hljs-comment">//lastName必须是邮箱格式</span>    <span class="hljs-meta">@Email</span>    <span class="hljs-comment">//@Value("$&#123;person.last-name&#125;")</span>    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-comment">//@Value("#&#123;11*2&#125;")</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">//@Value("true")</span>    <span class="hljs-keyword">private</span> Boolean boss;    <span class="hljs-keyword">private</span> Date birth;    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;    <span class="hljs-keyword">private</span> Dog dog;</code></pre></div><h4 id="4、-PropertySource-amp-ImportSource"><a href="#4、-PropertySource-amp-ImportSource" class="headerlink" title="4、@PropertySource &amp;@ImportSource"></a>4、@PropertySource &amp;@ImportSource</h4><p><strong>@PropertiesSource</strong> : 加载指定的配置文件</p><blockquote><p><strong>@PropertiesSource</strong> 只能对properties 配置文件进行数据绑定**</p></blockquote><div class="hljs"><pre><code class="hljs prop"># person对象person.name&#x3D;wangyangperson.age&#x3D;18person.salary&#x3D;20000person.map.k1&#x3D;v1person.map.k2&#x3D;v2person.list&#x3D;a,b,cperson.dog.name&#x3D;heheperson.dog.age&#x3D;3</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource</span>(value = <span class="hljs-string">"classpath:person.properties"</span>)<span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;</code></pre></div><p><strong>@ImportSource</strong> :   导入Spring的配置文件，让配置文件内容生效；</p><blockquote><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别</p><p>需要在主配置类上添加@ImportSource 导入我们编写的Spring的配置类，才能让它生效</p></blockquote><p>Spring Boot 推荐的给容器中添加组件的方式，使用全注解的方式</p><p><code>配置类 === 配置文件</code></p><p>@Configuration 用来表示当前类就是一个配置类</p><p>使用@Bean给容器中添加组件（将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Configuration</span> : 用来标记 该类是个配置类</span><span class="hljs-comment"> * <span class="hljs-doctag">@Bean</span> : 将方法的返回值，作为bean对象，添加到容器中，方法名就是Bean对象在容器中的id</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"配置类@Bean给容器中添加组件"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();    &#125;&#125;</code></pre></div><h3 id="4、配置文件占位符"><a href="#4、配置文件占位符" class="headerlink" title="4、配置文件占位符"></a>4、配置文件占位符</h3><h4 id="4-1-随机数"><a href="#4-1-随机数" class="headerlink" title="4.1 随机数"></a>4.1 随机数</h4><div class="hljs"><pre><code class="hljs java">$&#123;random.value&#125;、$&#123;random.<span class="hljs-keyword">int</span>&#125;、$&#123;random.<span class="hljs-keyword">long</span>&#125;$&#123;random.<span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>)&#125;、$&#123;random.<span class="hljs-keyword">int</span>[<span class="hljs-number">1024</span>,<span class="hljs-number">65536</span>]&#125;</code></pre></div><h4 id="4-2-占位符获取之前配置的值，如果没有可以通过-：-指定默认值"><a href="#4-2-占位符获取之前配置的值，如果没有可以通过-：-指定默认值" class="headerlink" title="4.2 占位符获取之前配置的值，如果没有可以通过 ： 指定默认值"></a>4.2 占位符获取之前配置的值，如果没有可以通过 ： 指定默认值</h4><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">person.name</span>=<span class="hljs-string">wangyang$&#123;random.int&#125;</span><span class="hljs-meta">person.age</span>=<span class="hljs-string">18</span><span class="hljs-meta">person.salary</span>=<span class="hljs-string">20000</span><span class="hljs-meta">person.map.k1</span>=<span class="hljs-string">v1</span><span class="hljs-meta">person.map.k2</span>=<span class="hljs-string">v2</span><span class="hljs-meta">person.list</span>=<span class="hljs-string">a,b,c</span><span class="hljs-meta">person.dog.name</span>=<span class="hljs-string">$&#123;person.name:wang&#125;_hehe</span><span class="hljs-meta">person.dog.age</span>=<span class="hljs-string">3</span></code></pre></div><h3 id="5、profile"><a href="#5、profile" class="headerlink" title="5、profile"></a>5、profile</h3><blockquote><p>多环境配制的支持。</p><p>Profile是Spring对不同环境提供不同配置功能的支持，通过激活、指定参数等方式快速切换环境。</p></blockquote><h4 id="5-1-多profile文件形式"><a href="#5-1-多profile文件形式" class="headerlink" title="5.1     多profile文件形式"></a>5.1     多profile文件形式</h4><p>在主配置文件编写时，文件名可以是 application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h4 id="5-2-yml多文档块方式"><a href="#5-2-yml多文档块方式" class="headerlink" title="5.2    yml多文档块方式"></a>5.2    yml多文档块方式</h4><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8009</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span> <span class="hljs-comment"># 指定属于哪个环境</span></code></pre></div><h4 id="3-2-激活指定profile"><a href="#3-2-激活指定profile" class="headerlink" title="3.2    激活指定profile"></a>3.2    激活指定profile</h4><ul><li><p>在配置文件中指定<code>spring.profiles.active=dev</code></p></li><li><p>命令行：<code>--spring.profiles.active=dev</code></p><p>​                    <code>java -jar spring-boot-xxxx.jar  --spring.profiles.active=dev</code></p></li><li><p>虚拟机参数：<code>-Dspring.profiles.active=dev</code></p></li></ul><h3 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h3><p>spring boot 启动会扫描一下位置的application.properties或者application.yml文件作为spring boot的默认配置文件</p><p>-file:./config/</p><p>-file:./       当前项目的根路径下</p><p>-classpath:/config/</p><p>-classpath:/      类路径下</p><blockquote><p>按照以上优先级从高到低的顺序加载配置文件，高优先级的配置会低优先级的配置</p><p>可以通过配置<code>spring.config.location</code>来改变默认配置</p></blockquote><p>spring boot 会从这四个位置全部加载配置文件：互补配置（相同的配置内容按照优先级的高级覆盖，不同的内容互补）</p><h3 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h3><p><code>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</code></p><p><strong><code>1.命令行参数</code></strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p>==<strong>由jar包外向jar包内进行寻找；</strong>==</p><p>==<strong>优先加载带profile</strong>==</p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>==<strong>再来加载不带profile</strong>==</p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><h3 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h3><p>配置文件到底能写什么？怎么写？自动配置原理</p><p><a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><p><strong>自动配置原理</strong></p><h2 id="三、SpringBoot与日志"><a href="#三、SpringBoot与日志" class="headerlink" title="三、SpringBoot与日志"></a>三、SpringBoot与日志</h2><h3 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h3><h3 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h3><h4 id="2-1-如何在系统中使用SLF4j"><a href="#2-1-如何在系统中使用SLF4j" class="headerlink" title="2.1    如何在系统中使用SLF4j"></a>2.1    如何在系统中使用SLF4j</h4><h4 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2 遗留问题"></a>2.2 遗留问题</h4><p>不同框架使用的是不一样的日志框架</p><p>此时统一日志记录，所有框架统一起使用SLF4j进行输出</p><p><strong>如何让系统中的所有日志都统一到SLF4j;</strong></p><ol><li><p>将系统中的其他日志框架先排除出去；（不能只做排除，因为框架的底层还在使用就日志中的类）</p></li><li><p>用中间包来替换原有的日志框架</p></li><li><p>导入slf4j的实现</p></li></ol><h3 id="3、Spring-Boot-日志关系"><a href="#3、Spring-Boot-日志关系" class="headerlink" title="3、Spring Boot 日志关系"></a>3、Spring Boot 日志关系</h3><p>![springboot logging](C:\Users\wangy\Desktop\SpringBoot\img\spring boot-logging.png)</p><p>总结：</p><p>​        1)、Spring Boot底层也是使用的slf4j+logback</p><p>​        2)、spring boot  把其他日志都改成了SLF4j</p><p>​        3)、中间转换包</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFactory</span> </span>&#123;    <span class="hljs-keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="hljs-string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;    <span class="hljs-keyword">static</span> LogFactory logFactory = <span class="hljs-keyword">new</span> SLF4JLogFactory();</code></pre></div><p><img src="/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/C:%5CUsers%5Cwangy%5CDesktop%5CSpringBoot%5Cimg%5C%E4%B8%AD%E9%97%B4%E8%BD%AC%E6%8D%A2%E5%8C%85.png" srcset="/img/loading.gif" alt></p><p>4)、如果引入其他框架的。一定要把这个框架的默认日志依赖排除掉？</p><p>Spring 框架用的是commons-logging；</p><div class="hljs"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4、使用日志"><a href="#4、使用日志" class="headerlink" title="4、使用日志"></a>4、使用日志</h3><p>使用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//记录器</span>    Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//日志级别</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * trace&lt;debug&lt;info&lt;warn&lt;error</span><span class="hljs-comment">         * 由低到高，打印的信息越来越少</span><span class="hljs-comment">         * Spring boot 默认试用的是infO级别的</span><span class="hljs-comment">         */</span>        logger.trace(<span class="hljs-string">"这是trace日志。。。"</span>);        logger.debug(<span class="hljs-string">"这是debug日志。。。"</span>);        logger.info(<span class="hljs-string">"这是info日志。。。"</span>);        logger.warn(<span class="hljs-string">"这是warn日志。。。"</span>);        logger.error(<span class="hljs-string">"这是error日志。。"</span>);    &#125;</code></pre></div><p>日志文件可以在application.properties中配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># spring boot 默认的日志级别是info,我们自定义设置指定包日志的级别</span><span class="hljs-meta">logging.level.com.yang</span>=<span class="hljs-string">trace</span><span class="hljs-comment"># 设置日志的文件名,默认是在项目的根路径下</span><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">D:/myLogging</span><span class="hljs-comment"># 设置日志文件的路径</span><span class="hljs-comment"># logging.file.path</span><span class="hljs-comment"># 设置日志在控制台输出的样式</span><span class="hljs-meta">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><span class="hljs-comment"># 设置日志在文件中输出的样式</span><span class="hljs-meta">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></code></pre></div><h4 id="4-2自定义配置"><a href="#4-2自定义配置" class="headerlink" title="4.2自定义配置"></a>4.2自定义配置</h4><p>给类路径下放上每个日志框架自己的配置文件，按照指定的配置名，spring boot就不使用自己默认的配置了</p><table><thead><tr><th align="left">Logging System</th><th align="left">Customization</th></tr></thead><tbody><tr><td align="left">Logback</td><td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td align="left">Log4j2</td><td align="left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td align="left">JDK (Java Util Logging)</td><td align="left"><code>logging.properties</code></td></tr></tbody></table><p>logback.xml: 直接就被日志框架识别了</p><p>logback-spring.xml: 日志框架就能直接加载日志配置文件了，由spring boot解析日志配置，并且可以使用spring boot的高级Profile功能</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"staging"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span>  可以指定某段配置只在某个环境下生效<span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span></code></pre></div><p>如：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stdout"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        日志输出格式：</span><span class="hljs-comment">%d表示日期时间，</span><span class="hljs-comment">%thread表示线程名，</span><span class="hljs-comment">%-5level：级别从左显示5个字符宽度</span><span class="hljs-comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><span class="hljs-comment">%msg：日志消息，</span><span class="hljs-comment">%n是换行符</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"!dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre></div><p>如果使用logback.xml作为日志框架的配置，还要使用Profile功能，就会报错</p><p><code>no applicable action for [springProfile]</code></p><h3 id="5、日志切换"><a href="#5、日志切换" class="headerlink" title="5、日志切换"></a>5、日志切换</h3><p>按照slf4j的日志适配图，进行切换。</p><h2 id="四、Spring-Boot-与Web开发"><a href="#四、Spring-Boot-与Web开发" class="headerlink" title="四、Spring Boot 与Web开发"></a>四、Spring Boot 与Web开发</h2><div class="hljs"><pre><code>### 1、使用Spring Boot</code></pre></div><p>1)    创建Spring Boot 应用，选中我们需要的模块</p><p>2）Spring Boot 已经默认将这么常见配置好了，只需要 在配置文件中配置少量的配置，就可以运行起来</p><p>3）自己编写业务</p><p><strong>自动配置原理</strong></p><p>这个场景spring Boot 帮我们配置了什么? 能不能修改？能修改哪些配置？能不能扩展？</p><div class="hljs"><pre><code class="hljs xml">xxxxxAutoConfiguration: 帮我们给容器自动配置组件xxxxxProperties: 配置类来封装配置文件的内容</code></pre></div><h3 id="2、SpringBoot对静态资源的映射规则"><a href="#2、SpringBoot对静态资源的映射规则" class="headerlink" title="2、SpringBoot对静态资源的映射规则"></a>2、SpringBoot对静态资源的映射规则</h3><p><strong>1）所有/webjars/</strong> ，都去classpath:/META-INF/resources/webjars/找资源**</p><p>可以 ctrl+shift +t 去WebMvcAutoConfiguration类下查看</p><p><code>webjars: 以jar包的方式引入静态资源</code></p><p>在webjars 官网找到项目需要的依赖，在pom文件中引入</p><p><img src="/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/C:%5CUsers%5Cwangy%5CDesktop%5CSpringBoot%5Cimg%5Cjuqery-jar.png" srcset="/img/loading.gif" alt></p><p>访问路径 <a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.5.1/jquery.js</a></p><div class="hljs"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>2）”/“ 访问当前项目的任何资源，（静态文件的文件夹）</strong></p><div class="hljs"><pre><code class="hljs xml">“classpath：/META-INF/resources/”"calsspath：/rescources/""classpath：/static/""classpath: /public/""/": 当前项目的根路径</code></pre></div><p>导入准备好的静态资源到static文件夹下 clean一下就可以访问到<a href="http://localhost:8080/asserts/js/Chart.min.js" target="_blank" rel="noopener">http://localhost:8080/asserts/js/Chart.min.js</a></p><p><strong>3）欢迎页：静态资源文件下的所有index.htm，被”/</strong>“ 映射**</p><p><code>localhost:8080/ 找index页面</code></p><p><strong>4) 所有的**</strong>/favicon.ico 都在静态资源文件下找**</p><p>没有出现图标执行 Ctrl + f5 刷新浏览器页面就出现了</p><h3 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h3><p><img src="/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/C:%5CUsers%5Cwangy%5CDesktop%5CSpringBoot%5Cimg%5C%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E.png" srcset="/img/loading.gif" alt></p><p>Spring Boot 推荐 thymeleaf</p><h4 id="3-1-引入thymeleaf"><a href="#3-1-引入thymeleaf" class="headerlink" title="3.1    引入thymeleaf"></a>3.1    引入thymeleaf</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入thymeleaf--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="3-2-Thymeleaf-使用"><a href="#3-2-Thymeleaf-使用" class="headerlink" title="3.2    Thymeleaf 使用"></a>3.2    Thymeleaf 使用</h4><blockquote><p>只需要将HTML页面放在classpath:/templates/，thymeleaf就能自动渲染</p></blockquote><p>使用：</p><h5 id="1、导入thymeleaf的名称空间"><a href="#1、导入thymeleaf的名称空间" class="headerlink" title="1、导入thymeleaf的名称空间"></a>1、导入thymeleaf的名称空间</h5><div class="hljs"><pre><code class="hljs html">xmlns:th="http://www.thymeleaf.org"</code></pre></div><h5 id="2、使用thymeleaf语法；"><a href="#2、使用thymeleaf语法；" class="headerlink" title="2、使用thymeleaf语法；"></a>2、使用thymeleaf语法；</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>使用thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!--th:text将div中的内容设置为java代码绑定的数据--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;hello&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h5 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h5><p>1）、th:text    改变元素中的内容</p><p><code>使用th:html任意属性来替换原生属性的值</code></p><h5 id="2）、表达式"><a href="#2）、表达式" class="headerlink" title="2）、表达式"></a>2）、表达式</h5><table><thead><tr><th align="center">语法</th><th align="center">名称</th><th align="center">描述</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">${…}</td><td align="center">Variable Expressions</td><td align="center">变量表达式</td><td align="center">取出上下文变量的值</td></tr><tr><td align="center">*{…}</td><td align="center">Selection Variable Expressions</td><td align="center">选择变量表达式</td><td align="center">取出选择的对象的属性值</td></tr><tr><td align="center">#{…}</td><td align="center">Message Expressions</td><td align="center">消息表达式</td><td align="center">使文字消息国际化，I18N</td></tr><tr><td align="center">@{…}</td><td align="center">Link URL Expressions</td><td align="center">链接表达式</td><td align="center">用于表示各种超链接地址</td></tr><tr><td align="center">~{…}</td><td align="center">Fragment Expressions</td><td align="center">片段表达式</td><td align="center">引用一段公共的代码片段</td></tr></tbody></table><h3 id="4-Spring-MVC的自动配置"><a href="#4-Spring-MVC的自动配置" class="headerlink" title="4.Spring MVC的自动配置"></a>4.Spring MVC的自动配置</h3><h4 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h4><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p></li></ul><ul><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mvc"</span>, name = <span class="hljs-string">"date-format"</span>)<span class="hljs-comment">//在文件中配置日期格式化的规则</span><span class="hljs-function"><span class="hljs-keyword">public</span> Formatter&lt;Date&gt; <span class="hljs-title">dateFormatter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DateFormatter(<span class="hljs-keyword">this</span>.mvcProperties.getDateFormat());<span class="hljs-comment">//日期格式化组件</span>&#125;</code></pre></div><p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p></li></ul></li></ul><ul><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p><div class="hljs"><pre><code class="hljs diff">初始化WebDataBinder；请求数据<span class="hljs-comment">=====JavaBean；</span></code></pre></div></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h4 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h4><blockquote><p><strong>1.0的是继承WebMvcConfigurerAdapter类</strong></p><p><strong>2.0+是实现WebMvcConfigurer接口</strong></p></blockquote><div class="hljs"><pre><code class="hljs xm">&lt;mvc:view-controller path&#x3D;&quot;&#x2F;hello&quot; view-name&#x3D;&quot;success&quot;&#x2F;&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path&#x3D;&quot;&#x2F;hello&quot;&#x2F;&gt;            &lt;bean&gt;&lt;&#x2F;bean&gt;        &lt;&#x2F;mvc:interceptor&gt;    &lt;&#x2F;mvc:interceptors&gt;</code></pre></div><p><code>编写一个配置类（@Configuration）,是WebMvcConfigurer类型；不能标注@EnableWebMvc</code></p><p>既保留了所有的自动配置，也能用我们的扩展配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//添加自定义的视图解析器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送/he请求到success页面</span>        registry.addViewController(<span class="hljs-string">"/he"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite(); <span class="hljs-comment">//从容器中获取所有的WebMvcConfigurer</span>     <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;         <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;             <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);           <span class="hljs-comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span>           <span class="hljs-meta">@Override</span>            <span class="hljs-comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span>             <span class="hljs-comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span>              <span class="hljs-comment">//       delegate.addViewControllers(registry);</span>              <span class="hljs-comment">//   &#125;</span>             &#125;         &#125;&#125;</code></pre></div><p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​    4）、我们的配置类也会被调用；</p><p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h4 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h4><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(DelegatingWebMvcConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebMvc</span> </span>&#123;</code></pre></div><p>2）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</code></pre></div><p>3）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DispatcherServlet</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebMvcConfigurerAdapter</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">WebMvcConfigurationSupport</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">HIGHEST_PRECEDENCE</span> + 10)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ValidationAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;</code></pre></div><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h3 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h3><p>只需要把要修改的配置添加到容器中，就能被spring boot 使用到</p><p>模式：</p><p>1）Sprig Boot 在自动配置很多组件的时候，先看容器中有没有用户配置的（@Bean、@Component）如果有就使用用户配置的，没有，才自动配置；有些 组件还可以有多个（比如viewResolver）将用户的配置和自己的默认配置组合起来。</p><p> 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h3 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h3><p>准备工作：将静态资源导入工程中。引入需要的webjars，修改模板文件的引用地址。</p><h4 id="1、默认访问首页"><a href="#1、默认访问首页" class="headerlink" title="1、默认访问首页"></a>1、默认访问首页</h4><blockquote><p>可以直接在Controller中写映射，也可以在配置类中定义</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//添加自定义的视图解析器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送/he请求到success页面</span>        registry.addViewController(<span class="hljs-string">"/he"</span>).setViewName(<span class="hljs-string">"success"</span>);        <span class="hljs-comment">//默认访问登录页面</span>        registry.addViewController(<span class="hljs-string">"/"</span>).setViewName(<span class="hljs-string">"login"</span>);        registry.addViewController(<span class="hljs-string">"/login.html"</span>).setViewName(<span class="hljs-string">"login"</span>);    &#125;&#125;</code></pre></div><h4 id="2、国际化"><a href="#2、国际化" class="headerlink" title="2、国际化"></a>2、国际化</h4><h5 id="1）、编写国际化配置文件"><a href="#1）、编写国际化配置文件" class="headerlink" title="1）、编写国际化配置文件"></a>1）、编写国际化配置文件</h5><h5 id="2）、使用ResourceBundleMessage管理国际化资源文件"><a href="#2）、使用ResourceBundleMessage管理国际化资源文件" class="headerlink" title="2）、使用ResourceBundleMessage管理国际化资源文件"></a>2）、使用ResourceBundleMessage管理国际化资源文件</h5><h5 id="3）、在页面中使用ftm-message取出国际化内容"><a href="#3）、在页面中使用ftm-message取出国际化内容" class="headerlink" title="3）、在页面中使用ftm:message取出国际化内容"></a>3）、在页面中使用ftm:message取出国际化内容</h5><p>步骤：</p><h5 id="1）、编写国际化配置文件，抽取页面需要显示的国际化信息"><a href="#1）、编写国际化配置文件，抽取页面需要显示的国际化信息" class="headerlink" title="1）、编写国际化配置文件，抽取页面需要显示的国际化信息"></a>1）、编写国际化配置文件，抽取页面需要显示的国际化信息</h5>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目一实战思路</title>
    <link href="/2020/05/31/%E9%A1%B9%E7%9B%AE%E4%B8%80%E5%AE%9E%E6%88%98%E6%80%9D%E8%B7%AF/"/>
    <url>/2020/05/31/%E9%A1%B9%E7%9B%AE%E4%B8%80%E5%AE%9E%E6%88%98%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="项目一实战总结"><a href="#项目一实战总结" class="headerlink" title="项目一实战总结"></a>项目一实战总结</h1><h2 id="会员统计"><a href="#会员统计" class="headerlink" title="会员统计"></a>会员统计</h2><p>设计年龄段，0-6岁为婴儿，7-12岁为少儿，13-17岁为青少年，18-45岁为青年、46-69岁为中年、&gt;69岁为老年，为达到一目了然各个年龄段的人数高低，选择柱状图展示。</p><blockquote><p><strong>心得</strong></p><p>使用ECharts很容易达到效果，使用时我们不需要关系样式怎么设置，直接去<a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">ECharts官网</a>找到合适的案例，粘贴到页面上即可。重要的是根据案例中的数据，构造出合适的数据模型动态的赋值。</p></blockquote><h4 id="前端调用实现"><a href="#前端调用实现" class="headerlink" title="前端调用实现"></a>前端调用实现</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span>        <span class="hljs-keyword">var</span> myChart1 = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'chart1'</span>));        axios.get(<span class="hljs-string">"/report/getMemberAgeReport.do"</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;            <span class="hljs-comment">// 指定图表的配置项和数据</span>            myChart1.setOption(                &#123;                    title: &#123;                        text: <span class="hljs-string">'会员年龄分布统计'</span>                    &#125;,                    tooltip: &#123;&#125;,                    legend: &#123;                        data:[<span class="hljs-string">'年龄段人数'</span>]                    &#125;,                    xAxis: &#123;                        data: res.data.data.ageStages                    &#125;,                    yAxis: &#123;&#125;,                    series: [&#123;                        name: <span class="hljs-string">'年龄段人数'</span>,                        type: <span class="hljs-string">'bar'</span>,                        data: res.data.data.ageCountNum                    &#125;]                &#125;                );        &#125;);</code></pre></div><h4 id="后台逻辑"><a href="#后台逻辑" class="headerlink" title="后台逻辑"></a>后台逻辑</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getMemberAgeReport"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">getMemberAgeReport</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Map&lt;String,Object&gt;&gt; ageStagesMapList = memberService.findMemberCountByBirthdy();        Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        List&lt;String&gt; ageStages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();               <span class="hljs-comment">//纵坐标数据,统计每个年龄段的人数</span>        List&lt;Long&gt; ageCountNum = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(ageStagesMapList != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : ageStagesMapList) &#123;                <span class="hljs-comment">//拿到map集合&#123;name=青少年, num=12&#125;</span>                String str = (String) stringObjectMap.get(<span class="hljs-string">"name"</span>);                <span class="hljs-comment">//年龄段表示字段 x</span>                ageStages.add(str);                Long value = (Long) stringObjectMap.get(<span class="hljs-string">"num"</span>);                <span class="hljs-comment">//年龄段的值 y</span>                ageCountNum.add(value);            &#125;            <span class="hljs-comment">//将横纵坐标的list 接入map 集合</span>            data.put(<span class="hljs-string">"ageStages"</span>, ageStages);            data.put(<span class="hljs-string">"ageCountNum"</span>,ageCountNum);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, <span class="hljs-string">"查询成功"</span>, data);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, <span class="hljs-string">"查询失败"</span>);    &#125;</code></pre></div><div class="hljs"><pre><code>#### SQL</code></pre></div><div class="hljs"><pre><code class="hljs mysql">&lt;select id&#x3D;&quot;findMemberCountByBirthdy&quot; resultType&#x3D;&quot;map&quot;&gt;        SELECT t.name,COUNT(1) as num FROM (SELECT  CASE        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt; 0 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;  6  THEN &#39;婴幼儿&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;7 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   12  THEN &#39;少儿&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;13 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   17  THEN &#39;青少年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;18 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   45  THEN &#39;青年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;46 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   69  THEN &#39;中年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;79 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   89  THEN &#39;老年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;90 THEN &#39;90以上&#39;        ELSE &#39;未知&#39; END as name FROM t_member) as t GROUP BY t.name;    &lt;&#x2F;select&gt;</code></pre></div><blockquote><p><img src="http://www.qfeng.online/imgs/test-02.PNG" srcset="/img/loading.gif" alt><strong>SQL分析</strong></p><p>年龄采取四舍五入的方式，如出生日期2018-08-02，如果今天是2018-09-01差一天满，将处理为1岁显示。</p><p>如果不需要四舍五入则使用： <code>TIMESTAMPDIFF(YEAR, @birthday, CURDATE())</code></p><p>round():     函数 用于四舍五入。</p><p>DATEDIFF()：返回两个日期之间的天数。</p><p>CURDATE() 函数返回当前的日期。</p><p>注意大于号和小于号在mybatis 中转义，不转义会和标签的 &lt;&gt;混淆。</p></blockquote><blockquote><p>​    需要分析的sql</p><p>统计会员年龄分布sql ： findMemberCountByBirthdy</p></blockquote><div class="hljs"><pre><code class="hljs md">&#123;% note success %&#125;文字 或者 <span class="hljs-code">`markdown`</span> 均可&#123;% endnote %&#125;</code></pre></div><p><a href="http://www.qfeng.online/imgs/test-02.PNG" target="_blank" rel="noopener">http://www.qfeng.online/imgs/test-02.PNG</a></p><p class="class note-success">法发大水发生发放</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/29/hello-world/"/>
    <url>/2020/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
