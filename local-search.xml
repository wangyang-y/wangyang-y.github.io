<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Spring&amp;SpringBoot面试题总结</title>
    <link href="/2020/06/20/Spring-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/20/Spring-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Component-和-Bean的区别？"><a href="#1-Component-和-Bean的区别？" class="headerlink" title="1. @Component 和@ Bean的区别？"></a>1. @Component 和@ Bean的区别？</h3><p>@Component是贴在类上面的，自动检测和使用类路径扫描将bean添加到容器中。</p><p>@Bean的使用在方法上的，是将方法的返回值作为bean 注入到容器中，常和@Configuration结合使用。</p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ工作模式——简单工作模式</title>
    <link href="/2020/06/12/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/12/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.qfeng.online/imgs/RabbitMQ/rabbitmq%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" alt></p><h1 id="RabbitMQ工作模式（一）HelloWorld"><a href="#RabbitMQ工作模式（一）HelloWorld" class="headerlink" title="RabbitMQ工作模式（一）HelloWorld"></a>RabbitMQ工作模式（一）HelloWorld</h1><p><img src="https://www.qfeng.online/imgs/RabbitMQ/RabbitMQ%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt></p><div class="note note-primary">            <p>简单工作模式：生产者将消息发送到消息队列queue，消费者从该队列接受消息</p>          </div><blockquote><p>环境准备和依赖导入pom.xml文件中导入RabbitMQ的java客户端依赖<code>amqp-client</code>,配置编译插件</p></blockquote><p>pom.xml</p><div class="hljs"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;&lt;project xmlns=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>         xmlns:xsi=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>         xsi:schemaLocation=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.yang&lt;/groupId&gt;    &lt;artifactId&gt;rabiitmq-server&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!--导入rabbitmq  java客户端依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;            &lt;version&gt;5.9.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></div><blockquote><p>Provider消息提供者，创建一个消息服务者的maven项目,pom.xnl中就导入上面文件中显示的。创建Provider类，用来向消息队列发送消息。</p></blockquote><p>Rabbitmq_Provider.java</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.provider;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/12 14:50</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbitmq_Provider</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        <span class="hljs-comment">//1.创建Connection工厂</span>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//2.设置参数</span>        connectionFactory.setHost(<span class="hljs-string">"121.199.17.199"</span>);        connectionFactory.setPort(<span class="hljs-number">5672</span>);        connectionFactory.setVirtualHost(<span class="hljs-string">"/yang"</span>);  <span class="hljs-comment">//设置虚拟机，默认值是/</span>        connectionFactory.setUsername(<span class="hljs-string">"yang"</span>);        connectionFactory.setPassword(<span class="hljs-string">"yang"</span>);        <span class="hljs-comment">//3..创建connection</span>        Connection connection = connectionFactory.newConnection();        <span class="hljs-comment">//4.创建channel</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//创建exchange,由于是简单模式，不需要创建exchange，使用默认的即可</span>        <span class="hljs-comment">//5.创建queue</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *       Declare a queue</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> queue the name of the queue</span><span class="hljs-comment">         *              队列的名字</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</span><span class="hljs-comment">         *              是否持久化，当mq重启后数据还在</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</span><span class="hljs-comment">         *              如果声明独占队列(仅限于此连接)，只能有一个消费者监听此队列</span><span class="hljs-comment">         *              当connection关闭时是否自动删除</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span><span class="hljs-comment">         *             如果我们声明一个自动删除队列，自动删除为真(当它不再使用时，服务器将删除它)</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> arguments other properties (construction arguments) for the queue</span><span class="hljs-comment">         *              队列的其他属性(构造参数)</span><span class="hljs-comment">         *       <span class="hljs-doctag">@return</span> a declaration-confirm method to indicate the queue was successfully declared</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        channel.queueDeclare(<span class="hljs-string">"test-rabbitmq-provider"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//6.发送消息</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> exchange the exchange to publish the message to</span><span class="hljs-comment">         *       交换机的名称，简单模式下使用的是默认的  “”</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> routingKey the routing key</span><span class="hljs-comment">         *       路由名称，默认的交换机这里需要和queue的名字一直</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> mandatory true if the 'mandatory' flag is to be set</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> immediate true if the 'immediate' flag is to be</span><span class="hljs-comment">         *       set. Note that the RabbitMQ server does not support this flag.</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> props other properties for the message - routing headers etc</span><span class="hljs-comment">         *       匹配信息</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> body the message body</span><span class="hljs-comment">         *       发送的数据</span><span class="hljs-comment">         *       <span class="hljs-doctag">@throws</span> java.io.IOException if an error is encountered</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        String message = <span class="hljs-string">"hello rabbitmq ...."</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            channel.basicPublish(<span class="hljs-string">""</span>,<span class="hljs-string">"test-rabbitmq-provider"</span>,<span class="hljs-keyword">null</span>,message.getBytes());                    &#125;        <span class="hljs-comment">//释放资源</span>        channel.close();        connection.close();    &#125;&#125;</code></pre></div><p><strong>小结：</strong></p><ul><li>创建Connection工厂  <code>ConnectionFactory  factory =  new ConnectionFactory( );</code></li></ul><ul><li>设置Connection参数 <code>factory.setHosts (&quot;服务器名称/ip&quot;)</code> 、<code>factory.setPort(&quot;rabbitmq服务端口号&quot;)</code>、<code>connectionFactory.setVirtualHost(&quot;/yang&quot;); 设置虚拟机，默认值是/</code>、设置用户名<code>factory.setUsername(&quot;yang&quot;)</code>、设置密码<code>factory.setPassword(&quot;yang&quot;)</code></li></ul><ul><li>创建connection对象 <code>factory.newConnection()</code></li></ul><ul><li>创建channel对象<code>connection.createChannle()</code>,由于是简单工作模式，不需要创建exchange交换器，实际上使用的是默认的。</li></ul><ul><li>创建queue对象并声明queue的一些信息，缓存消息channle.queueDeclare（”消息队列名字”，durable 是否持久化，exclusive，autoDelete 是否自动删除，arguments其他属性参数）</li><li>发送消息 channel.basicPublish(exchange交换机的名字,routingKey 路由的名字，properties一些配置信息，byte[]发送的消息) <code>交换机的名字没写，“”使用默认的，routingKey和queue的名字对应</code></li></ul><blockquote><p>Consumer消费者，从queue中拿出消息</p></blockquote><p>Rabbitmq_Consumer.java</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.consumer;<span class="hljs-keyword">import</span> com.rabbitmq.client.*;<span class="hljs-keyword">import</span> com.rabbitmq.client.impl.AMQImpl;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/12 15:59</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbitmq_Consumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//1.创建连接工厂</span>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//2.设置参数</span>        factory.setHost(<span class="hljs-string">"121.199.17.199"</span>);        factory.setPort(<span class="hljs-number">5672</span>);        factory.setVirtualHost(<span class="hljs-string">"/yang"</span>);  <span class="hljs-comment">//设置虚拟机，默认值是/</span>        factory.setUsername(<span class="hljs-string">"yang"</span>);        factory.setPassword(<span class="hljs-string">"yang"</span>);        <span class="hljs-comment">//创建connection</span>        Connection connection = factory.newConnection();        <span class="hljs-comment">//创建channel</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//获取queue</span>        channel.queueDeclare(<span class="hljs-string">"test-rabbitmq-provider"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * queue： 队列名字</span><span class="hljs-comment">         * autoAsk: 是否自动确认</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-comment">//回调方法，当确认收到消息后会自动执行该方法</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * consumerTag 消息的标识</span><span class="hljs-comment">                 * envelope 获取一些信息</span><span class="hljs-comment">                 * properties 配置信息</span><span class="hljs-comment">                 * body 具体信息</span><span class="hljs-comment">                 */</span>                System.out.println(<span class="hljs-string">"consumerTag:"</span> + consumerTag);                System.out.println(<span class="hljs-string">"envelope:"</span> + envelope.getExchange());                System.out.println(<span class="hljs-string">"envelope:"</span> + envelope.getRoutingKey());                System.out.println(<span class="hljs-string">"properties:"</span> + properties);                System.out.println(<span class="hljs-string">"消息:"</span> + <span class="hljs-keyword">new</span> String(body));                System.out.println(<span class="hljs-string">"-----------------"</span>);            &#125;        &#125;;        <span class="hljs-comment">//消费消息</span>        channel.basicConsume(<span class="hljs-string">"test-rabbitmq-provider"</span>,<span class="hljs-keyword">true</span>,consumer);    &#125;&#125;</code></pre></div><p><strong>小结</strong></p><p>消费的方法调用基本和消息提供者的基本相似，注意当确认收到消息后要执行回调方法 <code>handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)</code></p><p>消费消息</p><p>channel.basicConsume(“queue名字”，autoAsk是否自动确认 ，consumer回调函数)</p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合RabbitMQ</title>
    <link href="/2020/06/12/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/"/>
    <url>/2020/06/12/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h1><div class="note note-primary">            <p>创建两个springboot工程，一个充当消息的提供者provider,另一个监听消息消费消息consumer</p>          </div><h2 id="1-创建生产者Provider"><a href="#1-创建生产者Provider" class="headerlink" title="1. 创建生产者Provider"></a>1. 创建生产者Provider</h2><p><strong>1.1  创建SpringBoot的项目</strong></p><p><strong>1.2 pom文件中导入spring-boot-starter-amqp启动器</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入rabbitmq依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>完整依赖</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.yang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--导入rabbitmq依赖--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p><strong>1.3 在application.yml中配置rabbitmq的基本属性</strong></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 配置rabbitmq的基本参数</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">121.199</span><span class="hljs-string">.xx.xxx</span>   <span class="hljs-comment"># 写自己rabbitmq运行的服务器ip</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/yang</span></code></pre></div><p><strong>1.4 编写配置类</strong></p><div class="note note-primary">            <p><strong>使用@Coonfiguration标注这个类是一个配置类</strong></p><p>在配置类中向容器中注入交换机组件Exchange，队列组件Queue、明确队列和交换机的绑定bind</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.springbootrabbitmq.config;<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/16 20:47</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootRabbitMQ</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"springboot-rabbitmq-exchange"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME= <span class="hljs-string">"springboot-rabbitmq-queue"</span>;    <span class="hljs-comment">//注入交换机组件</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bootExchange"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">bootExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//构建交换机,指定交换机类型和名字</span>        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">//注入队列</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bootQueue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">bootQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();    &#125;    <span class="hljs-comment">//交换机和队列绑定</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindQueueAndExchange</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"bootQueue"</span>)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(<span class="hljs-string">"bootExchange"</span>)</span> Exchange exchange)</span>&#123;        <span class="hljs-comment">//指定哪个队列，哪个交换机，什么routingKey，参数啥的</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">"boot.#"</span>).noargs();    &#125;&#125;</code></pre></div><blockquote><p><strong>小结：</strong></p><p>通常将<code>队列名和交换机名</code>，定义成<code>静态常量</code>方便在其他类中使用</p><p>创建交换机的时候就制定了交换机的类型<code>ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(true).build();</code></p><p>构建队列<code>QueueBuilder.durable(QUEUE_NAME).build();</code></p><p>绑定队列和交换机</p><p> <code>BindingBuilder.bind(queue).to(exchange).with(&quot;boot.#&quot;).noargs();</code></p></blockquote><h2 id="2-创建消费者Consumer"><a href="#2-创建消费者Consumer" class="headerlink" title="2.创建消费者Consumer"></a>2.创建消费者Consumer</h2><p> <strong>2.1  创建SpringBoot的项目</strong></p><p><strong>2.2 pom文件中导入spring-boot-starter-amqp启动器</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.yang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-rabbitmq-consumer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-rabbitmq-consumer<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p><strong>2.3 在application.yml中配置rabbitmq的基本属性</strong></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 配置rabbitmq的基本参数</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">121.199</span><span class="hljs-number">.17</span><span class="hljs-number">.199</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/yang</span></code></pre></div><p><strong>2.4 编写消息监听器</strong></p><div class="note note-primary">            <p><code>@RabbitListener（queues=&quot;&quot;） 监听queue的方法</code></p><p><code>Message 包含了所有的信息包括队列信息，以及配置的属性，和消息体</code></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.springbootrabbitmqconsumer.consumer;<span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/16 21:22</span><span class="hljs-comment"> * 编写消息监听器</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> </span>&#123;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"springboot-rabbitmq-queue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ListenerQueue</span><span class="hljs-params">(Message message)</span></span>&#123;        System.out.println(message);        System.out.println(<span class="hljs-keyword">new</span> String(message.getBody()));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ基础</title>
    <link href="/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ的基本概念"><a href="#RabbitMQ的基本概念" class="headerlink" title="RabbitMQ的基本概念"></a>RabbitMQ的基本概念</h1><h2 id="1-1-MQ概述"><a href="#1-1-MQ概述" class="headerlink" title="1.1 MQ概述"></a>1.1 MQ概述</h2><p>MQ全称Message Queue (消息队列)，是在消息的传输过程中<code>保存消息的容器</code>。多用于分布式系统之间进行通信。</p><div class="note note-primary">            <p>分布式系统中通信两种方式：直接远程调用和借助 第三方完成间接通信</p>          </div><p><img src="/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/C:%5CUsers%5Cwangy%5CDesktop%5Cmq%E6%A6%82%E5%BF%B5.jpg" srcset="/img/loading.gif" alt></p><h2 id="1-2-MQ的优劣势（理解）"><a href="#1-2-MQ的优劣势（理解）" class="headerlink" title="1.2 MQ的优劣势（理解）"></a>1.2 MQ的优劣势（理解）</h2><p><strong>MQ的优势</strong></p><ul><li>应用解耦： 提高系统容错性和可维护性</li><li>异步提速：提升用户体验和系统的吞吐量</li><li>削峰填谷：提高系统稳定性</li></ul><p><strong>MQ的劣势</strong></p><ul><li><p>系统的可用性降低</p><p>系统引入的外部依赖越多，系统的稳定性就越差。要保证每一部分都是完好的。一旦MQ宕机，就会对业务造成影响。就要考虑保证MQ的高可用？</p></li><li><p>系统的复杂性提高</p><p>要保证消息没有被重复消费？处理消息丢失情况？保证消息传递的顺序行？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过 MQ 给 B 、 C 、 D 三个系统发消息数据，如果 B 系统、 C 系统处理成功， D 系统处理失败。如何保证消息数据处理的一性？</p></li></ul><h2 id="1-3常见的MQ产品（了解）"><a href="#1-3常见的MQ产品（了解）" class="headerlink" title="1.3常见的MQ产品（了解）"></a>1.3常见的MQ产品（了解）</h2><p><img src="/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/C:%5CUsers%5Cwangy%5CDesktop%5C%E5%B8%B8%E8%A7%81MQ.jpg" srcset="/img/loading.gif" alt></p><h2 id="1-4-RabbitMQ简介"><a href="#1-4-RabbitMQ简介" class="headerlink" title="1.4 RabbitMQ简介"></a>1.4 RabbitMQ简介</h2><p><strong>小结</strong></p><blockquote><p>1、 RabbitMQ是基于AMQP协议使用Erlang语言开发的一款消息队列</p><p>2、RabbitMQ提供了6种工作模式</p><p>3、AMQP是协议，类比HTTP</p><p>4、JMS是API规范接口，类比JDBC</p></blockquote><h1 id="RabbitMQ的安装和配置"><a href="#RabbitMQ的安装和配置" class="headerlink" title="RabbitMQ的安装和配置"></a>RabbitMQ的安装和配置</h1><p>1、点击下载安装</p><p>2、点击Docker 镜像</p><p>3、找到最新的带界面的安装</p><p>二、拉取镜像<br>docker pull rabbitmq:3.8.0-management</p><p>三、运行镜像  4b23cfb64730  （5672是程序的端口，15672是web访问的端口）<br>docker run -d –name my-rabbitmq-management -p 5672:5672 -p 15672:15672 –hostname my-rabbitmq 4b23cfb64730<br>四、防火墙打开15672端口<br>1、放开端口</p><p>firewall-cmd –add-port=15672/tcp –permanent<br>2、重启防火墙</p><p>firewall-cmd –reload<br>五、到阿里云的安全策略组，打开15672端口</p><p>六、通过阿里云服务器的  ip:15672 就可以访问了！起始账号密码都是：guest</p><p>七、出于安全考虑，请及时修改账号密码哦！<br>1、进入docker 的 RabbitMQ 容器中</p><p>docker exec -it 647caf5c20c6 bash<br>2、查看用户</p><p>rabbitmqctl list_users<br>3、修改密码</p><p>rabbitmqctl change_password userName newPassword<br>4、如果不想要guest的账号也可以新增账号</p><p> rabbitmqctl add_user userName newPassword<br>5、看guest不爽，你还可以delete它</p><p>rabbitmqctl delete_user guest<br>6、最后别忘了给自己添加的账号增加超级管理员权限</p><p>rabbitmqctl set_user_tags userName administrator</p><h1 id="RabbitMQ快速入门"><a href="#RabbitMQ快速入门" class="headerlink" title="RabbitMQ快速入门"></a>RabbitMQ快速入门</h1><h2 id="3-1-入门程序"><a href="#3-1-入门程序" class="headerlink" title="3.1 入门程序"></a>3.1 入门程序</h2><blockquote><p>需求：使用简单模式完成消息传递</p></blockquote><h2 id="3-2-工作模式"><a href="#3-2-工作模式" class="headerlink" title="3.2 工作模式"></a>3.2 工作模式</h2><ul><li>简单工作模式</li></ul><p>​    </p><ul><li>work Queues 工作模式</li></ul><div class="hljs"><pre><code>* Pub/Sub订阅模式</code></pre></div><ul><li>Routing 路由模式</li></ul><ul><li>Topics 通配符模式</li></ul><h1 id="Spring-整合-RabbitMQ"><a href="#Spring-整合-RabbitMQ" class="headerlink" title="Spring 整合 RabbitMQ"></a>Spring 整合 RabbitMQ</h1><ul><li>生产者</li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker深入</title>
    <link href="/2020/06/09/Docker%E6%B7%B1%E5%85%A5/"/>
    <url>/2020/06/09/Docker%E6%B7%B1%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><h3 id="1、docker理念回顾"><a href="#1、docker理念回顾" class="headerlink" title="1、docker理念回顾"></a>1、docker理念回顾</h3><p>将应用和环境打包成一个镜像！</p><p><strong>问题：</strong> 如果数据都在容器中，那么我们容器删除了，数据就丢失了！比如MySql容器删除了，那么数据就丢失了。</p><p>需求:    数据可持久化（MySql数据可以存储到本地！）</p><p>因此容器之间可以有一个数据共享技术！Docker容器产生的数据，同步到本地！</p><p><code>这就是卷技术！目录的挂载,将我们容器的目录，挂载到Linux上面</code></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%8D%B7%E6%8A%80%E6%9C%AF.jpg" srcset="/img/loading.gif" alt></p><p><strong>总结容器数据卷就是：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><h3 id="1、数据卷的挂载"><a href="#1、数据卷的挂载" class="headerlink" title="1、数据卷的挂载"></a>1、数据卷的挂载</h3><blockquote><p><strong>方式一：使用命令来挂载    -v</strong>  问题：已经在运行的容器可以实现数据卷挂载吗？</p><p><strong>docker run -it -v /home/ceshi:/home centos</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 挂载 将宿主机的目录和容器的目录映射起来</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it -v /home/ceshi:/home centos</code></pre></div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 2. 查看是否挂载成功</span><span class="hljs-meta">#</span><span class="bash"> docker inspect 容器的id</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker inspect 6ff6055f21fb</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%8C%82%E8%BD%BD%E6%88%90%E5%8A%9F.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 3. 测试容器中的数据是否可以同步到宿主机</span><span class="hljs-meta">#</span><span class="bash"> 在容器中创建文件，测试是否同步到容器中</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%AE%B9%E5%99%A8%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%B5%8B%E8%AF%95.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 4. 停止容器后再重启容器，查看数据是否同步</span><span class="hljs-meta">#</span><span class="bash"> docker stop 容器id  或者 <span class="hljs-built_in">exit</span> 退出容器并停止容器</span><span class="hljs-meta">#</span><span class="bash"> docker start 容器id</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%AE%BF%E4%B8%BB%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%AD.jpg" srcset="/img/loading.gif" alt></p><h3 id="2、实践MySQL数据同步"><a href="#2、实践MySQL数据同步" class="headerlink" title="2、实践MySQL数据同步"></a>2、实践MySQL数据同步</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 获取mysql镜像</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 2. 运行容器时数据挂载</span><span class="hljs-meta">#</span><span class="bash"> mysql 启动时设置密码</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 3. 测试连接是否成功</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%B5%8B%E8%AF%95mysql%E5%AE%B9%E5%99%A8.jpg" srcset="/img/loading.gif" alt></p><h3 id="3、具名挂载和匿名挂载"><a href="#3、具名挂载和匿名挂载" class="headerlink" title="3、具名挂载和匿名挂载"></a>3、具名挂载和匿名挂载</h3><div class="note note-primary">            <p>匿名挂载 </p><p>-v 容器内的路径!</p><p>docker run -d -P –name  nginx01 -v /etc/nginx nginx</p><p>这种就是匿名挂载，我们只在 -v 后面写了容器内的路径，没有写容器外的路径</p>          </div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name nginx01 -v /etc/nginx nginx</code></pre></div><div class="note note-primary">            <p>docker  volume 对数据卷执行操作</p><p>Commands:<br>  create      Create a volume<br>  inspect     Display detailed information on one or more volumes<br>  ls          List volumes<br>  prune       Remove all unused local volumes<br>  rm          Remove one or more volumes</p>          </div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume 情况</span>docker volume ls</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%8C%BF%E5%90%8D%E5%8D%B7%E6%8C%82%E8%BD%BD.jpg" srcset="/img/loading.gif" alt></p><div class="note note-primary">            <p><strong>-v 卷名：容器名</strong></p><p><code>docker volume inspect</code> [卷名]  来查看下这个卷的信息</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/volume-inspect.jpg" srcset="/img/loading.gif" alt></p><p>所有容器中卷在没有指定目录的情况下，都在<code>/var/lib/docker/volumes/XXX/_data</code></p><p>通过具名挂载我们可以方便得找到这个卷</p><p><strong>如何去区别是具名挂载还是匿名挂载，还是指定路径挂载</strong></p><div class="hljs"><pre><code class="hljs shell">-v 容器内路径   # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机的目录：容器内的目录  #指定路径挂载</code></pre></div><p><strong>扩展：</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径：ro  rw 来改变读写权限</span>ro readonlly # 只读rw  readwrite # 可读可写<span class="hljs-meta">#</span><span class="bash"> 一旦设置了权限，那么容器中挂载出来的内容就有了限制，</span>docker run -d -P --name nginx01 -v /etc/nginx:ro nginx  # 在容器中只能读docker run -d -P --name nginx01 -v /etc/nginx:rw nginx  # 在容器中可读可写</code></pre></div><h3 id="4、初识Dockerfile"><a href="#4、初识Dockerfile" class="headerlink" title="4、初识Dockerfile"></a>4、初识Dockerfile</h3><p>Dockerfile 就是用来构建docker镜像的构建文件！命令脚本！</p><div class="note note-primary">            <p>方式二：通过Dockerfile来生成镜像</p>          </div><p><strong>编写dockerfile脚本文件</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过这个脚本可以生成镜像（指令都是大写）</span><span class="hljs-meta">#</span><span class="bash"> 这里的每条命令就是镜像的一层</span>FROM centosVOLUME ["volume01","volume02"]CMD echo "---end---"CMD /bin/bash</code></pre></div><p><strong>通过dockerfile脚本文件构建镜像</strong></p><div class="hljs"><pre><code class="hljs shell">docker build -f [dockerfile文件的路径] -t [要生成的目标镜像] .[root@iZbp1baf0xyn152a53kixrZ docker-test-volume]# docker build -f dockerfile -t wangyang/centos .</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/dockerfile%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F.jpg" srcset="/img/loading.gif" alt></p><p><strong>查看脚本生成的镜像</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E7%9A%84%E9%95%9C%E5%83%8F.jpg" srcset="/img/loading.gif" alt></p><p><strong>启动我们自己生成的容器</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker01.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker03.jpg" srcset="/img/loading.gif" alt></p><p>这个卷一定和外部的一个目录映射上了。是匿名挂载，在/var/bin/docker/可以找到这两个挂载得卷。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E9%95%9C%E5%83%8F.jpg" srcset="/img/loading.gif" alt></p><p><strong>在容器中挂载的目录下，新建个文件，测试对应的外部下是否同步了这个文件</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker00.jpg" srcset="/img/loading.gif" alt></p><h3 id="5、数据卷容器"><a href="#5、数据卷容器" class="headerlink" title="5、数据卷容器"></a>5、数据卷容器</h3><div class="note note-primary">            <p>数据卷容器就是个用来给其它容器同步数据的容器，其它容器的文件挂载到这个数据卷容器上，也就是父容器上。</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker04.jpg" srcset="/img/loading.gif" alt></p><p><strong>启动3个容器测试，通过我们刚才自己编写的镜像</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it --name docker01 6661964acee0</code></pre></div><p><strong>将docker02和docker01通过 –volumes-from同步</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it --name docker02 --volumes-from docker01 6661964acee0</code></pre></div><p><strong>在docker01的volume01中新建一个文件，查看dokcer02中是否存在</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker05.jpg" srcset="/img/loading.gif" alt></p><p><strong>再启动一个docker03和docke01同步，并在docke03中创建文件查看docker01中是否存</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it --name docker03 --volumes-from docker01 6661964acee0</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker06.jpg" srcset="/img/loading.gif" alt></p>{% note primary %}**结论：**容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦持久化到本地，那么本地的数据不会删除。{% endnote %}<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1>{% note primary %}**dockerfile是用来构建docker镜像的文件！命令参数脚本**构建步骤：1、编写一个dockerfile文件2、docker build 构建成为一个镜像3、docker run 运行镜像4、docker push 发布镜像（DockerHub、阿里云镜像仓库）{% endnote %}<p><code>可以查看官方是怎么做的，模仿官方</code></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker07.jpg" srcset="/img/loading.gif" alt></p><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p><h2 id="DockerFile的构建过程"><a href="#DockerFile的构建过程" class="headerlink" title="DockerFile的构建过程"></a>DockerFile的构建过程</h2><p><strong>基础知识</strong></p><ol><li><p>每个保留关键字（指令）都必须是大写</p></li><li><p>执行从上到下顺序执行</p></li><li><p>#表示注释</p></li><li><p>每一个指令都会创建提交一个新的镜像层，并提交。</p></li></ol><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/dockerFile08.jpg" srcset="/img/loading.gif" alt></p><p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p><p>DockerFile:  构建文件，定义了一切的步骤，</p><p>DockerImages：通过DockeFile构建生成的镜像，最终发布和运行的产品，原来是jar,war</p><p>Docker容器：是DockerImages运行起来，提供的服务。</p><h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><p>通过这些指令，自己写一个镜像</p>{% note primary %}`FROM`: 基础镜像，一切从这里开始构建`MAINTAINER`: 指定维护者信息`RUN`:镜像构建时需要运行的命令`ADD`:添加内容`WORKDIR`: 镜像的工作目录`VOLUME`: 挂载的目录`EXPOSE`：爆漏端口配置`CMD` :指定容器启动的时候要运行的命令,只有最后一个会生效，而且可以被替代`ENTRYPOINT` : 指定容器启动的时候要运行的命令,可以追加命令`COPY` :类似ADD，将我们文件拷贝到镜像中`ENV`： 构建时设置环境变量{% endnote %}<p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/dockerFile09%20%281%29.jpg" srcset="/img/loading.gif" alt></p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2>{% note primary %}Docker Hub中 99%镜像都是这个基础镜像过来的 `FROM scratch`{% endnote %}<ul><li>编写dockerfile的文件</li></ul><div class="hljs"><pre><code class="hljs shell">FROM centosMAINTAINER wangyang&lt;975594867@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo "---end---"CMD /bin/bash</code></pre></div><ul><li>通过dockerfile文件构建对象(可能下载安装vim 会失败，可以直接注释掉)</li></ul><div class="note note-primary">            <p><code>命令 docker build -f dockerfile文件名 -t  镜像名:[tag]   .</code></p>          </div><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docekr10.jpg" srcset="/img/loading.gif" alt></p><ul><li>启动 测试下（我们设置了WORKDIR 进来就在我们指定的工作目录下）</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker11.jpg" srcset="/img/loading.gif" alt></p><ul><li>可以通过 <code>docker history 镜像id</code>  来查看镜像的构建过程</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker12.jpg" srcset="/img/loading.gif" alt></p>{% note primary %}`CMD`和`ENTRYPOINT`的区别CMD 最后的命令只能替换entrypoint 可以在命令后面追加参数{% endnote %}<ul><li>测试CMD</li></ul><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ dockerfile]# vim dockerfile-test-cmd[root@iZbp1baf0xyn152a53kixrZ dockerfile]# cat dockerfile-test-cmd FROM centosCMD ["ls","-a"][root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker build -f dockerfile-test-cmd -t test-cmd .Sending build context to Docker daemon  3.072kBStep 1/2 : FROM centos<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>Step 2/2 : CMD ["ls","-a"]<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> f33a79b32463</span>Removing intermediate container f33a79b32463<span class="hljs-meta"> ---&gt;</span><span class="bash"> e5087b9ba8b4</span>Successfully built e5087b9ba8b4Successfully tagged test-cmd:latest<span class="hljs-meta">#</span><span class="bash"> 启动镜像 成功后 cmd命令执行了</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it e5087b9ba8b4.   .dockerenvdev  home  lib64       media  opt   root  sbinsys  usr..  binetc  lib   lost+found  mnt    proc  run   srvtmp  var<span class="hljs-meta">#</span><span class="bash"> 追加命令 报错</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it e5087b9ba8b4 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "exec: \"-l\": executable file not found in $PATH": unknown.</code></pre></div><ul><li>测试 ENTRYPOINT</li></ul><div class="hljs"><pre><code class="hljs shell">创建dockerfile文件[root@iZbp1baf0xyn152a53kixrZ dockerfile]# vim dockerfile-test-entryinport[root@iZbp1baf0xyn152a53kixrZ dockerfile]# cat dockerfile-test-entryinport FROM centosENTRYPOINT ["ls","-a"]<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker build -f dockerfile-test-entryinport -t test-entryinport .Sending build context to Docker daemon  4.096kBStep 1/2 : FROM centos<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>Step 2/2 : ENTRYPOINT ["ls","-a"]<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 96f23afcc451</span>Removing intermediate container 96f23afcc451<span class="hljs-meta"> ---&gt;</span><span class="bash"> 1144a7b9bae1</span>Successfully built 1144a7b9bae1Successfully tagged test-entryinport:latest<span class="hljs-meta">#</span><span class="bash"> 通过镜像启动，测试命令，这里和cmd一样的结果</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it 1144a7b9bae1.   .dockerenvdev  home  lib64       media  opt   root  sbinsys  usr..  binetc  lib   lost+found  mnt    proc  run   srvtmp  var<span class="hljs-meta">#</span><span class="bash"> 测试追加命令，entrypoint 可以追加参数</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it 1144a7b9bae1 -ltotal 0drwxr-xr-x   1 root root   6 Jun 10 10:46 .drwxr-xr-x   1 root root   6 Jun 10 10:46 ..-rwxr-xr-x   1 root root   0 Jun 10 10:46 .dockerenvlrwxrwxrwx   1 root root   7 May 11  2019 bin -&gt; usr/bindrwxr-xr-x   5 root root 360 Jun 10 10:46 devdrwxr-xr-x   1 root root  66 Jun 10 10:46 etcdrwxr-xr-x   2 root root   6 May 11  2019 homelrwxrwxrwx   1 root root   7 May 11  2019 lib -&gt; usr/liblrwxrwxrwx   1 root root   9 May 11  2019 lib64 -&gt; usr/lib64drwx------   2 root root   6 Jan 13 21:48 lost+founddrwxr-xr-x   2 root root   6 May 11  2019 mediadrwxr-xr-x   2 root root   6 May 11  2019 mntdrwxr-xr-x   2 root root   6 May 11  2019 optdr-xr-xr-x 136 root root   0 Jun 10 10:46 procdr-xr-x---   2 root root 162 Jan 13 21:49 rootdrwxr-xr-x  11 root root 163 Jan 13 21:49 runlrwxrwxrwx   1 root root   8 May 11  2019 sbin -&gt; usr/sbindrwxr-xr-x   2 root root   6 May 11  2019 srvdr-xr-xr-x  13 root root   0 Jun 10 10:46 sysdrwxrwxrwt   7 root root 145 Jan 13 21:49 tmpdrwxr-xr-x  12 root root 144 Jan 13 21:49 usrdrwxr-xr-x  20 root root 262 Jan 13 21:49 var</code></pre></div><h2 id="实战-：Tomcat镜像"><a href="#实战-：Tomcat镜像" class="headerlink" title="实战 ：Tomcat镜像"></a>实战 ：Tomcat镜像</h2><ul><li>准备镜像文件tomcat 压缩包，jdk压缩包！</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker13.jpg" srcset="/img/loading.gif" alt></p><ul><li>编写dockerfile文件，官方命令 <code>Dockerfile</code></li></ul><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><div class="note note-primary">            <p>发布镜像到DockerHub</p>          </div><p>1、<a href="https://hub.docker.com注册自己的账号！" target="_blank" rel="noopener">https://hub.docker.com注册自己的账号！</a></p><p>2、在我们的服务器上提交这个镜像</p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ buildTomcatImage]# docker login --helpUsage:docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options:  -p, --password string   Password      --password-stdin    Take the password from stdin  -u, --username string   Username</code></pre></div><p>3、登录上 之后就可以提交镜像了，就是一步 docker push</p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ buildTomcatImage]# docker login -u wangyang22Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded</code></pre></div><p>4、 提交镜像，带着版本号</p><p>docker tag 镜像id 镜像名:版本号</p><p><code>由于网络原因，可能会被拒绝</code></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ buildTomcatImage]# docker push wangyang/centos:1.0The push refers to repository [docker.io/wangyang/centos]0683de282177: Preparing denied: requested access to the resource is denied</code></pre></div><div class="note note-primary">            <p>发布镜像到阿里云镜像服务</p>          </div><p>1 .登录阿里云</p><p>2.找到容器镜像服务</p><p>3、创建命名空间</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker14.jpg" srcset="/img/loading.gif" alt></p><p>4、创建容器镜像</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker15.jpg" srcset="/img/loading.gif" alt></p><p>具体的操作参考阿里云</p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker16.jpg" srcset="/img/loading.gif" style="zoom:150%;"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker17.jpg" srcset="/img/loading.gif" alt></p><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h2><div class="note note-primary">            <p><code>ip addr</code>查看网络连接信息</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/ip-addr.jpg" srcset="/img/loading.gif" alt></p><p><strong>docker是如何处理容器网络访问的</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%AE%B9%E5%99%A8%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1.jpg" srcset="/img/loading.gif" alt></p><ul><li>启动一个tomcat容器</li></ul><div class="hljs"><pre><code class="hljs shell">docker run -d -P --name tomcat01 tomcat</code></pre></div><blockquote><p>查看容器内部网络地址，发现容器启动时都会得到一个eth0@if65 ip地址，docker分配的</p></blockquote><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever64: eth0@if65: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever<span class="hljs-meta">#</span><span class="bash"> 在宿主机上ping 一下这个容器，发现也是可以ping 通的</span>[root@iZbp1baf0xyn152a53kixrZ ~]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.086 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.070 ms64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.061 ms64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.061 ms64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.068 ms</code></pre></div><div class="note note-primary">            <p>原理：只要安装了docker,就会有一个docker0网卡，我们每启动一个docker容器，docker就会给docker容器分配一个ip。</p><p>桥接模式，使用的是veth-pair技术</p>          </div><ul><li>再次测试 ip addr 发现多了一个ip</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/veth-pair01.jpg" srcset="/img/loading.gif" alt></p><ul><li>再启动一个docker,发现又多了ip</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/veth-pair02.jpg" srcset="/img/loading.gif" alt></p><p><code>发现这些容器的网卡，都是一对一对的，这就veth-pair 一对虚拟的设备接口，都是成对出现的，一端连着协议，一端彼此相连。利用这个特性，连接各种虚拟网络设备</code></p><ul><li>测试Tomcat01 和tomcat02是否可以ping通</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1.jpg" srcset="/img/loading.gif" alt></p><p><code>容器和容器之间是可以ping通的，tomcat01 和tomcat02是公用的一个路由器也就是docker0。所有的容器不指定网络的情况下，默认都是docker0路由的，docker0会给每一容器分配一个可以用的ip</code></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>docker 使用的是linux的桥接，宿主机中是一个Docker容器的网桥docker0</p><p>Docker 中所有的网络接口都是虚拟的。虚拟的转发效率高。只要容器删除，对应的一对veth-pair就会删除。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E7%BD%91%E6%A1%A5.jpg" srcset="/img/loading.gif" alt></p><h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><p>思考一个场景，编写一个微服务，database url=ip; 项目不重启，数据库ip换了，我们希望可以通过名字来访问容器。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过容器名来访问</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Temporary failure in name resolution<span class="hljs-meta">#</span><span class="bash"> 解决不能通过容器名访问另一个容器的问题 --link</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name tomcat04 --link tomcat01 tomcat1320f2f4135933df7e11b8f8d3e8e8db10eab6959c65c2585cd24a1e1e4d2cb2[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it tomcat04 ping tomcat01PING tomcat01 (172.17.0.2) 56(84) bytes of data.64 bytes from tomcat01 (172.17.0.2): icmp_seq=1 ttl=64 time=0.153 ms64 bytes from tomcat01 (172.17.0.2): icmp_seq=2 ttl=64 time=0.089 ms64 bytes from tomcat01 (172.17.0.2): icmp_seq=3 ttl=64 time=0.103 ms64 bytes from tomcat01 (172.17.0.2): icmp_seq=4 ttl=64 time=0.086 ms<span class="hljs-meta">#</span><span class="bash"> 反向连接不可以ping通</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it tomcat01 ping tomcat04ping: tomcat04: Temporary failure in name resolution</code></pre></div><p>其实 就是 tomcat03在本地配置了tomcat02</p><p><strong>本质</strong>：–link就是在hosts配置中增加了一个172.17.0.3    tomcat02 f02eeee4ac8a</p><p>现在玩Docker已经<code>不建议使用 --link了！</code></p><p>docker0 不支持容器名访问</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><div class="note note-primary">            <p>查看网卡信息 <code>docker network ls</code></p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/network.jpg" srcset="/img/loading.gif" alt></p><p><strong>网络模式</strong></p><p>bridge :  桥接模式（默认）</p><p>host： 和主机共享网络</p><p>none:  不配置网络</p><p><strong>测试</strong></p><blockquote><p>之前我们直接启动一个容器默认是带着 <code>--net bridge</code></p><p>docker run -d -P –name tomcat01 –net bridge tomcat </p><p>​                                        ||</p><p>docker run -d -P –name tomcat01 tomcat</p><p>docker0 特点： 是默认的，容器名不访问 ，可以使用–link 连同</p></blockquote><ul><li>创建自定义的网络</li></ul><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker network create -d bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet077ded555eba6506432dfcfd57db1c59e91ff792294702a7d8a6ad3c82d531af[root@iZbp1baf0xyn152a53kixrZ ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEabe6f173e521        bridge              bridge              local45464866e7ab        host                host                local077ded555eba        mynet               bridge              local5e194fec7f08        none                null                local</code></pre></div><p><strong>我们自己创建的网络</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/mynet.jpg" srcset="/img/loading.gif" alt></p><p>使用自动以的网络启动两个容器</p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat</code></pre></div><p><strong>查看自定义网卡下的详细信息</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker network inspect mynet[    &#123;        "Name": "mynet",        "Id": "077ded555eba6506432dfcfd57db1c59e91ff792294702a7d8a6ad3c82d531af",        "Created": "2020-06-11T14:27:09.90550936+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": &#123;            "Driver": "default",            "Options": &#123;&#125;,            "Config": [                &#123;                    "Subnet": "192.168.0.0/16",                    "Gateway": "192.168.0.1"                &#125;            ]        &#125;,        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": &#123;            "Network": ""        &#125;,        "ConfigOnly": false,        "Containers": &#123;            "3bb5cbb40854c9a9741de337607481400d6b4e36afc7495f8ad8be453904933b": &#123;                "Name": "tomcat-net-02",                "EndpointID": "9772aff8ea85e9c698bacc1941dd49bbf8af23c266131b8d46e09d34957c6692",                "MacAddress": "02:42:c0:a8:00:03",                "IPv4Address": "192.168.0.3/16",                "IPv6Address": ""            &#125;,            "4515121b30deb6836e85a9de3be8549c2466e8f7d1443e4c7ee239bd63fcdd55": &#123;                "Name": "tomcat-net-01",                "EndpointID": "469f2163f5d81a113114599b936407f71ee6681880ef9934d33871ac3c5c57e3",                "MacAddress": "02:42:c0:a8:00:02",                "IPv4Address": "192.168.0.2/16",                "IPv6Address": ""            &#125;        &#125;,        "Options": &#123;&#125;,        "Labels": &#123;&#125;    &#125;]</code></pre></div><p><strong>使用自定义的网络可以容器名ping通</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E5%8F%AF%E4%BB%A5%E5%AE%B9%E5%99%A8%E5%90%8Dping.jpg" srcset="/img/loading.gif" alt></p><h2 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h2><div class="note note-primary">            <p>不在同一个网络段的容器不能之间联通，必须使用 <code>docker network connect</code> 将他们联通</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%90%91%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E8%BF%9E%E5%90%8C%E7%BD%91%E5%8D%A1%E5%92%8C%E5%AE%B9%E5%99%A8.jpg" srcset="/img/loading.gif" alt></p><p><strong>测试打通mynet 到 tomcat01</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker network connect mynet tomcat01</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/network%20connect%20ping%20%E9%80%9A%E4%BA%86%E5%AE%B9%E5%99%A8%E5%92%8Cmynet.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>连通之后查看发现，直接是将tomcat01放到mynet下</p><p>一个容器两个ip,就好比阿里云的 公网ip 和内网ip</p></blockquote><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/tomat01%E6%94%BE%E5%88%B0mynet%E4%B8%8B.jpg" srcset="/img/loading.gif" alt></p><h2 id="实战部署redis集群"><a href="#实战部署redis集群" class="headerlink" title="实战部署redis集群"></a>实战部署redis集群</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/redis%E9%9B%86%E7%BE%A4.jpg" srcset="/img/loading.gif" alt></p><h2 id="Spring-Boot-打包成Docker-镜像"><a href="#Spring-Boot-打包成Docker-镜像" class="headerlink" title="Spring Boot 打包成Docker 镜像"></a>Spring Boot 打包成Docker 镜像</h2><ol><li>创建springboot 应用</li><li>打包springboot</li><li>编写Dockerfile</li><li>上传大好的jar包和Dockerfile</li><li>构建docker镜像</li><li>发送到仓库</li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础</title>
    <link href="/2020/06/07/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/07/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Docker 学习</p><ul><li><p>Docker概述</p></li><li><p>Docker安装</p></li><li><p>Docker命令</p><ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li><p>Docker镜像！</p></li><li><p>容器数据卷！</p></li><li><p>DockerFile</p></li><li><p>Docker网络原理</p></li><li><p>IDEA整合Docker</p></li><li><p>集群 DockerCompose</p></li><li><p>Docker Swarm</p></li><li><p>CI\CD Jenkins</p></li></ul><h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么出现？"><a href="#Docker为什么出现？" class="headerlink" title="Docker为什么出现？"></a>Docker为什么出现？</h2><p>一款产品：开发–上线 两套环境！应用环境，应用配置</p><p>开发 —运维。经常会出现这种问题，在我的电脑上可以运行？到你那里就不可以运行了！版本更新，导致服务不可用！</p><p>环境配置是十分麻烦的，每一机器都要配置环境，特别麻烦浪费时间。</p><p>发布一个项目以前是发布一个jar,但是它需要运行环境。我们好需要去配置运行环境。</p><p>那么我们可以让jar + 开发环境（Redis Mysql jdk ES） 打包部署，就不需要麻烦的配置了。</p><p>之前服务器配置了一个应用环境Redis Mysql jdk ES Hadoop，配置起来很麻烦，而且还不能跨平台。那么 没换一个服务就又得重新配置一边。</p><p>传统开发： 开发jar ,运维来做部署！</p><p>现在，开发打包部署上线，一套流程做完！</p><p>我们使用java开发一个项目—&gt; 打包的时候带上环境（镜像）—&gt;将它放到Docker仓库—–&gt;下载我们发布的镜像—&gt;直接运行即可</p><p><strong>Docker 给以上的问题，提出了解决方案</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker.jpg" srcset="/img/loading.gif" alt></p><p><code>Docker的思想就来源于集装箱！</code></p><p>隔离: Docker核心思想！打包装箱！每个箱子是相互隔离的。</p><p>Docker通过隔离机制，可以将服务器运用到极致。</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>2010，几个搞IT的年轻人，在美国成立了一公司<code>dotCloud</code></p><p>做一些pass的云计算服务！linux中虚拟机有关的容器技术!</p><p>他们将自己的技术（容器化技术）命名就是Docker!</p><p>Docker刚刚诞生的时候，没有引起行业的注意！dotCloud，就活不下去了，他们想到了开源，<code>开放源代码</code>。</p><p>2013年，Docker开源！以至于越来越多的人了解，发现好用。就被广泛使用。发展的越来越好！</p><p><strong>Docker为什么这么火？</strong></p><p>虚拟机也是属于虚拟化技术，Docker容器技术，也是一种虚拟化技术。</p><p>在容器化技术发展起来的时候，我们一直使用的即使虚拟机技术。</p><p>虚拟机：在windows中装一个Vmware，通过这个软件让我们虚拟出来一个或多个电脑！但是它非常笨重。</p><div class="hljs"><pre><code class="hljs shell">vm ： linux centos原生镜像（一个电脑）几十个G的大小，启动时间久。docker ： 隔离，镜像（最核心的环境）十分的小巧，运行镜像就可以了！启动非常快</code></pre></div><blockquote><p>聊聊Docker</p></blockquote><p>Docker是基于Go语言开发的！开源项目！</p><p>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/Docs.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/mv.jpg" srcset="/img/loading.gif" alt></p><p><strong>虚拟机技术缺点：</strong></p><p>1、资源占用什么多</p><p>2、冗余步骤多</p><p>3、启动很慢</p><blockquote><p>容器化技术</p></blockquote><p>比较Docker和虚拟机技术的不同：</p><ul><li><p>传统虚拟机，直接虚拟出一个硬件，运行一个完成的操作系统，然后在这个系统上安装运行软件。</p></li><li><p>容器内的应用直接运行在宿主机的内核上，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了很多</p></li><li><p>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响。</p></li></ul><blockquote><p>DevOps（开发运维）使用Docker后的好处</p></blockquote><p><strong>应用更快捷的交付和部署</strong></p><p>传统：运维时，要看一堆帮助文档，安装程序</p><p>Docker:  打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩容</strong></p><p>项目打包成一个镜像，扩展服务器A ！服务器B</p><p><strong>更简单的系统运维</strong></p><p>容器化后，我们的开发，测试环境都高度的一致</p><p><strong>更高效的计算资源利用</strong></p><p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的实例容器，服务器的性能可以内利用到极致。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker的基本组成</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="Docker架构图"></p><p><strong>镜像（image）</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，可以创建多个容器，最终项目就运行在这些容器中</p><p><strong>容器（container）</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>目前可以把容器理解为是一个简易的linux系统</p><p><strong>仓库（repository）</strong></p><p>仓库就是来存放镜像的地方</p><p>仓库可以分为公有仓库和私有仓库</p><p>Docker Hub</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote><p>环境准备</p><p>1.需要回点Linux基础</p><p>2.CentOS7</p><p>3.使用Xshell连接远程服务进行操作</p></blockquote><blockquote><p>环境查看 uname -r</p></blockquote><p><strong>查看系统内核版本</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# uname -r4.18.0-147.8.1.el8_1.x86_64</code></pre></div><p><strong>查看linux系统版本</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# cat /etc/os-releaseNAME="CentOS Linux"VERSION="8 (Core)"ID="centos"ID_LIKE="rhel fedora"VERSION_ID="8"PLATFORM_ID="platform:el8"PRETTY_NAME="CentOS Linux 8 (Core)"ANSI_COLOR="0;31"CPE_NAME="cpe:/o:centos:centos:8"HOME_URL="https://www.centos.org/"BUG_REPORT_URL="https://bugs.centos.org/"CENTOS_MANTISBT_PROJECT="CentOS-8"CENTOS_MANTISBT_PROJECT_VERSION="8"REDHAT_SUPPORT_PRODUCT="centos"REDHAT_SUPPORT_PRODUCT_VERSION="8"</code></pre></div><blockquote><p>安装</p></blockquote> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧的版本</span>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine                  <span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置仓库的镜像</span><span class="hljs-meta">#</span><span class="bash"> 默认使用的是国外的，访问很慢，我们使用阿里云的</span>yum-config-manager \    --add-repo \http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 建议更新yum软件索引包</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4.安装docker ce 社区版 ee 企业版</span>yum install docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 5.启动docker</span>systemctl start docker</code></pre></div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 6.查看是否安装成功</span>docker version</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8Bdocker%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7.测试 通过运行hello-world 映像来验证是否正确安装了Docker Engine </span>docker run hello-world</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker-helloworld.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 8.查看一下下载的这个镜像</span>docker images</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/hello-image.jpg" srcset="/img/loading.gif" alt></p><blockquote><p><strong>了解</strong>  卸载docker  docker的默认工作路径<strong>/var/lib/docker</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.删除docker依赖</span>yum remove docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 2.删除目录</span>rm -rf /var/lib/docker</code></pre></div><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><h3 id="1-登录阿里云找到镜像服务"><a href="#1-登录阿里云找到镜像服务" class="headerlink" title="1. 登录阿里云找到镜像服务"></a>1. 登录阿里云找到镜像服务</h3><h3 id="2-找到每个人的镜像加速地址"><a href="#2-找到每个人的镜像加速地址" class="headerlink" title="2. 找到每个人的镜像加速地址"></a>2. 找到每个人的镜像加速地址</h3><h3 id="3-在镜像中心找到镜像加速器，配置使用"><a href="#3-在镜像中心找到镜像加速器，配置使用" class="headerlink" title="3. 在镜像中心找到镜像加速器，配置使用"></a>3. 在镜像中心找到镜像加速器，配置使用</h3><blockquote><p>每个人都有自己的地址</p></blockquote><div class="hljs"><pre><code class="hljs shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;  "registry-mirrors": ["https://xxxxxxxx.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><h2 id="回顾HelloWord流程"><a href="#回顾HelloWord流程" class="headerlink" title="回顾HelloWord流程"></a>回顾HelloWord流程</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/hello-world%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt="Hello world流程"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker-run.jpg" srcset="/img/loading.gif" alt="docker run"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker 是怎么工作的？</strong></p><p>Docekr是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！（类似mysql）</p><p>DockerServer接收到Docker-Clinet的指令，就会执行这个命令。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" alt></p><p><strong>Docker为什么比VM快？</strong></p><p>1、Docker有着比虚拟机更少的抽象层</p><p>2、Docker利用的是宿主机的内核，vm需要自己的Guest OS</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/vm--docker%E5%8C%BA%E5%88%AB.jpg" srcset="/img/loading.gif" alt></p><p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS 分钟级别的。而Docker是利用宿主机的操作系统，省略了这个复杂的过程，启动时秒机的。</p><h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><div class="hljs"><pre><code class="hljs shell">docekr version  # 查看docekr的版本信息docker info# 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help  # 帮助命令</code></pre></div><p><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">命令帮助文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p><strong>docker images</strong>  查看所有本地主机上的镜像</p></blockquote><div class="hljs"><pre><code class="hljs shell">root@iZbp1baf0xyn152a53kixrZ ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        5 months ago        13.3kB<span class="hljs-meta">#</span><span class="bash"> 解释</span>REPOSITORY 仓库名字TAG        标签指定版本IMAGE ID   镜像idCREATED    创建时间SIZE       大小<span class="hljs-meta">#</span><span class="bash"> 可选项</span>Options:  -a, --all             Show all images (default hides intermediate images) ## 常用  查看所有      --digests         Show digests  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print images using a Go template      --no-trunc        Don't truncate output  -q, --quiet           Only show numeric IDs   ## 常用  查看id</code></pre></div><blockquote><p><strong>docker search 搜索镜像</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker search 镜像名字</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search mysqlNAME     DESCRIPTION      STARS    OFFICIAL    AUTOMATEDmysql    MySQL is a widely used, open-source relation… 9587 [OK]mariadb   MariaDB is a community-developed fork of MyS…   3486   [OK]<span class="hljs-meta">#</span><span class="bash"> 按照星数过滤</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search mysql --filter=STARS=3000NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql               MySQL is a widely used, open-source relation…   9587                [OK]                mariadb             MariaDB is a community-developed fork of MyS…   3486                [OK]</code></pre></div><blockquote><p>docker  pull 下载镜像</p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysqlUsing default tag: latest  # 如果不写tag ,默认是下载最先版的latest: Pulling from library/mysqlafb6ec6fdc1c: Pull complete  # 分层下载 docker image 核心0bdc5971ba40: Pull complete 97ae94a2c729: Pull complete f777521d340e: Pull complete 1393ff7fc871: Pull complete a499b89994d9: Pull complete 7ebe8eefbafe: Pull complete 597069368ef1: Pull complete ce39a5501878: Pull complete 7d545bca14bf: Pull complete 211e5bb2ae7b: Pull complete 5914e537c077: Pull complete Digest: sha256:a31a277d8d39450220c722c1302a345c84206e7fd4cdb619e7face046e89031d # 防伪签名Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest  <span class="hljs-meta">#</span><span class="bash">  真实地址  docker pull mysql 等价于 docker pull docker.io/library/mysql:latest</span><span class="hljs-meta">#</span><span class="bash"> 指定版本下载</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysql:5.75.7: Pulling from library/mysqlafb6ec6fdc1c: Already exists  # 已经存在的分层0bdc5971ba40: Already exists 97ae94a2c729: Already exists f777521d340e: Already exists 1393ff7fc871: Already exists a499b89994d9: Already exists 7ebe8eefbafe: Already exists 4eec965ae405: Pull complete a531a782d709: Pull complete 270aeddb45e3: Pull complete b25569b61008: Pull complete Digest: sha256:d16d9ef7a4ecb29efcd1ba46d5a82bda3c28bd18c0f1e3b86ba54816211e1ac4Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 查看帮助命令</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull --helpUsage:docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions:  -a, --all-tags                Download all tagged images in the repository      --disable-content-trust   Skip image verification (default true)      --platform string         Set platform if server is multi-platform capable  -q, --quiet                   Suppress verbose output</code></pre></div><blockquote><p><strong>docker rmi</strong> 删除docker image </p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除指定的镜像</span>docekr rmi -f 镜像id<span class="hljs-meta">#</span><span class="bash"> 删除多个镜像</span>docker  rmi -f 镜像id 镜像id 镜像id 镜像id<span class="hljs-meta">#</span><span class="bash"> 批量删除   $(docker images -aq)作为参数</span>docker rmi -f $(docker images -aq)</code></pre></div><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><code>我们有了镜像之后，才可以创建容器，使用linux下载一个镜像来学习测试</code></p><div class="hljs"><pre><code class="hljs shell">docker pull centos</code></pre></div><blockquote><p>新建容器并启动 <code>docker run -it centos /bin/bash</code></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动容器，并进入容器</span>docker run -it centos /bin/bash[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it centos /bin/bash[root@e214ca179c15 /]# lsbin  etc   lib  lost+found  mnt  proc  run   srv  tmp  vardev  home  lib64  media       opt  root  sbin  sys  usr<span class="hljs-meta">#</span><span class="bash"> 容器停止并退出</span>[root@e214ca179c15 /]# exitexit</code></pre></div><blockquote><p><strong>退出容器</strong></p><p>容器停止并退出<br>[root@e214ca179c15 /]# exit<br>exit</p><p>容器不停止退出容器</p><p>Ctrl + P + Q</p></blockquote><blockquote><p>查看正在运行的容器 <code>docker ps</code></p><p>查看曾经运行过的容器 <code>docker ps -a</code></p><p>参数</p><p>​    无参：    列出当前正在运行的容器</p><p>​    -a :             列出当前正在运行的容器，以及停止运行的容器</p><p>​    -n=?         显示最近运行的容器 ？ 指定个数</p><p>​    -q            只显示容器编号</p></blockquote><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre></div><blockquote><p><strong>删除容器</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell">docker rm 容器id  # 删除指定容器docker rm  -f $(docker ps -aq)   #删除所有容器 docker ps -a -q | xargs docker rm -f  # 删除所有的容器</code></pre></div><blockquote><p>启动和停止容器</p></blockquote><div class="hljs"><pre><code class="hljs shell">docker start 容器id# 启动容器docker restart 容器id# 重启容器docker stop 容器id# 停止当前正在容器docker kill 容器id        # 强制停止当前运行的容器</code></pre></div><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1、后台启动命令"><a href="#1、后台启动命令" class="headerlink" title="1、后台启动命令"></a>1、后台启动命令</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker run -d 镜像名    后台启动容器</span><span class="hljs-meta">#</span><span class="bash"> 问题 docker ps， 发现容器停止了</span><span class="hljs-meta">#</span><span class="bash"> dockek容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止。</span></code></pre></div><h3 id="2、查看日志"><a href="#2、查看日志" class="headerlink" title="2、查看日志"></a>2、查看日志</h3><div class="hljs"><pre><code class="hljs shell">docker logs -ft --tail n  # 查看日志的后几条<span class="hljs-meta">#</span><span class="bash"> 显示日志</span>-tf     # 时间戳和格式--tail number    #显示日志后几条</code></pre></div><h3 id="3、查看容器中的进程命令"><a href="#3、查看容器中的进程命令" class="headerlink" title="3、查看容器中的进程命令"></a>3、查看容器中的进程命令</h3><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker top 1b4cdaa8b5aeUID    PID   PPID   C   STIME    TTY    TIME   CMDroot  20878   20862  0  08:48   pts/0 00:00:00  /bin/bash</code></pre></div><h3 id="4、查看容器的元数据"><a href="#4、查看容器的元数据" class="headerlink" title="4、查看容器的元数据"></a>4、查看容器的元数据</h3><div class="hljs"><pre><code class="hljs shell">docker inspect 容器id[root@iZbp1baf0xyn152a53kixrZ ~]# docker inspect 1b4cdaa8b5ae[    &#123;        "Id": "1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee",        "Created": "2020-06-06T07:20:02.258890351Z",        "Path": "/bin/bash",        "Args": [],        "State": &#123;            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 20878,            "ExitCode": 0,            "Error": "",            "StartedAt": "2020-06-07T00:48:12.344223612Z",            "FinishedAt": "2020-06-06T07:23:34.064971347Z"        &#125;,        "Image": "sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee",        "ResolvConfPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/resolv.conf",        "HostnamePath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/hostname",        "HostsPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/hosts",        "LogPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee-json.log",        "Name": "/heuristic_davinci",        "RestartCount": 0,        "Driver": "overlay2",        "Platform": "linux",        "MountLabel": "",        "ProcessLabel": "",        "AppArmorProfile": "",        "ExecIDs": null,        "HostConfig": &#123;            "Binds": null,            "ContainerIDFile": "",            "LogConfig": &#123;                "Type": "json-file",                "Config": &#123;&#125;            &#125;,            "NetworkMode": "default",            "PortBindings": &#123;&#125;,            "RestartPolicy": &#123;                "Name": "no",                "MaximumRetryCount": 0            &#125;,            "AutoRemove": false,            "VolumeDriver": "",            "VolumesFrom": null,            "CapAdd": null,            "CapDrop": null,            "Capabilities": null,            "Dns": [],            "DnsOptions": [],            "DnsSearch": [],            "ExtraHosts": null,            "GroupAdd": null,            "IpcMode": "private",            "Cgroup": "",            "Links": null,            "OomScoreAdj": 0,            "PidMode": "",            "Privileged": false,            "PublishAllPorts": false,            "ReadonlyRootfs": false,            "SecurityOpt": null,            "UTSMode": "",            "UsernsMode": "",            "ShmSize": 67108864,            "Runtime": "runc",            "ConsoleSize": [                0,                0            ],            "Isolation": "",            "CpuShares": 0,            "Memory": 0,            "NanoCpus": 0,            "CgroupParent": "",            "BlkioWeight": 0,            "BlkioWeightDevice": [],            "BlkioDeviceReadBps": null,            "BlkioDeviceWriteBps": null,            "BlkioDeviceReadIOps": null,            "BlkioDeviceWriteIOps": null,            "CpuPeriod": 0,            "CpuQuota": 0,            "CpuRealtimePeriod": 0,            "CpuRealtimeRuntime": 0,            "CpusetCpus": "",            "CpusetMems": "",            "Devices": [],            "DeviceCgroupRules": null,            "DeviceRequests": null,            "KernelMemory": 0,            "KernelMemoryTCP": 0,            "MemoryReservation": 0,            "MemorySwap": 0,            "MemorySwappiness": null,            "OomKillDisable": false,            "PidsLimit": null,            "Ulimits": null,            "CpuCount": 0,            "CpuPercent": 0,            "IOMaximumIOps": 0,            "IOMaximumBandwidth": 0,            "MaskedPaths": [                "/proc/asound",                "/proc/acpi",                "/proc/kcore",                "/proc/keys",                "/proc/latency_stats",                "/proc/timer_list",                "/proc/timer_stats",                "/proc/sched_debug",                "/proc/scsi",                "/sys/firmware"            ],            "ReadonlyPaths": [                "/proc/bus",                "/proc/fs",                "/proc/irq",                "/proc/sys",                "/proc/sysrq-trigger"            ]        &#125;,        "GraphDriver": &#123;            "Data": &#123;                "LowerDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72-init/diff:/var/lib/docker/overlay2/5a6f50a98473d927999ddc03f2b6b8670059cceef16c833cafb050a59fcc479c/diff",                "MergedDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/merged",                "UpperDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/diff",                "WorkDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/work"            &#125;,            "Name": "overlay2"        &#125;,        "Mounts": [],        "Config": &#123;            "Hostname": "1b4cdaa8b5ae",            "Domainname": "",            "User": "",            "AttachStdin": true,            "AttachStdout": true,            "AttachStderr": true,            "Tty": true,            "OpenStdin": true,            "StdinOnce": true,            "Env": [                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"            ],            "Cmd": [                "/bin/bash"            ],            "Image": "centos",            "Volumes": null,            "WorkingDir": "",            "Entrypoint": null,            "OnBuild": null,            "Labels": &#123;                "org.label-schema.build-date": "20200114",                "org.label-schema.license": "GPLv2",                "org.label-schema.name": "CentOS Base Image",                "org.label-schema.schema-version": "1.0",                "org.label-schema.vendor": "CentOS",                "org.opencontainers.image.created": "2020-01-14 00:00:00-08:00",                "org.opencontainers.image.licenses": "GPL-2.0-only",                "org.opencontainers.image.title": "CentOS Base Image",                "org.opencontainers.image.vendor": "CentOS"            &#125;        &#125;,        "NetworkSettings": &#123;            "Bridge": "",            "SandboxID": "438bb0e752375594c48f8ba55f4374214bd3b36cf1e9ebbc06bb8cb471f79381",            "HairpinMode": false,            "LinkLocalIPv6Address": "",            "LinkLocalIPv6PrefixLen": 0,            "Ports": &#123;&#125;,            "SandboxKey": "/var/run/docker/netns/438bb0e75237",            "SecondaryIPAddresses": null,            "SecondaryIPv6Addresses": null,            "EndpointID": "f9881ae9d0d82f56ce686875465a0b919929bf4b6a094a90f3eecf95418be7d7",            "Gateway": "172.17.0.1",            "GlobalIPv6Address": "",            "GlobalIPv6PrefixLen": 0,            "IPAddress": "172.17.0.2",            "IPPrefixLen": 16,            "IPv6Gateway": "",            "MacAddress": "02:42:ac:11:00:02",            "Networks": &#123;                "bridge": &#123;                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "abe6f173e52133983efc00c41f8b3125612c37489f7eba4898ef1fc1b1a570b5",                    "EndpointID": "f9881ae9d0d82f56ce686875465a0b919929bf4b6a094a90f3eecf95418be7d7",                    "Gateway": "172.17.0.1",                    "IPAddress": "172.17.0.2",                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:11:00:02",                    "DriverOpts": null                &#125;            &#125;        &#125;    &#125;]</code></pre></div><h3 id="5、进入当前正在运行的容器（重要）"><a href="#5、进入当前正在运行的容器（重要）" class="headerlink" title="5、进入当前正在运行的容器（重要）"></a>5、进入当前正在运行的容器（<code>重要</code>）</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通常容器都是使用后台方式运行的，我们需要进入容器，修改一些配置</span><span class="hljs-meta">#</span><span class="bash"> 方式一</span>docker exec -it 容器id /bin/bashroot@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it 1b4cdaa8b5ae /bin/bash[root@1b4cdaa8b5ae /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@1b4cdaa8b5ae /]# read escape sequence<span class="hljs-meta">#</span><span class="bash"> 方式二</span>docker attach 容器id[root@iZbp1baf0xyn152a53kixrZ ~]# docker attach 1b4cdaa8b5ae[root@1b4cdaa8b5ae /]# ls<span class="hljs-meta">#</span><span class="bash"> 区别</span><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">exec</span>  进入容器后开启一个新的终端，再在里面操作（常用）</span><span class="hljs-meta">#</span><span class="bash"> docker attach  进入容器正在执行的终端</span></code></pre></div><h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker cp 容器id:/文件所在的路径  /要复制到主机的哪个位置</span><span class="hljs-meta">#</span><span class="bash"> 注意复制时 需要退出容器</span></code></pre></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93.jpg" srcset="/img/loading.gif" alt></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="1、部署Nginx"><a href="#1、部署Nginx" class="headerlink" title="1、部署Nginx"></a>1、部署Nginx</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、搜索镜像 建议去docker Hub上搜索，可以看见版本号</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search nginx --filter=stars=10000NAME                DESCRIPTION                STARS               OFFICIAL            AUTOMATEDnginx               Official build of Nginx.   13299               [OK]<span class="hljs-meta">#</span><span class="bash"> 2、下载镜像</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxafb6ec6fdc1c: Pull complete dd3ac8106a0b: Pull complete 8de28bdda69b: Pull complete a2c431ac2669: Pull complete e070d03fd1b5: Pull complete Digest: sha256:c870bf53de0357813af37b9500cb1c2ff9fb4c00120d5fe1d75c21591293c34dStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest<span class="hljs-meta">#</span><span class="bash"> 3、启动容器 docker run -d --name nginx01 -p 3344:80 nginx</span><span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span><span class="hljs-meta">#</span><span class="bash"> --name 给容器起名字</span><span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d --name nginx01 -p 3344:80 nginx2f2205692302e8d08a27d2a6476fa50034dd2eaa3114fd422de025febe072930[root@iZbp1baf0xyn152a53kixrZ ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES2f2205692302        nginx               "/docker-entrypoint.…"   6 seconds ago       Up 4 seconds        0.0.0.0:3344-&gt;80/tcp   nginx01 <span class="hljs-meta">#</span><span class="bash"> curl localhost:端口号查看是否启动成功</span>[root@iZbp1baf0xyn152a53kixrZ ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body &#123;        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><h2 id="2、部署Tomcat"><a href="#2、部署Tomcat" class="headerlink" title="2、部署Tomcat"></a>2、部署Tomcat</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.搜素镜像</span>docker search tomcat<span class="hljs-meta">#</span><span class="bash"> 2.下载镜像</span>docker pull tomcat:9.0<span class="hljs-meta">#</span><span class="bash"> 3.创建容器，并启动，主机和容器的端口映射</span>docker run -d -name tomcat01 -p 3355:8080 tomcat:9.0<span class="hljs-meta">#</span><span class="bash"> 4.测试</span>curl localhost:8080<span class="hljs-meta">#</span><span class="bash"> 在外网访问 容器中的tomcat 会报404，解决：可以将webapps.dist下的文件复制到 webapps 下</span><span class="hljs-meta">#</span><span class="bash"> 发现问题</span><span class="hljs-meta">#</span><span class="bash"> a.容器中Tomcat的命令少了</span><span class="hljs-meta">#</span><span class="bash"> b.没有webapps.这是由于阿里云镜像的原因，默认是最小的镜像，剔除了不必要的，只保证最小的可运行环境，是一个阉割版的Tomcat</span></code></pre></div><h2 id="3、部署-ES-Kibana"><a href="#3、部署-ES-Kibana" class="headerlink" title="3、部署 ES + Kibana"></a>3、部署 ES + Kibana</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多</span><span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span><span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span><span class="hljs-meta">#</span><span class="bash"> 启动</span><span class="hljs-meta">$</span><span class="bash"> docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e <span class="hljs-string">"discovery.type=single-node"</span> elasticsearch:7.7.1</span><span class="hljs-meta">#</span><span class="bash"> 启动就很卡 docker stats 查看 cpu状态</span><span class="hljs-meta">#</span><span class="bash"> 测试完就赶紧停掉，他是非常吃内存的</span><span class="hljs-meta">#</span><span class="bash">修改配置文件 -e 环境配置</span>docker run -d --name elasticsearch02  -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.7.1</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/ES%2BKibana.jpg" srcset="/img/loading.gif" alt></p><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><ul><li>portainer(先使用这)</li></ul><div class="hljs"><pre><code class="hljs shell">docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code></pre></div><ul><li>Rancher(CI/CD再用)</li></ul><p><strong>什么是portainer?</strong></p><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p><div class="hljs"><pre><code class="hljs shell">docker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div><p>访问测试 ：<a href="http://ip:8088" target="_blank" rel="noopener">http://ip:8088</a></p><ul><li>登录页面</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer%E7%99%BB%E5%BD%95.jpg" srcset="/img/loading.gif" alt="portainer登录"></p><ul><li>进入之后选择local</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer%E9%80%89%E6%8B%A9local.jpg" srcset="/img/loading.gif" alt="portainer选择local"></p><ul><li>进来之后就可以看见我们安装的一些容器，镜像</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer01.jpg" srcset="/img/loading.gif" alt="portainer01"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer02.jpg" srcset="/img/loading.gif" alt="portainer02"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer03.jpg" srcset="/img/loading.gif" alt="portainer03"></p><h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p><code>镜像就是一种轻量级、可执行的独软件包</code>。用来打包软件运行环境和基于运行环境开的软件，它包含运行某个如那件所需要的所有内容，包括代码、运行时库、环境变量和配置文件。</p><p>所有的应用直接打包成docker镜像，就直接跑起来了。</p><p><strong>如何得到镜像：</strong></p><ul><li>从远程仓库下载</li><li>别人拷给你</li><li>自己制作一个DockerFile</li></ul><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82.jpg" srcset="/img/loading.gif" alt="docker镜像分层"></p><h2 id="如何提交一个自己的镜像commit-镜像"><a href="#如何提交一个自己的镜像commit-镜像" class="headerlink" title="如何提交一个自己的镜像commit 镜像"></a>如何提交一个自己的镜像commit 镜像</h2><div class="hljs"><pre><code class="hljs shell">docker commit 提交容器称为一个新的镜像docker commit -m="提价的描述信息" -a="作者" 容器id 目标镜像名:[tag]</code></pre></div><p><strong>实战测试</strong> </p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动一个默认的tomcat</span><span class="hljs-meta">#</span><span class="bash"> 发现这个默认的tomcat webapps中的文件夹是空的，原因是官方镜像剔除了不必要的文件</span><span class="hljs-meta">#</span><span class="bash"> 将webapps.dist 中的拷贝到webapps中</span><span class="hljs-meta">#</span><span class="bash"> 将我们操作过的镜像通过commit提交为一个镜像</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E7%9A%84image.jpg" srcset="/img/loading.gif" alt="提交自己的image"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84image.jpg" srcset="/img/loading.gif" alt="修改过的image"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%88%86%E5%B1%82%E6%93%8D%E4%BD%9C.jpg" srcset="/img/loading.gif" alt="分层操作"></p><div class="note note-primary">            <p><strong>到这里 才是入门docker</strong></p>          </div>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot整合Druid</title>
    <link href="/2020/06/05/SpringBoot%E6%95%B4%E5%90%88Druid/"/>
    <url>/2020/06/05/SpringBoot%E6%95%B4%E5%90%88Druid/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot整合Druid"><a href="#Spring-Boot整合Druid" class="headerlink" title="Spring Boot整合Druid"></a>Spring Boot整合Druid</h1><div class="note note-primary">            <p>配置数据源</p>          </div><p><strong>1、添加Druid依赖（新版本有starter）</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>2、在配置文件yml中配置数据源的链接属性</strong></p><blockquote><p>springboot 默认是使用的<code>Hikari</code>数据源,可以通过<code>spring.datasource.type</code> 切换数据源,指定数据源</p></blockquote><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 配置jdbc数据源</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>    <span class="hljs-comment"># 设置时区 serverTimeZone</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springcloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-comment"># 自定义数据源</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="hljs-comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span>    <span class="hljs-comment">#druid 数据源专有配置</span>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span>    <span class="hljs-comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span>    <span class="hljs-comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></code></pre></div><p><strong>3、导入log4j的依赖</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><blockquote><p>在resource下添加log4j配置文件 log4j.properties</p></blockquote><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG, stdout</span><span class="hljs-comment"># Console output...</span><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%5p [%t] - %m%n</span></code></pre></div><p><strong>4、自己为DruidDataSource 绑定全局配置文件中的参数，在添加到容器中，不在使用Spring Boot 自动生成了，自己添加DruidDataSources到组件到容器中，并绑定属性</strong></p><div class="note note-primary">            <ol><li><p>配置DruidDataSource数据源</p></li><li><p>配置Druid数据监控</p><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p><p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p></li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.sprinngboot.config;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<span class="hljs-keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/16 13:19</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-comment">//配置 Druid 监控管理后台的Servlet；</span>    <span class="hljs-comment">//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//配置一个servler 并设置映射路径</span>        ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(),<span class="hljs-string">"/druid/*"</span>);        <span class="hljs-comment">//设置后台的登录账号密码 key是固定的</span>        <span class="hljs-comment">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet</span>        <span class="hljs-comment">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span>        Map&lt;String,String&gt;  initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        initParams.put(<span class="hljs-string">"loginUsername"</span>,<span class="hljs-string">"root"</span>);        initParams.put(<span class="hljs-string">"loginPassword"</span>,<span class="hljs-string">"root"</span>);        <span class="hljs-comment">//后台允许谁可以访问</span>        <span class="hljs-comment">//initParams.put("allow", "localhost")：表示只有本机可以访问</span>        <span class="hljs-comment">//initParams.put("allow", "")：为空或者为null时，表示允许所有访问</span>        initParams.put(<span class="hljs-string">"allow"</span>, <span class="hljs-string">""</span>);        <span class="hljs-comment">//deny：Druid 后台拒绝谁访问</span>        <span class="hljs-comment">//initParams.put("deny", "192.168.1.20");表示禁止此ip访问</span>        <span class="hljs-comment">//设置初始化参数</span>        bean.setInitParameters(initParams);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><p>启动Spring Boot后，<code>localhost:8080/druid/login.html</code>登录查看</p><p><img src="https://www.qfeng.online/imgs/Spring-Boot/druid-web-login.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/Spring-Boot/druid-web.jpg" srcset="/img/loading.gif" alt></p><div class="note note-primary">            <p>​    <strong>配置 Druid web 监控 filter 过滤器</strong></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//配置 Druid 监控 之  web 监控的 filter</span><span class="hljs-comment">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span> </span>&#123;    FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();    bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());    <span class="hljs-comment">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span>    Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    initParams.put(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.css,/druid/*,/jdbc/*"</span>);    bean.setInitParameters(initParams);    <span class="hljs-comment">//"/*" 表示过滤所有请求</span>    bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot完整笔记</title>
    <link href="/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot-入门"><a href="#一、Spring-Boot-入门" class="headerlink" title="一、Spring Boot 入门"></a>一、Spring Boot 入门</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><blockquote><p>Spring Boot来简化Spring应用开发的框架</p><p>整个Spring技术栈的一个大整合</p><p>J2EE开发的一站式解决方案</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>微服务：一种架构风格</p><p>一个应用应该是一组小型服务；可以通过HTTP的方法是进行互通；</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软禁单元；</p><h2 id="3、Hello-World"><a href="#3、Hello-World" class="headerlink" title="3、Hello World"></a>3、Hello World</h2><p>浏览器发送hello请求，服务器接收请求并处理，响应Hello World字符串。</p><h3 id="1、创建一个maven工程"><a href="#1、创建一个maven工程" class="headerlink" title="1、创建一个maven工程"></a>1、创建一个maven工程</h3><h3 id="2、导入Spring相关依赖"><a href="#2、导入Spring相关依赖" class="headerlink" title="2、导入Spring相关依赖"></a>2、导入Spring相关依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="3、编写一个主程序，启动Spring应用"><a href="#3、编写一个主程序，启动Spring应用" class="headerlink" title="3、编写一个主程序，启动Spring应用"></a>3、编写一个主程序，启动Spring应用</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//来标注一个主程序类，表示这是一个Spring Boot的应用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Spring 应用启动起来</span>        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Spring Boot"</span>;    &#125;&#125;</code></pre></div><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--简化部署，这个插件可以将应用打包成一个可执行的jar包--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><h2 id="4、Hello-World-分析"><a href="#4、Hello-World-分析" class="headerlink" title="4、Hello World 分析"></a>4、Hello World 分析</h2><h3 id="1、POM"><a href="#1、POM" class="headerlink" title="1、POM"></a>1、POM</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><blockquote><p>​    上面的项目的父项目</p></blockquote><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>在这个项目里面真正管理了Spring Boot应用的所有依赖版本</code></pre></div><blockquote><p>Spring Boot的版本仲裁中心</p><p>以后我们导入项目默认是不需要写版本号的，当然没有在dependencies中管理的依赖还是需要声明版本号的</p></blockquote><h4 id="2、导入的依赖，启动器"><a href="#2、导入的依赖，启动器" class="headerlink" title="2、导入的依赖，启动器"></a>2、导入的依赖，启动器</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>Spring-boot-starter-web</strong></p><p>​        spirng-boot-starter ：spring-boot场景启动器；帮我们导入了web模块正常运行所需要的依赖组件</p><p> Spring Boot将所有的功能场景都抽取出来了，做成了一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p><h3 id="2、主程序类、主入口类"><a href="#2、主程序类、主入口类" class="headerlink" title="2、主程序类、主入口类"></a>2、主程序类、主入口类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//来标注一个主程序类，表示这是一个Spring Boot的应用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Spring 应用启动起来</span>        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p><code>@SpringBootApplication</code> : SpringBootApplication标注在某个类上面，就表示这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动Spring应用 </p><h2 id="5、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#5、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="5、使用Spring Initializer快速创建Spring Boot项目"></a>5、使用Spring Initializer快速创建Spring Boot项目</h2><h1 id="二、Spring-Boot-配置"><a href="#二、Spring-Boot-配置" class="headerlink" title="二、Spring Boot 配置"></a>二、Spring Boot 配置</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><blockquote><p>SpringBoot 使用一个全局的配置文件，配置文件的名是固定的</p></blockquote><p><code>application.properties</code></p><p><code>application.yml</code></p><p>配置文件的作用：修改SpringBoot自动配置的默认值；</p><p>YAML（YANL Ain’t Markup Languge）</p><p>标记语言</p><p>​        以前的配置文件；大多都使用的是 xxx.xml文件；</p><p>​        YAML ：以数据为中心，比json,xml等更加合适做配置文件</p><p>YAML:</p><div class="hljs"><pre><code class="hljs xml">server:  port: 8003</code></pre></div><p>XML:</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>        8003    <span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre></div><h2 id="2、YAML基本语法"><a href="#2、YAML基本语法" class="headerlink" title="2、YAML基本语法"></a>2、YAML基本语法</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k: （空格)v ：表示一对键值对（空格必须有）</p><p>一<strong>空格</strong>的缩进来控制层级关系；只要是左对其的一列数据，都是同一个层级</p><div class="hljs"><pre><code class="hljs xml">serverport: 8081path: /hello</code></pre></div><p><code>属性和值也是大小写敏感的</code></p><h3 id="2、指的写法"><a href="#2、指的写法" class="headerlink" title="2、指的写法"></a>2、指的写法</h3><p><strong>字面量 : 普通的值（数字，字符串，布尔）</strong></p><p>​        k:v ：字面直接来写；</p><p>​                字符串默认不用加上单引号或者双引号</p><p>​                “” : 双引号；会转义转义字符串里面的特殊字符</p><p>​                                name:    “wangyang\n lisi”    输出 wangyang 换行 lisi</p><p>​                ‘’：单引号；不会转义字符串里面的特殊字符，会原样输出字符串中的内容</p><p>​                                name:    “wangyang\n lisi”    输出 wangyang\n lisi</p><p><strong>对象、Map(属性和值) (键值对)</strong></p><p>​        k:    v ： 在下一行来写对象的属性和值的关系；注意缩进</p><p>​                对象还是K : v的方式</p><div class="hljs"><pre><code class="hljs xml">student: name: zhangsanage: 20</code></pre></div><p><strong>行内写法：</strong></p><div class="hljs"><pre><code class="hljs xml">student: &#123;name: zhangsan,age: 20&#125;</code></pre></div><p><strong>数组（List、Set）</strong>    </p><p>值表示数组中的一个元素</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">pets:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><span class="hljs-bullet">-</span> <span class="hljs-string">pig</span></code></pre></div><p>行内写法</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">pets:</span> <span class="hljs-string">[cat,dog,pig]</span></code></pre></div><h3 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h3><p>配置文件</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">wangyang</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>  <span class="hljs-attr">salary:</span> <span class="hljs-number">20000</span>  <span class="hljs-attr">map:</span>    <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>    <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>  <span class="hljs-attr">list:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">a</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">b</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">c</span>  <span class="hljs-attr">dog:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">hehe</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">3</span></code></pre></div><p>JavaBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;        ...getter setter&#125;</code></pre></div><p>可以导入一个配置文件处理器，以后编写配置文件就会有提示了</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="1、properties配置文件在idea中默认utf-8可能会乱码"><a href="#1、properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="1、properties配置文件在idea中默认utf-8可能会乱码"></a>1、properties配置文件在idea中默认utf-8可能会乱码</h4><h4 id="2、-value和ConfigurationProperties获取值比较、Environment"><a href="#2、-value和ConfigurationProperties获取值比较、Environment" class="headerlink" title="2、@value和ConfigurationProperties获取值比较、Environment"></a>2、@value和ConfigurationProperties获取值比较、Environment</h4><p><strong>@value获取配置文件中的值</strong>(简单类型的数据绑定)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.name&#125;"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.age&#125;"</span>)<span class="hljs-keyword">private</span> Integer age;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.salary&#125;"</span>) <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;</code></pre></div><p><strong>@ConfigurationProperties获取属性值，（批量注入配置文件中的属性）</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;        ...getter setter&#125;</code></pre></div><table><thead><tr><th align="center"></th><th align="center">@ConfigUrationProperties</th><th align="center">@value</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">批量注入配置文件中的属性</td><td align="center">一个一个注入</td></tr><tr><td align="center">松散绑定</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">SqEl</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">JSR303数据校验</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center"></td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><blockquote><p>如果是在业务逻辑中只需要获取一下配置文件中某项的值那么就使用@Value</p><p>如果我们专门编写了一个javabean来和配置文件映射，我们就直接使用@ConfigurationProperties</p></blockquote><h4 id="3、配置文件注入值校验"><a href="#3、配置文件注入值校验" class="headerlink" title="3、配置文件注入值校验"></a>3、配置文件注入值校验</h4><p><code>使用@ConfigurationProperties获取配置文件值，并校验@Validated写在需要校验的属性上</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)<span class="hljs-meta">@Validated</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;   <span class="hljs-comment">//lastName必须是邮箱格式</span>    <span class="hljs-meta">@Email</span>    <span class="hljs-comment">//@Value("$&#123;person.last-name&#125;")</span>    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-comment">//@Value("#&#123;11*2&#125;")</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">//@Value("true")</span>    <span class="hljs-keyword">private</span> Boolean boss;    <span class="hljs-keyword">private</span> Date birth;    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;    <span class="hljs-keyword">private</span> Dog dog;</code></pre></div><h4 id="4、-PropertySource-amp-ImportSource"><a href="#4、-PropertySource-amp-ImportSource" class="headerlink" title="4、@PropertySource &amp;@ImportSource"></a>4、@PropertySource &amp;@ImportSource</h4><p><strong>@PropertiesSource</strong> : 加载指定的配置文件</p><blockquote><p><strong>@PropertiesSource</strong> 只能对properties 配置文件进行数据绑定**</p></blockquote><div class="hljs"><pre><code class="hljs prop"># person对象person.name&#x3D;wangyangperson.age&#x3D;18person.salary&#x3D;20000person.map.k1&#x3D;v1person.map.k2&#x3D;v2person.list&#x3D;a,b,cperson.dog.name&#x3D;heheperson.dog.age&#x3D;3</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource</span>(value = <span class="hljs-string">"classpath:person.properties"</span>)<span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;</code></pre></div><p><strong>@ImportSource</strong> :   导入Spring的配置文件，让配置文件内容生效；</p><blockquote><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别</p><p>需要在主配置类上添加@ImportSource 导入我们编写的Spring的配置类，才能让它生效</p></blockquote><p>Spring Boot 推荐的给容器中添加组件的方式，使用全注解的方式</p><p><code>配置类 === 配置文件</code></p><p>@Configuration 用来表示当前类就是一个配置类</p><p>使用@Bean给容器中添加组件（将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Configuration</span> : 用来标记 该类是个配置类</span><span class="hljs-comment"> * <span class="hljs-doctag">@Bean</span> : 将方法的返回值，作为bean对象，添加到容器中，方法名就是Bean对象在容器中的id</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"配置类@Bean给容器中添加组件"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();    &#125;&#125;</code></pre></div><h3 id="4、配置文件占位符"><a href="#4、配置文件占位符" class="headerlink" title="4、配置文件占位符"></a>4、配置文件占位符</h3><h4 id="4-1-随机数"><a href="#4-1-随机数" class="headerlink" title="4.1 随机数"></a>4.1 随机数</h4><div class="hljs"><pre><code class="hljs java">$&#123;random.value&#125;、$&#123;random.<span class="hljs-keyword">int</span>&#125;、$&#123;random.<span class="hljs-keyword">long</span>&#125;$&#123;random.<span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>)&#125;、$&#123;random.<span class="hljs-keyword">int</span>[<span class="hljs-number">1024</span>,<span class="hljs-number">65536</span>]&#125;</code></pre></div><h4 id="4-2-占位符获取之前配置的值，如果没有可以通过-：-指定默认值"><a href="#4-2-占位符获取之前配置的值，如果没有可以通过-：-指定默认值" class="headerlink" title="4.2 占位符获取之前配置的值，如果没有可以通过 ： 指定默认值"></a>4.2 占位符获取之前配置的值，如果没有可以通过 ： 指定默认值</h4><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">person.name</span>=<span class="hljs-string">wangyang$&#123;random.int&#125;</span><span class="hljs-meta">person.age</span>=<span class="hljs-string">18</span><span class="hljs-meta">person.salary</span>=<span class="hljs-string">20000</span><span class="hljs-meta">person.map.k1</span>=<span class="hljs-string">v1</span><span class="hljs-meta">person.map.k2</span>=<span class="hljs-string">v2</span><span class="hljs-meta">person.list</span>=<span class="hljs-string">a,b,c</span><span class="hljs-meta">person.dog.name</span>=<span class="hljs-string">$&#123;person.name:wang&#125;_hehe</span><span class="hljs-meta">person.dog.age</span>=<span class="hljs-string">3</span></code></pre></div><h3 id="5、profile"><a href="#5、profile" class="headerlink" title="5、profile"></a>5、profile</h3><blockquote><p>多环境配制的支持。</p><p>Profile是Spring对不同环境提供不同配置功能的支持，通过激活、指定参数等方式快速切换环境。</p></blockquote><h4 id="5-1-多profile文件形式"><a href="#5-1-多profile文件形式" class="headerlink" title="5.1     多profile文件形式"></a>5.1     多profile文件形式</h4><p>在主配置文件编写时，文件名可以是 application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h4 id="5-2-yml多文档块方式"><a href="#5-2-yml多文档块方式" class="headerlink" title="5.2    yml多文档块方式"></a>5.2    yml多文档块方式</h4><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8009</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span> <span class="hljs-comment"># 指定属于哪个环境</span></code></pre></div><h4 id="3-2-激活指定profile"><a href="#3-2-激活指定profile" class="headerlink" title="3.2    激活指定profile"></a>3.2    激活指定profile</h4><ul><li><p>在配置文件中指定<code>spring.profiles.active=dev</code></p></li><li><p>命令行：<code>--spring.profiles.active=dev</code></p><p>​                    <code>java -jar spring-boot-xxxx.jar  --spring.profiles.active=dev</code></p></li><li><p>虚拟机参数：<code>-Dspring.profiles.active=dev</code></p></li></ul><h3 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h3><p>spring boot 启动会扫描一下位置的application.properties或者application.yml文件作为spring boot的默认配置文件</p><p>-file:./config/</p><p>-file:./       当前项目的根路径下</p><p>-classpath:/config/</p><p>-classpath:/      类路径下</p><blockquote><p>按照以上优先级从高到低的顺序加载配置文件，高优先级的配置会低优先级的配置</p><p>可以通过配置<code>spring.config.location</code>来改变默认配置</p></blockquote><p>spring boot 会从这四个位置全部加载配置文件：互补配置（相同的配置内容按照优先级的高级覆盖，不同的内容互补）</p><h3 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h3><p><code>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</code></p><p><strong><code>1.命令行参数</code></strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p>==<strong>由jar包外向jar包内进行寻找；</strong>==</p><p>==<strong>优先加载带profile</strong>==</p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>==<strong>再来加载不带profile</strong>==</p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><h3 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h3><p>配置文件到底能写什么？怎么写？自动配置原理</p><p><a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><p><strong>自动配置原理</strong></p><h2 id="三、SpringBoot与日志"><a href="#三、SpringBoot与日志" class="headerlink" title="三、SpringBoot与日志"></a>三、SpringBoot与日志</h2><h3 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h3><h3 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h3><h4 id="2-1-如何在系统中使用SLF4j"><a href="#2-1-如何在系统中使用SLF4j" class="headerlink" title="2.1    如何在系统中使用SLF4j"></a>2.1    如何在系统中使用SLF4j</h4><h4 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2 遗留问题"></a>2.2 遗留问题</h4><p>不同框架使用的是不一样的日志框架</p><p>此时统一日志记录，所有框架统一起使用SLF4j进行输出</p><p><strong>如何让系统中的所有日志都统一到SLF4j;</strong></p><ol><li><p>将系统中的其他日志框架先排除出去；（不能只做排除，因为框架的底层还在使用就日志中的类）</p></li><li><p>用中间包来替换原有的日志框架</p></li><li><p>导入slf4j的实现</p></li></ol><h3 id="3、Spring-Boot-日志关系"><a href="#3、Spring-Boot-日志关系" class="headerlink" title="3、Spring Boot 日志关系"></a>3、Spring Boot 日志关系</h3><p><img src="https://www.qfeng.online/imgs/Spring-Boot/springboot-log.jpg" srcset="/img/loading.gif" alt="springboot logging"></p><p>总结：</p><p>​        1)、Spring Boot底层也是使用的slf4j+logback</p><p>​        2)、spring boot  把其他日志都改成了SLF4j</p><p>​        3)、中间转换包</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFactory</span> </span>&#123;    <span class="hljs-keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="hljs-string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;    <span class="hljs-keyword">static</span> LogFactory logFactory = <span class="hljs-keyword">new</span> SLF4JLogFactory();</code></pre></div><p><img src="https://www.qfeng.online/imgs/Spring-Boot/slf4j.jpg" srcset="/img/loading.gif" alt></p><p>4)、如果引入其他框架的。一定要把这个框架的默认日志依赖排除掉？</p><p>Spring 框架用的是commons-logging；</p><div class="hljs"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4、使用日志"><a href="#4、使用日志" class="headerlink" title="4、使用日志"></a>4、使用日志</h3><p>使用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//记录器</span>    Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//日志级别</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * trace&lt;debug&lt;info&lt;warn&lt;error</span><span class="hljs-comment">         * 由低到高，打印的信息越来越少</span><span class="hljs-comment">         * Spring boot 默认试用的是infO级别的</span><span class="hljs-comment">         */</span>        logger.trace(<span class="hljs-string">"这是trace日志。。。"</span>);        logger.debug(<span class="hljs-string">"这是debug日志。。。"</span>);        logger.info(<span class="hljs-string">"这是info日志。。。"</span>);        logger.warn(<span class="hljs-string">"这是warn日志。。。"</span>);        logger.error(<span class="hljs-string">"这是error日志。。"</span>);    &#125;</code></pre></div><p>日志文件可以在application.properties中配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># spring boot 默认的日志级别是info,我们自定义设置指定包日志的级别</span><span class="hljs-meta">logging.level.com.yang</span>=<span class="hljs-string">trace</span><span class="hljs-comment"># 设置日志的文件名,默认是在项目的根路径下</span><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">D:/myLogging</span><span class="hljs-comment"># 设置日志文件的路径</span><span class="hljs-comment"># logging.file.path</span><span class="hljs-comment"># 设置日志在控制台输出的样式</span><span class="hljs-meta">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><span class="hljs-comment"># 设置日志在文件中输出的样式</span><span class="hljs-meta">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></code></pre></div><h4 id="4-2自定义配置"><a href="#4-2自定义配置" class="headerlink" title="4.2自定义配置"></a>4.2自定义配置</h4><p>给类路径下放上每个日志框架自己的配置文件，按照指定的配置名，spring boot就不使用自己默认的配置了</p><table><thead><tr><th align="left">Logging System</th><th align="left">Customization</th></tr></thead><tbody><tr><td align="left">Logback</td><td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td align="left">Log4j2</td><td align="left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td align="left">JDK (Java Util Logging)</td><td align="left"><code>logging.properties</code></td></tr></tbody></table><p>logback.xml: 直接就被日志框架识别了</p><p>logback-spring.xml: 日志框架就能直接加载日志配置文件了，由spring boot解析日志配置，并且可以使用spring boot的高级Profile功能</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"staging"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span>  可以指定某段配置只在某个环境下生效<span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span></code></pre></div><p>如：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stdout"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        日志输出格式：</span><span class="hljs-comment">%d表示日期时间，</span><span class="hljs-comment">%thread表示线程名，</span><span class="hljs-comment">%-5level：级别从左显示5个字符宽度</span><span class="hljs-comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><span class="hljs-comment">%msg：日志消息，</span><span class="hljs-comment">%n是换行符</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"!dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre></div><p>如果使用logback.xml作为日志框架的配置，还要使用Profile功能，就会报错</p><p><code>no applicable action for [springProfile]</code></p><h3 id="5、日志切换"><a href="#5、日志切换" class="headerlink" title="5、日志切换"></a>5、日志切换</h3><p>按照slf4j的日志适配图，进行切换。</p><h2 id="四、Spring-Boot-与Web开发"><a href="#四、Spring-Boot-与Web开发" class="headerlink" title="四、Spring Boot 与Web开发"></a>四、Spring Boot 与Web开发</h2><div class="hljs"><pre><code>### 1、使用Spring Boot</code></pre></div><p>1)    创建Spring Boot 应用，选中我们需要的模块</p><p>2）Spring Boot 已经默认将这么常见配置好了，只需要 在配置文件中配置少量的配置，就可以运行起来</p><p>3）自己编写业务</p><p><strong>自动配置原理</strong></p><p>这个场景spring Boot 帮我们配置了什么? 能不能修改？能修改哪些配置？能不能扩展？</p><div class="hljs"><pre><code class="hljs xml">xxxxxAutoConfiguration: 帮我们给容器自动配置组件xxxxxProperties: 配置类来封装配置文件的内容</code></pre></div><h3 id="2、SpringBoot对静态资源的映射规则"><a href="#2、SpringBoot对静态资源的映射规则" class="headerlink" title="2、SpringBoot对静态资源的映射规则"></a>2、SpringBoot对静态资源的映射规则</h3><p><strong>1）所有/webjars/</strong> ，都去classpath:/META-INF/resources/webjars/找资源**</p><p>可以 ctrl+shift +t 去WebMvcAutoConfiguration类下查看</p><p><code>webjars: 以jar包的方式引入静态资源</code></p><p>在webjars 官网找到项目需要的依赖，在pom文件中引入</p><p><img src="https://www.qfeng.online/imgs/Spring-Boot/webjars.jpg" srcset="/img/loading.gif" alt></p><p>访问路径 <a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.5.1/jquery.js</a></p><div class="hljs"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>2）”/“ 访问当前项目的任何资源，（静态文件的文件夹）</strong></p><div class="hljs"><pre><code class="hljs xml">“classpath：/META-INF/resources/”"calsspath：/rescources/""classpath：/static/""classpath: /public/""/": 当前项目的根路径</code></pre></div><p>导入准备好的静态资源到static文件夹下 clean一下就可以访问到<a href="http://localhost:8080/asserts/js/Chart.min.js" target="_blank" rel="noopener">http://localhost:8080/asserts/js/Chart.min.js</a></p><p><strong>3）欢迎页：静态资源文件下的所有index.htm，被”/</strong>“ 映射**</p><p><code>localhost:8080/ 找index页面</code></p><p><strong>4) 所有的**</strong>/favicon.ico 都在静态资源文件下找**</p><p>没有出现图标执行 Ctrl + f5 刷新浏览器页面就出现了</p><h3 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h3><p><img src="https://www.qfeng.online/imgs/Spring-Boot/thymeleaf.jpg" srcset="/img/loading.gif" alt></p><p>Spring Boot 推荐 thymeleaf</p><h4 id="3-1-引入thymeleaf"><a href="#3-1-引入thymeleaf" class="headerlink" title="3.1    引入thymeleaf"></a>3.1    引入thymeleaf</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入thymeleaf--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="3-2-Thymeleaf-使用"><a href="#3-2-Thymeleaf-使用" class="headerlink" title="3.2    Thymeleaf 使用"></a>3.2    Thymeleaf 使用</h4><blockquote><p>只需要将HTML页面放在classpath:/templates/，thymeleaf就能自动渲染</p></blockquote><p>使用：</p><h5 id="1、导入thymeleaf的名称空间"><a href="#1、导入thymeleaf的名称空间" class="headerlink" title="1、导入thymeleaf的名称空间"></a>1、导入thymeleaf的名称空间</h5><div class="hljs"><pre><code class="hljs html">xmlns:th="http://www.thymeleaf.org"</code></pre></div><h5 id="2、使用thymeleaf语法；"><a href="#2、使用thymeleaf语法；" class="headerlink" title="2、使用thymeleaf语法；"></a>2、使用thymeleaf语法；</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>使用thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!--th:text将div中的内容设置为java代码绑定的数据--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;hello&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h5 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h5><p>1）、th:text    改变元素中的内容</p><p><code>使用th:html任意属性来替换原生属性的值</code></p><h5 id="2）、表达式"><a href="#2）、表达式" class="headerlink" title="2）、表达式"></a>2）、表达式</h5><table><thead><tr><th align="center">语法</th><th align="center">名称</th><th align="center">描述</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">${…}</td><td align="center">Variable Expressions</td><td align="center">变量表达式</td><td align="center">取出上下文变量的值</td></tr><tr><td align="center">*{…}</td><td align="center">Selection Variable Expressions</td><td align="center">选择变量表达式</td><td align="center">取出选择的对象的属性值</td></tr><tr><td align="center">#{…}</td><td align="center">Message Expressions</td><td align="center">消息表达式</td><td align="center">使文字消息国际化，I18N</td></tr><tr><td align="center">@{…}</td><td align="center">Link URL Expressions</td><td align="center">链接表达式</td><td align="center">用于表示各种超链接地址</td></tr><tr><td align="center">~{…}</td><td align="center">Fragment Expressions</td><td align="center">片段表达式</td><td align="center">引用一段公共的代码片段</td></tr></tbody></table><h3 id="4-Spring-MVC的自动配置"><a href="#4-Spring-MVC的自动配置" class="headerlink" title="4.Spring MVC的自动配置"></a>4.Spring MVC的自动配置</h3><h4 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h4><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p></li></ul><ul><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mvc"</span>, name = <span class="hljs-string">"date-format"</span>)<span class="hljs-comment">//在文件中配置日期格式化的规则</span><span class="hljs-function"><span class="hljs-keyword">public</span> Formatter&lt;Date&gt; <span class="hljs-title">dateFormatter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DateFormatter(<span class="hljs-keyword">this</span>.mvcProperties.getDateFormat());<span class="hljs-comment">//日期格式化组件</span>&#125;</code></pre></div><p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p></li></ul></li></ul><ul><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p><div class="hljs"><pre><code class="hljs diff">初始化WebDataBinder；请求数据<span class="hljs-comment">=====JavaBean；</span></code></pre></div></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h4 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h4><blockquote><p><strong>1.0的是继承WebMvcConfigurerAdapter类</strong></p><p><strong>2.0+是实现WebMvcConfigurer接口</strong></p></blockquote><div class="hljs"><pre><code class="hljs xm">&lt;mvc:view-controller path&#x3D;&quot;&#x2F;hello&quot; view-name&#x3D;&quot;success&quot;&#x2F;&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path&#x3D;&quot;&#x2F;hello&quot;&#x2F;&gt;            &lt;bean&gt;&lt;&#x2F;bean&gt;        &lt;&#x2F;mvc:interceptor&gt;    &lt;&#x2F;mvc:interceptors&gt;</code></pre></div><p><code>编写一个配置类（@Configuration）,是WebMvcConfigurer类型；不能标注@EnableWebMvc</code></p><p>既保留了所有的自动配置，也能用我们的扩展配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//添加自定义的视图解析器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送/he请求到success页面</span>        registry.addViewController(<span class="hljs-string">"/he"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite(); <span class="hljs-comment">//从容器中获取所有的WebMvcConfigurer</span>     <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;         <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;             <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);           <span class="hljs-comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span>           <span class="hljs-meta">@Override</span>            <span class="hljs-comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span>             <span class="hljs-comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span>              <span class="hljs-comment">//       delegate.addViewControllers(registry);</span>              <span class="hljs-comment">//   &#125;</span>             &#125;         &#125;&#125;</code></pre></div><p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​    4）、我们的配置类也会被调用；</p><p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h4 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h4><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(DelegatingWebMvcConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebMvc</span> </span>&#123;</code></pre></div><p>2）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</code></pre></div><p>3）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DispatcherServlet</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebMvcConfigurerAdapter</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">WebMvcConfigurationSupport</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">HIGHEST_PRECEDENCE</span> + 10)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ValidationAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;</code></pre></div><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h3 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h3><p>只需要把要修改的配置添加到容器中，就能被spring boot 使用到</p><p>模式：</p><p>1）Sprig Boot 在自动配置很多组件的时候，先看容器中有没有用户配置的（@Bean、@Component）如果有就使用用户配置的，没有，才自动配置；有些 组件还可以有多个（比如viewResolver）将用户的配置和自己的默认配置组合起来。</p><p> 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h3 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h3><p>准备工作：将静态资源导入工程中。引入需要的webjars，修改模板文件的引用地址。</p><h4 id="1、默认访问首页"><a href="#1、默认访问首页" class="headerlink" title="1、默认访问首页"></a>1、默认访问首页</h4><blockquote><p>可以直接在Controller中写映射，也可以在配置类中定义</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//添加自定义的视图解析器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送/he请求到success页面</span>        registry.addViewController(<span class="hljs-string">"/he"</span>).setViewName(<span class="hljs-string">"success"</span>);        <span class="hljs-comment">//默认访问登录页面</span>        registry.addViewController(<span class="hljs-string">"/"</span>).setViewName(<span class="hljs-string">"login"</span>);        registry.addViewController(<span class="hljs-string">"/login.html"</span>).setViewName(<span class="hljs-string">"login"</span>);    &#125;&#125;</code></pre></div><h4 id="2、国际化"><a href="#2、国际化" class="headerlink" title="2、国际化"></a>2、国际化</h4><h5 id="1）、编写国际化配置文件"><a href="#1）、编写国际化配置文件" class="headerlink" title="1）、编写国际化配置文件"></a>1）、编写国际化配置文件</h5><h5 id="2）、使用ResourceBundleMessage管理国际化资源文件"><a href="#2）、使用ResourceBundleMessage管理国际化资源文件" class="headerlink" title="2）、使用ResourceBundleMessage管理国际化资源文件"></a>2）、使用ResourceBundleMessage管理国际化资源文件</h5><h5 id="3）、在页面中使用ftm-message取出国际化内容"><a href="#3）、在页面中使用ftm-message取出国际化内容" class="headerlink" title="3）、在页面中使用ftm:message取出国际化内容"></a>3）、在页面中使用ftm:message取出国际化内容</h5><p>步骤：</p><h5 id="1）、编写国际化配置文件，抽取页面需要显示的国际化信息"><a href="#1）、编写国际化配置文件，抽取页面需要显示的国际化信息" class="headerlink" title="1）、编写国际化配置文件，抽取页面需要显示的国际化信息"></a>1）、编写国际化配置文件，抽取页面需要显示的国际化信息</h5>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目一实战思路</title>
    <link href="/2020/05/31/%E9%A1%B9%E7%9B%AE%E4%B8%80%E5%AE%9E%E6%88%98%E6%80%9D%E8%B7%AF/"/>
    <url>/2020/05/31/%E9%A1%B9%E7%9B%AE%E4%B8%80%E5%AE%9E%E6%88%98%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="项目一实战总结"><a href="#项目一实战总结" class="headerlink" title="项目一实战总结"></a>项目一实战总结</h1><h2 id="会员统计"><a href="#会员统计" class="headerlink" title="会员统计"></a>会员统计</h2><p>设计年龄段，0-6岁为婴儿，7-12岁为少儿，13-17岁为青少年，18-45岁为青年、46-69岁为中年、&gt;69岁为老年，为达到一目了然各个年龄段的人数高低，选择柱状图展示。</p><blockquote><p><strong>心得</strong></p><p>使用ECharts很容易达到效果，使用时我们不需要关系样式怎么设置，直接去<a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">ECharts官网</a>找到合适的案例，粘贴到页面上即可。重要的是根据案例中的数据，构造出合适的数据模型动态的赋值。</p></blockquote><h4 id="前端调用实现"><a href="#前端调用实现" class="headerlink" title="前端调用实现"></a>前端调用实现</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span>        <span class="hljs-keyword">var</span> myChart1 = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'chart1'</span>));        axios.get(<span class="hljs-string">"/report/getMemberAgeReport.do"</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;            <span class="hljs-comment">// 指定图表的配置项和数据</span>            myChart1.setOption(                &#123;                    title: &#123;                        text: <span class="hljs-string">'会员年龄分布统计'</span>                    &#125;,                    tooltip: &#123;&#125;,                    legend: &#123;                        data:[<span class="hljs-string">'年龄段人数'</span>]                    &#125;,                    xAxis: &#123;                        data: res.data.data.ageStages                    &#125;,                    yAxis: &#123;&#125;,                    series: [&#123;                        name: <span class="hljs-string">'年龄段人数'</span>,                        type: <span class="hljs-string">'bar'</span>,                        data: res.data.data.ageCountNum                    &#125;]                &#125;                );        &#125;);</code></pre></div><h4 id="后台逻辑"><a href="#后台逻辑" class="headerlink" title="后台逻辑"></a>后台逻辑</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getMemberAgeReport"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">getMemberAgeReport</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Map&lt;String,Object&gt;&gt; ageStagesMapList = memberService.findMemberCountByBirthdy();        Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        List&lt;String&gt; ageStages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();               <span class="hljs-comment">//纵坐标数据,统计每个年龄段的人数</span>        List&lt;Long&gt; ageCountNum = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(ageStagesMapList != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : ageStagesMapList) &#123;                <span class="hljs-comment">//拿到map集合&#123;name=青少年, num=12&#125;</span>                String str = (String) stringObjectMap.get(<span class="hljs-string">"name"</span>);                <span class="hljs-comment">//年龄段表示字段 x</span>                ageStages.add(str);                Long value = (Long) stringObjectMap.get(<span class="hljs-string">"num"</span>);                <span class="hljs-comment">//年龄段的值 y</span>                ageCountNum.add(value);            &#125;            <span class="hljs-comment">//将横纵坐标的list 接入map 集合</span>            data.put(<span class="hljs-string">"ageStages"</span>, ageStages);            data.put(<span class="hljs-string">"ageCountNum"</span>,ageCountNum);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, <span class="hljs-string">"查询成功"</span>, data);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, <span class="hljs-string">"查询失败"</span>);    &#125;</code></pre></div><div class="hljs"><pre><code>#### SQL</code></pre></div><div class="hljs"><pre><code class="hljs mysql">&lt;select id&#x3D;&quot;findMemberCountByBirthdy&quot; resultType&#x3D;&quot;map&quot;&gt;        SELECT t.name,COUNT(1) as num FROM (SELECT  CASE        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt; 0 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;  6  THEN &#39;婴幼儿&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;7 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   12  THEN &#39;少儿&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;13 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   17  THEN &#39;青少年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;18 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   45  THEN &#39;青年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;46 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   69  THEN &#39;中年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;79 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   89  THEN &#39;老年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;90 THEN &#39;90以上&#39;        ELSE &#39;未知&#39; END as name FROM t_member) as t GROUP BY t.name;    &lt;&#x2F;select&gt;</code></pre></div><blockquote><p><img src="http://www.qfeng.online/imgs/test-02.PNG" srcset="/img/loading.gif" alt><strong>SQL分析</strong></p><p>年龄采取四舍五入的方式，如出生日期2018-08-02，如果今天是2018-09-01差一天满，将处理为1岁显示。</p><p>如果不需要四舍五入则使用： <code>TIMESTAMPDIFF(YEAR, @birthday, CURDATE())</code></p><p>round():     函数 用于四舍五入。</p><p>DATEDIFF()：返回两个日期之间的天数。</p><p>CURDATE() 函数返回当前的日期。</p><p>注意大于号和小于号在mybatis 中转义，不转义会和标签的 &lt;&gt;混淆。</p></blockquote><blockquote><p>​    需要分析的sql</p><p>统计会员年龄分布sql ： findMemberCountByBirthdy</p></blockquote><div class="hljs"><pre><code class="hljs md">&#123;% note success %&#125;文字 或者 <span class="hljs-code">`markdown`</span> 均可&#123;% endnote %&#125;</code></pre></div><p><a href="http://www.qfeng.online/imgs/test-02.PNG" target="_blank" rel="noopener">http://www.qfeng.online/imgs/test-02.PNG</a></p><p class="class note-success">法发大水发生发放</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/29/hello-world/"/>
    <url>/2020/05/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux下安装jdk</title>
    <link href="/2020/05/20/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/"/>
    <url>/2020/05/20/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/</url>
    
    <content type="html"><![CDATA[<h3 id="一、下载jdk"><a href="#一、下载jdk" class="headerlink" title="一、下载jdk"></a>一、下载jdk</h3><p>下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Oracle官网</a></p><p>选择下载tar包</p><h3 id="二、卸载已有jdk"><a href="#二、卸载已有jdk" class="headerlink" title="二、卸载已有jdk"></a>二、卸载已有jdk</h3><p>1、查看已安装jdk <code>rpm -qa | grep java</code></p><div class="hljs"><pre><code class="hljs shell">[root@slave1 sbin]# rpm -qa | grep javajavapackages-tools-3.4.1-11.el7.noarchjava-1.8.0-openjdk-1.8.0.242.b08-1.el7.x86_64tzdata-java-2019c-1.el7.noarchjava-1.8.0-openjdk-headless-1.8.0.242.b08-1.el7.x86_64java-1.7.0-openjdk-1.7.0.251-2.6.21.1.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.251-2.6.21.1.el7.x86_64python-javapackages-3.4.1-11.el7.noarch</code></pre></div><p>2、卸载已有的jdk</p><p><code>rpm -e --nodeps javapackages-tools-3.4.1-11.el7.noarch</code></p><div class="hljs"><pre><code class="hljs shell">[root@slave1 sbin]# rpm -e --nodeps javapackages-tools-3.4.1-11.el7.noarch java-1.8.0-openjdk-1.8.0.242.b08-1.el7.x86_64 tzdata-java-2019c-1.el7.noarch java-1.8.0-openjdk-headless-1.8.0.242.b08-1.el7.x86_64 java-1.7.0-openjdk-1.7.0.251-2.6.21.1.el7.x86_64 java-1.7.0-openjdk-headless-1.7.0.251-2.6.21.1.el7.x86_64 python-javapackages-3.4.1-11.el7.noarch</code></pre></div>{% note primary %}**注意：** 如果使用rpm -qa | grep java 命令没有查到jdk包，但是使用java -version 命令却可以看到jdk版本，可以使用which java 命令查看java命令的执行路径，然后找到对应的jdk文件删除。{% endnote %}<h3 id="三、安装jdk"><a href="#三、安装jdk" class="headerlink" title="三、安装jdk"></a>三、安装jdk</h3><ol><li>将下载好的安装包 jdk-8u151-linux-x64.tar.gz 上传到服务器指定目录下,我的是 /usr/local/yang/；</li><li>解压安装包 <code>tar -zxvf jdk-8u151-linux-x64.tar.gz</code></li></ol><p><img src="https://www.qfeng.online/imgs/jdk/jdk_2020-06-20_10-54-05.jpg" srcset="/img/loading.gif" alt></p><ol start="3"><li>添加环境变量： 编辑/etc/profile 文件 ： vim /etc/profile ,添加如下内容</li></ol><div class="hljs"><pre><code class="hljs shell">JAVA_HOME=/usr/local/yang/jdk1.8.0_151CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH</code></pre></div><ol start="4"><li>重新加载配置文件 <code>source /etc/profile</code></li></ol><div class="hljs"><pre><code class="hljs shell">[root@slave1 lib]# source /etc/profile</code></pre></div><ol start="5"><li>使用<code>java -version</code> 查看是否安装成功</li></ol><div class="hljs"><pre><code class="hljs shell">[root@slave1 lib]# java -versionjava version "1.8.0_151"Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</code></pre></div><blockquote><p>安装成功</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>environment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
