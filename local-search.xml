<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>screw生成数据库文档</title>
    <link href="/2020/08/28/screw%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E6%A1%A3/"/>
    <url>/2020/08/28/screw%E7%94%9F%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="一键生成数据库文档，堪称数据库界的Swagger，有点厉害"><a href="#一键生成数据库文档，堪称数据库界的Swagger，有点厉害" class="headerlink" title="一键生成数据库文档，堪称数据库界的Swagger，有点厉害!"></a>一键生成数据库文档，堪称数据库界的Swagger，有点厉害!</h2><h3 id="数据库支持"><a href="#数据库支持" class="headerlink" title="数据库支持"></a>数据库支持</h3><ul><li>MySQL</li><li>MariaDB</li><li>TIDB</li><li>Oracle</li><li>SqlServer</li><li>PostgreSQL</li><li>Cache DB</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><blockquote><h3 id="1、pom文件"><a href="#1、pom文件" class="headerlink" title="1、pom文件"></a>1、pom文件</h3></blockquote><p>引入<code>screw</code>核心包，<code>HikariCP</code>数据库连接池，<code>HikariCP</code>号称性能最出色的数据库连接池。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- screw核心 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.smallbun.screw<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>screw-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- HikariCP --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zaxxer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HikariCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--mysql driver--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><blockquote><h3 id="2、配置数据源"><a href="#2、配置数据源" class="headerlink" title="2、配置数据源"></a>2、配置数据源</h3></blockquote><p>配置数据源，设置 <code>useInformationSchema</code> 可以获取<code>tables</code>注释信息。</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment">#配置数据源</span><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://192.168.200.128:3306/changgou_config?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=UTC</span><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">root</span><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><span class="hljs-meta">spring.datasource.xa.properties.useInformationSchema</span>=<span class="hljs-string">true</span></code></pre></div><blockquote><h3 id="3、screw核心配置"><a href="#3、screw核心配置" class="headerlink" title="3、screw核心配置"></a>3、screw核心配置</h3></blockquote><p><code>screw</code>有两种执行方式，第一种是<code>pom</code>文件配置，另一种是代码执行。</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-comment">&lt;!--screw有两种执行方式，第一种是pom文件配置，另一种是代码执行。--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.smallbun.screw<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>screw-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>                    <span class="hljs-comment">&lt;!-- HikariCP --&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zaxxer<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>HikariCP<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>                    <span class="hljs-comment">&lt;!--mysql driver--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-comment">&lt;!--username--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span>                    <span class="hljs-comment">&lt;!--password--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span>                    <span class="hljs-comment">&lt;!--driver--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">driverClassName</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">driverClassName</span>&gt;</span>                    <span class="hljs-comment">&lt;!--jdbc url--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">jdbcUrl</span>&gt;</span>jdbc:mysql://192.168.200.128:3306/changgou_config?serverTimezone=UTC<span class="hljs-tag">&lt;/<span class="hljs-name">jdbcUrl</span>&gt;</span>                    <span class="hljs-comment">&lt;!--生成文件类型 MD HTML DOC--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">fileType</span>&gt;</span>MD<span class="hljs-tag">&lt;/<span class="hljs-name">fileType</span>&gt;</span>                    <span class="hljs-comment">&lt;!--打开文件输出目录--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">openOutputDir</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">openOutputDir</span>&gt;</span>                    <span class="hljs-comment">&lt;!--生成模板--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">produceType</span>&gt;</span>freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">produceType</span>&gt;</span>                    <span class="hljs-comment">&lt;!--文档名称 为空时:将采用[数据库名称-描述-版本号]作为文档名称--&gt;</span>                    <span class="hljs-comment">&lt;!--&lt;docName&gt;测试文档名称&lt;/docName&gt;--&gt;</span>                    <span class="hljs-comment">&lt;!--描述--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>数据库文档生成<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>                    <span class="hljs-comment">&lt;!--版本--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;project.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                    <span class="hljs-comment">&lt;!--标题--&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>数据库文档<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span>                        <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span>                            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>run<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span>                        <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span>                    <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><p>配置完以后在 <code>maven project</code>-&gt;<code>screw</code> 双击执行ok。</p><p><img src="https://www.qfeng.online/imgs/java/screw/Snipaste_2020-08-28_10-35-08.jpg" srcset="/img/loading.gif" alt></p><p>代码生成方式也非常简单。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrewApplicationTests</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    ApplicationContext applicationContext;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        DataSource dataSourceMysql = applicationContext.getBean(DataSource<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-comment">// 生成文件配置</span>        EngineConfig engineConfig = EngineConfig.builder()                <span class="hljs-comment">// 生成文件路径，自己mac本地的地址，这里需要自己更换下路径</span>                .fileOutputDir(<span class="hljs-string">"D:/"</span>)                <span class="hljs-comment">// 打开目录</span>                .openOutputDir(<span class="hljs-keyword">false</span>)                <span class="hljs-comment">// 文件类型</span>                .fileType(EngineFileType.HTML)                <span class="hljs-comment">// 生成模板实现</span>                .produceType(EngineTemplateType.freemarker).build();        <span class="hljs-comment">// 生成文档配置（包含以下自定义版本号、描述等配置连接）</span>        Configuration config = Configuration.builder()                .version(<span class="hljs-string">"1.0.3"</span>)                .description(<span class="hljs-string">"生成文档信息描述"</span>)                .dataSource(dataSourceMysql)                .engineConfig(engineConfig)                .produceConfig(getProcessConfig())                .build();        <span class="hljs-comment">// 执行生成</span>        <span class="hljs-keyword">new</span> DocumentationExecute(config).execute();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置想要生成的表+ 配置想要忽略的表</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 生成表配置</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ProcessConfig <span class="hljs-title">getProcessConfig</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 忽略表名</span>        List&lt;String&gt; ignoreTableName = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"test_group"</span>);        <span class="hljs-comment">// 忽略表前缀，如忽略a开头的数据库表</span>        List&lt;String&gt; ignorePrefix = Arrays.asList(<span class="hljs-string">"a"</span>, <span class="hljs-string">"t"</span>);        <span class="hljs-comment">// 忽略表后缀</span>        List&lt;String&gt; ignoreSuffix = Arrays.asList(<span class="hljs-string">"_test"</span>, <span class="hljs-string">"czb_"</span>);        <span class="hljs-keyword">return</span> ProcessConfig.builder()                <span class="hljs-comment">//根据名称指定表生成</span>                .designatedTableName(Arrays.asList(<span class="hljs-string">"fire_user"</span>))                <span class="hljs-comment">//根据表前缀生成</span>                .designatedTablePrefix(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;())                <span class="hljs-comment">//根据表后缀生成</span>                .designatedTableSuffix(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;())                <span class="hljs-comment">//忽略表名</span>                .ignoreTableName(ignoreTableName)                <span class="hljs-comment">//忽略表前缀</span>                .ignoreTablePrefix(ignorePrefix)                <span class="hljs-comment">//忽略表后缀</span>                .ignoreTableSuffix(ignoreSuffix).build();    &#125;&#125;</code></pre></div><blockquote><h3 id="4、文档格式"><a href="#4、文档格式" class="headerlink" title="4、文档格式"></a>4、文档格式</h3></blockquote><p><code>screw</code> 有 <code>HTML</code>、<code>DOC</code>、<code>MD</code> 三种格式的文档。</p><p>代码中的修改</p><div class="hljs"><pre><code class="hljs java">.fileType(EngineFileType.HTML</code></pre></div><p>或者<code>pom</code>文件</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fileType</span>&gt;</span>MD<span class="hljs-tag">&lt;/<span class="hljs-name">fileType</span>&gt;</span></code></pre></div><h3 id="DOC文档样式"><a href="#DOC文档样式" class="headerlink" title="DOC文档样式"></a><code>DOC</code>文档样式</h3><p><img src="https://www.qfeng.online/imgs/java/screw/Snipaste_2020-08-28_10-43-54.jpg" srcset="/img/loading.gif" alt></p><h3 id="HTML文档样式"><a href="#HTML文档样式" class="headerlink" title="HTML文档样式"></a><code>HTML</code>文档样式</h3><p><img src="https://www.qfeng.online/imgs/java/screw/Snipaste_2020-08-28_10-43-20.jpg" srcset="/img/loading.gif" alt></p><h3 id="MD文档样式"><a href="#MD文档样式" class="headerlink" title="MD文档样式"></a><code>MD</code>文档样式</h3><p><img src="https://www.qfeng.online/imgs/java/screw/Snipaste_2020-08-28_10-44-31.jpg" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2020/07/12/JUC/"/>
    <url>/2020/07/12/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="1、什么是JUC"><a href="#1、什么是JUC" class="headerlink" title="1、什么是JUC"></a>1、什么是JUC</h2><p>java.util.concurrent 并发工具包 </p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-05_20-49-24.jpg" srcset="/img/loading.gif" alt></p><h2 id="2、线程和进程"><a href="#2、线程和进程" class="headerlink" title="2、线程和进程"></a>2、线程和进程</h2><blockquote><p><strong>进程</strong>：正在执行在一个程序，任务管理器中的显示的都是一个个进程。</p><p><strong>线程</strong>：程序中的一条执行路径，一个进程可以有多个线程。</p><p>java默认是有两个线程。GC垃圾回收器，main </p></blockquote><p>举例：植物大战僵尸游戏中，各种植物发射子弹和僵尸们往前走，这就多线程。</p><p><strong>java真的可以开启线程吗？</strong></p><p>java 无法直接操作硬件，start 是本地方法调用的。</p><blockquote><p>并发、并行</p></blockquote><p>并发（多线程操作同一个资源）</p><ul><li>CPU单核  时间片轮转，快速切换</li></ul><p>并行（多个人一起行走）</p><ul><li>多核CPU</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.demo01;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/5 21:09</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//获取CPU核数</span>        <span class="hljs-comment">//cpu密集型 、io密集型</span>        System.out.println(Runtime.getRuntime().availableProcessors());    &#125;&#125;</code></pre></div><p>并发编程的本质：<strong>充分利用CPU的资源</strong></p><blockquote><p>线程有几个状态</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> State &#123;        <span class="hljs-comment">//创建</span>      NEW,    <span class="hljs-comment">//运行</span>      RUNNABLE,    <span class="hljs-comment">//阻塞</span>      BLOCKED,    <span class="hljs-comment">//等待,死死的等</span>      WAITING,         <span class="hljs-comment">//限时等待</span>      TIMED_WAITING,     <span class="hljs-comment">//终止状态</span>      TERMINATED;&#125;</code></pre></div><blockquote><p>wait 和 sleep 区别</p></blockquote><p><strong>1、来自不同的类</strong></p><p>wait ==&gt; Object </p><p>sleep  ==&gt; Thread</p><p><strong>2、关于锁的释放</strong></p><p>wait会释放锁，sleep睡的时候，抱着锁睡觉，不会释放。</p><p><strong>3、使用的范围是不同的</strong></p><p>wait 必须在同步代码块中</p><p>sleep 可以在任何地方睡</p><p><strong>4、是否需要捕获异常</strong></p><p>wait 不需要捕获异常</p><p>sleep 必须要捕获异常</p><h2 id="3、Lock锁（重点）"><a href="#3、Lock锁（重点）" class="headerlink" title="3、Lock锁（重点）"></a>3、Lock锁（<code>重点</code>）</h2><blockquote><p>传统synchronize </p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.demo01;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/6 20:55</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">saleTicketDemo01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//多线程并发操作同一个资源</span>        Ticket ticket = <span class="hljs-keyword">new</span> Ticket();        <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;.start();        <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;.start();        <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;                    ticket.sale();                &#125;            &#125;        &#125;.start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">30</span>;    <span class="hljs-comment">//买票的方式</span>    <span class="hljs-comment">//synchronized 的本质就像是一个队列 ，每个线程 有序进行操作</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>)&#123;            System.out.println(<span class="hljs-string">"卖出第"</span>+ number-- +<span class="hljs-string">"号票，剩余"</span> + number);        &#125;    &#125;&#125;</code></pre></div><blockquote><p>lock</p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-06_22-58-11.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-06_22-59-30.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.demo01;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/6 20:55</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">saleTicketDemo02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//多线程并发操作同一个资源</span>        Ticket2 ticket2 = <span class="hljs-keyword">new</span> Ticket2();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;                    ticket2.sale();                &#125;        &#125;,<span class="hljs-string">"Thread-A"</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;                ticket2.sale();            &#125;        &#125;,<span class="hljs-string">"Thread-B"</span>).start();        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; i++) &#123;                ticket2.sale();            &#125;        &#125;,<span class="hljs-string">"Thread-C"</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ticket2</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">30</span>;    <span class="hljs-comment">//买票的方式</span>   <span class="hljs-comment">//lock锁三部曲</span>    <span class="hljs-comment">//1.new lock锁</span>    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">sale</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//2.加锁</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//业务代码</span>            <span class="hljs-keyword">if</span>(number &gt; <span class="hljs-number">0</span>)&#123;                System.out.println(<span class="hljs-string">"卖出第"</span>+ number-- +<span class="hljs-string">"号票，剩余"</span> + number);            &#125;        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"lock锁出错了！"</span>);        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//3.手动释放锁</span>            lock.unlock();        &#125;    &#125;&#125;</code></pre></div><p>公平锁： 十分公平，讲究先来后到。</p><p>非公平锁：十分不公平，可以插队。（默认，涉及到cpu调度，耗时少的优先）</p><blockquote><p>Synchronized 和 Lock 区别</p></blockquote><p>1、Synchronized 内置的java关键字，Lock是一个Java类</p><p>2、Synchronized 无法判断获取锁的状态(他是自动的)，Lock可以判断是否取到了锁</p><p>3、Synchronized 会自动释放锁，lock必须要手动释放锁！ <code>如果不释放锁，就会发生死锁</code></p><p>4、Synchronized 线程1（获得锁，阻塞）、线程2（等待，傻傻的等）；lock锁就不一定等待下去 lock.tryLock（） 尝试获取锁；</p><p>5、Synchronize可重入锁、不可以中断，非公平；Lock ,可重入锁，可以判断锁，非公平（可以自己设置）</p><p>6、Sychronized 适合锁少量的代码同步问题，Lock适合锁大量的同步代码！</p><blockquote><p>锁是什么，如何判断锁的是谁！</p></blockquote><h2 id="4、生产者和消费者问题"><a href="#4、生产者和消费者问题" class="headerlink" title="4、生产者和消费者问题"></a>4、生产者和消费者问题</h2><blockquote><p>生产者和消费者Synchronized版</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.PC;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/6 23:55</span><span class="hljs-comment"> * 生产和消费者问题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Data data = <span class="hljs-keyword">new</span> Data();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                    data.increment();                &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                            data.decrement();                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;        ,<span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-comment">//判断等待，业务，通知</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number=<span class="hljs-number">0</span>;    <span class="hljs-comment">//+1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span>(number!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">// 判断等待</span>            <span class="hljs-keyword">this</span>.wait();        &#125;        <span class="hljs-comment">//业务</span>        number++;        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"--&gt;"</span>+ number);        <span class="hljs-comment">//通知 （唤醒其他线程），通知其他线程 +1 完毕</span>        <span class="hljs-keyword">this</span>.notify();    &#125;    <span class="hljs-comment">//-1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">if</span>(number==<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//判断等待</span>            <span class="hljs-keyword">this</span>.wait();        &#125;        <span class="hljs-comment">//业务</span>        number--;        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"--&gt;"</span>+ number);        <span class="hljs-comment">//通知 ,通知其他线程 -1 完毕</span>        <span class="hljs-keyword">this</span>.notify();    &#125;&#125;</code></pre></div><blockquote><p>问题存在 A、B、C、D四个线程！虚假唤醒 使用if 唤醒后不会重新判断等待，直接执行了，使用while唤醒后会从新判断是否等待</p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_00-26-32.jpg" srcset="/img/loading.gif" alt></p><p><strong>if 改while</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.PC;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/6 23:55</span><span class="hljs-comment"> * 生产和消费者问题</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Data1 data = <span class="hljs-keyword">new</span> Data1();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;                    data.increment();                &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                    <span class="hljs-keyword">try</span> &#123;                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;                            data.decrement();                        &#125;                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;        ,<span class="hljs-string">"B"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;                    data.increment();                &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">"C"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;                    data.decrement();                &#125;            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;,<span class="hljs-string">"D"</span>).start();    &#125;&#125;<span class="hljs-comment">//判断等待，业务，通知</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data1</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number=<span class="hljs-number">0</span>;    <span class="hljs-comment">//+1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">while</span> (number!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">// 判断等待</span>            <span class="hljs-keyword">this</span>.wait();        &#125;        <span class="hljs-comment">//业务</span>        number++;        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"--&gt;"</span>+ number);        <span class="hljs-comment">//通知 （唤醒其他线程），通知其他线程 +1 完毕</span>        <span class="hljs-keyword">this</span>.notifyAll();    &#125;    <span class="hljs-comment">//-1</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">while</span> (number==<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//判断等待</span>            <span class="hljs-keyword">this</span>.wait();        &#125;        <span class="hljs-comment">//业务</span>        number--;        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"--&gt;"</span>+ number);        <span class="hljs-comment">//通知 ,通知其他线程 -1 完毕</span>        <span class="hljs-keyword">this</span>.notifyAll();    &#125;&#125;</code></pre></div><blockquote><p>JUC版的生产者和消费者</p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_00-51-26.jpg" srcset="/img/loading.gif" alt></p><p>通过Lock 找到Condition</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_00-52-46.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>Condition的await 和 signalAll  也能实现 wait和notifyAll的作用，但Condition 不仅仅只是覆盖已有的功能</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.PC;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 19:14</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConditionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Data3 data = <span class="hljs-keyword">new</span> Data3();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                data.printA();            &#125;        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                data.printB();            &#125;        &#125;).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;                data.printC();            &#125;        &#125;).start();    &#125;&#125;<span class="hljs-comment">//资源类</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Data3</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number = <span class="hljs-number">1</span>;    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    Condition condition1 = lock.newCondition();    Condition condition2 = lock.newCondition();    Condition condition3 = lock.newCondition();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printA</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//判断等待</span>            <span class="hljs-keyword">while</span> (number!=<span class="hljs-number">1</span>)&#123;                condition1.await();            &#125;            <span class="hljs-comment">//业务</span>            number=<span class="hljs-number">2</span>;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"=&gt;"</span> + <span class="hljs-string">"AAAAA"</span>);            <span class="hljs-comment">//执行完了，唤醒指定的线程</span>            condition2.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放</span>            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printB</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//判断等待</span>            <span class="hljs-keyword">while</span> (number!=<span class="hljs-number">2</span>)&#123;                condition2.await();            &#125;            <span class="hljs-comment">//业务</span>            number=<span class="hljs-number">3</span>;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"=&gt;"</span> + <span class="hljs-string">"BBBBB"</span>);            <span class="hljs-comment">//执行完了，唤醒指定的线程</span>            condition3.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放</span>            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printC</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//判断等待</span>            <span class="hljs-keyword">while</span> (number!=<span class="hljs-number">3</span>)&#123;                condition3.await();            &#125;            <span class="hljs-comment">//业务</span>            number=<span class="hljs-number">1</span>;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"=&gt;"</span> + <span class="hljs-string">"CCCCC"</span>);            <span class="hljs-comment">//执行完了，唤醒指定的线程</span>            condition1.signal();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放</span>            lock.unlock();        &#125;    &#125;&#125;</code></pre></div><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_19-42-01.jpg" srcset="/img/loading.gif" alt></p><p><strong>任何一个新的技术，绝对不仅仅只是覆盖了原来的技术，是做优势和补充！</strong></p><blockquote><p>Condition精准的通知和唤醒线程（A B C线程安装顺序始终依次执行）</p></blockquote><h2 id="5、8锁现象"><a href="#5、8锁现象" class="headerlink" title="5、8锁现象"></a>5、8锁现象</h2><blockquote><p>分清锁的是对象，还是class 模本！8锁问题迎刃而解</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lock8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 16:51</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 8锁，就是关于锁的8个问题</span><span class="hljs-comment"> * 1、标准情况下，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span><span class="hljs-comment"> * 1、sendSms延迟4秒，两个线程先打印 发短信还是 打电话？ 1/发短信 2/打电话</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-comment">//锁的存在</span>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            phone.sendSms();        &#125;, <span class="hljs-string">"A"</span>).start();        <span class="hljs-comment">// 捕获</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            System.out.println(<span class="hljs-string">"我进来了可我没有得到lock"</span>);            phone.call();        &#125;, <span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;    <span class="hljs-comment">// synchronized 锁的对象是方法的调用者！、</span>    <span class="hljs-comment">// 两个方法用的是同一个锁，谁先拿到谁执行！</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">"发短信"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"打电话"</span>);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lock8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 16:55</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 3、 增加了一个普通方法后！先执行发短信还是Hello？ 普通方法</span><span class="hljs-comment"> * 4、 两个对象，两个同步方法， 发短信还是 打电话？ // 打电话</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 两个对象，两个调用者，两把锁！</span>        Phone2 phone1 = <span class="hljs-keyword">new</span> Phone2();        Phone2 phone2 = <span class="hljs-keyword">new</span> Phone2();        <span class="hljs-comment">//锁的存在</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone1.sendSms();        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-comment">// 捕获</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-comment">//phone2.call();</span>            phone1.hello();        &#125;,<span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone2</span></span>&#123;    <span class="hljs-comment">// synchronized 锁的对象是方法的调用者！</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">"发短信"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"打电话"</span>);    &#125;    <span class="hljs-comment">// 这里没有锁！不是同步方法，不受锁的影响</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"hello"</span>);    &#125;&#125;</code></pre></div><p><strong>static 同步方法，锁的是class模板对象，虽然是两个对象调用的方法，但是锁的对象是同一个calss对象</strong>  </p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lock8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 16:59</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 5、增加两个静态的同步方法，只有一个对象，先打印 发短信？打电话？</span><span class="hljs-comment"> * 6、两个对象！增加两个静态的同步方法， 先打印 发短信？打电话？</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 两个对象的Class类模板只有一个，static，锁的是Class</span>        Phone3 phone1 = <span class="hljs-keyword">new</span> Phone3();        Phone3 phone2 = <span class="hljs-keyword">new</span> Phone3();        <span class="hljs-comment">//锁的存在</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone1.sendSms();        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-comment">// 捕获</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone2.call();        &#125;,<span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-comment">// Phone3唯一的一个 Class 对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone3</span></span>&#123;    <span class="hljs-comment">// synchronized 锁的对象是方法的调用者！</span>    <span class="hljs-comment">// static 静态方法</span>    <span class="hljs-comment">// 类一加载就有了！锁的是Class</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">"发短信"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"打电话"</span>);    &#125;&#125;</code></pre></div><p><strong>calss的锁对象，不影响this 对象锁</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lock8;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 17:02</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 1、1个静态的同步方法，1个普通的同步方法 ，一个对象，先打印 发短信？打电话？</span><span class="hljs-comment"> * 2、1个静态的同步方法，1个普通的同步方法 ，两个对象，先打印 发短信？打电话？</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 两个对象的Class类模板只有一个，static，锁的是Class</span>        Phone4 phone1 = <span class="hljs-keyword">new</span> Phone4();        Phone4 phone2 = <span class="hljs-keyword">new</span> Phone4();        <span class="hljs-comment">//锁的存在</span>        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone1.sendSms();        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-comment">// 捕获</span>        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone2.call();        &#125;,<span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-comment">// Phone3唯一的一个 Class 对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone4</span></span>&#123;    <span class="hljs-comment">// 静态的同步方法 锁的是 Class 类模板</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendSms</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">4</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        System.out.println(<span class="hljs-string">"发短信"</span>);    &#125;    <span class="hljs-comment">// 普通的同步方法 锁的调用者</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"打电话"</span>);    &#125;&#125;</code></pre></div><h2 id="6、集合类不安全"><a href="#6、集合类不安全" class="headerlink" title="6、集合类不安全"></a>6、集合类不安全</h2><blockquote><p>List不安全</p></blockquote><p>ArrayList 底层是 Object[] 数组 ，默认大小的10，装满就扩容，1.5倍扩容。10 ——&gt;1.5  Arrays.copyof( ) 第二次扩容15——&gt; 22</p><p>现象：并发修改异常   <code>ConcurrentModificationException</code></p><p>解决：①： Vector  ②：Collections.SynchronizedList(new ArrayList())  ③： JUC包下 CopyOnWriteArrayList( )</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_12-17-52.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.unsafe;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 18:59</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * ConcurrentModificationException 并发修改异常</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *</span><span class="hljs-comment">         * 解决方案: ①  Vector 不推荐</span><span class="hljs-comment">         *          ②  Collections.synchronizedList(new ArrayList())</span><span class="hljs-comment">         *          ③  new CopyOnWriteArrayList ()  JUC 包下的，和ArrayList同级 都是List的实现类,写时复制，可以</span><span class="hljs-comment">         *              可以实现读写分离</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//ArrayList list = new ArrayList();</span>        <span class="hljs-comment">//List list = Collections.synchronizedList(new ArrayList());</span>        List list = <span class="hljs-keyword">new</span> CopyOnWriteArrayList ();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                list.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>));                System.out.println(list);            &#125;).start();        &#125;    &#125;&#125;</code></pre></div><blockquote><p><strong>set</strong> <code>hashset的底层是Hashmap ，但是 只是 用了map的key</code></p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.unsafe;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 15:09</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SetTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//问题：java.util.ConcurrentModificationException</span>        <span class="hljs-comment">//解决方案</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 1. Collections.synchronizedSet(new HashSet&lt;&gt;())</span><span class="hljs-comment">         * 2. copyOnWriteArraySet()  (juc中的类)</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//Set&lt;String&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;set.add(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>,<span class="hljs-number">6</span>));                System.out.println(set);            &#125;,Thread.currentThread().getName()+<span class="hljs-string">"===&gt;"</span>+ String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p>HashSet 底层是什么？看源码</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//hashSet的底层就是hashMap</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    &#125;<span class="hljs-comment">//但是它只是使用的map的key，添加元素</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;    &#125;</code></pre></div><blockquote><p>Map 不安全</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.unsafe;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.UUID;<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 15:29</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  故障问题 ：java.util.ConcurrentModificationException 并发修改异常</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *  解决办法：①Collections.synchronizedMap(new HashMap&lt;&gt;())</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">//Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span>        <span class="hljs-comment">//Map&lt;String,String&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());</span>        Map&lt;String,String&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString());                System.out.println(map);            &#125;).start();        &#125;    &#125;&#125;</code></pre></div><p><strong>map的底层</strong></p><p>默认大小是16 ，加载因子是0.75 </p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_16-03-19.jpg" srcset="/img/loading.gif" alt></p><h2 id="7、callable-简单"><a href="#7、callable-简单" class="headerlink" title="7、callable(简单)"></a>7、callable(简单)</h2><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_16-09-52.jpg" srcset="/img/loading.gif" alt></p><p>类似于Runnable </p><p>不同点：</p><p>1、可以有返回值</p><p>2、可以抛出异常</p><p>3、方法不同，之前是run（）/现在是call（）</p><blockquote><p>代码实现</p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_17-02-35.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_17-02-22.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_17-00-31.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.callable;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 16:33</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableTest</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * callable和 runnable什么相识</span><span class="hljs-comment">     * 不同在于</span><span class="hljs-comment">     * callable 有返回值 可以抛出异常 线程执行体的调用方法名 run/ call</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 使用 Runnable 的实现类 new FutureTask() 把callable的实例丢进去</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 相当于是使用了个FutureTask 把callable 伪装成runnable</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        MyThread t1 = <span class="hljs-keyword">new</span>  MyThread();        FutureTask futureTask = <span class="hljs-keyword">new</span> FutureTask(t1); <span class="hljs-comment">//伪装成runnable 类</span>        <span class="hljs-keyword">new</span> Thread(futureTask,<span class="hljs-string">"AAAAA"</span>).start();        <span class="hljs-keyword">new</span> Thread(futureTask,<span class="hljs-string">"AAAAA"</span>).start();        futureTask.get(); <span class="hljs-comment">//这个get 方法可能会产生阻塞</span>    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">//可以抛出异常</span>        System.out.println(<span class="hljs-string">"call()"</span>);        <span class="hljs-comment">//有返回值</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;    &#125;&#125;</code></pre></div><h2 id="8、JUC中常用的三大辅助类"><a href="#8、JUC中常用的三大辅助类" class="headerlink" title="8、JUC中常用的三大辅助类"></a>8、JUC中常用的三大辅助类</h2><h3 id="8-1-、CountDownLatch-减法计数器"><a href="#8-1-、CountDownLatch-减法计数器" class="headerlink" title="8.1 、CountDownLatch(减法计数器)"></a>8.1 、CountDownLatch(减法计数器)</h3><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_17-33-19.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.sup;<span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 17:22</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatchDemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 减法计数器</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//设置总数是6</span>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">6</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;            <span class="hljs-keyword">new</span>  Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName() +<span class="hljs-string">"Go out"</span>);                <span class="hljs-comment">//数量减1</span>                countDownLatch.countDown();            &#125;,String.valueOf(i)).start();        &#125;        <span class="hljs-comment">//等待计数器归零，然后向下执行</span>        countDownLatch.await();        System.out.println(<span class="hljs-string">"close ......"</span>);    &#125;&#125;</code></pre></div><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_17-30-18.jpg" srcset="/img/loading.gif" alt></p><p><strong>小结</strong>：<code>countDown（）数量减一</code>       <code>await（）等待计数器归零，然后向下执行</code></p><p>每次有线程调用countDown（）数量-1，当计数器的数量为0，countDownLatch.await（） 就会被唤醒，继续执行。</p><h3 id="8-2-、CyclicBarrier-saɪklɪk-ˈbaeriə-r"><a href="#8-2-、CyclicBarrier-saɪklɪk-ˈbaeriə-r" class="headerlink" title="8.2 、CyclicBarrier  /saɪklɪk  [ˈbæriə(r)]/"></a>8.2 、CyclicBarrier  /saɪklɪk  [ˈbæriə(r)]/</h3><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_18-14-25.jpg" srcset="/img/loading.gif" alt></p><p>集齐七龙珠召唤神龙</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.sup;<span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 17:54</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierDemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 集齐七龙珠召唤神龙</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//给定数量的线程</span>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">7</span>, ()-&gt; &#123;            System.out.println(<span class="hljs-string">"召唤神龙成功！"</span>);        &#125;);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">7</span>; i++) &#123;            <span class="hljs-comment">//不能直接操作到i 需要定义成final</span>            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> temp = i;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"收集"</span> + temp +<span class="hljs-string">"龙族"</span>);                <span class="hljs-keyword">try</span> &#123;                    cyclicBarrier.await(); <span class="hljs-comment">//等待  一直等到7个线程都执行到此刻，召唤神龙</span>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                    e.printStackTrace();                &#125;            &#125;).start();        &#125;    &#125;&#125;</code></pre></div><h3 id="8-3、Semaphore-ˈseməfoː-r-信号量"><a href="#8-3、Semaphore-ˈseməfoː-r-信号量" class="headerlink" title="8.3、Semaphore  [ˈseməfɔː(r)] 信号量"></a>8.3、Semaphore  [ˈseməfɔː(r)] 信号量</h3><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-07_18-15-06.jpg" srcset="/img/loading.gif" alt></p><p>抢车位 3个车位—》 6个车</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.sup;<span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/7 18:32</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreDemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 信号量</span><span class="hljs-comment">     * 3个车位，6个车需要停车</span><span class="hljs-comment">     * 处理 指定数量的线程，多出来的线程需要等待处理的线程释放后才可以执行</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//指定能够处理的线程数量</span>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                <span class="hljs-keyword">try</span> &#123;                    semaphore.acquire(); <span class="hljs-comment">//得到，如果没有可用的就阻塞等着</span>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"抢到了车位"</span>);                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"离开了车位"</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;<span class="hljs-keyword">finally</span> &#123;                    semaphore.release(); <span class="hljs-comment">//释放</span>                &#125;            &#125;,String.valueOf(i)).start();        &#125;    &#125;&#125;</code></pre></div><p><strong>原理：</strong></p><p><code>semaphore.acquire()</code>: 获得执行权，如果没有可以使用的，就一直等着，等到释放为止</p><p><code>semaphore.release()</code> : 释放，会将当前的信号量释放 + 1，然后唤醒等待的线程！</p><p><code>作用： 多个共享资源互斥的使用！并发限流，控制最大的线程数！</code></p><h2 id="9、读写锁（一写多读）"><a href="#9、读写锁（一写多读）" class="headerlink" title="9、读写锁（一写多读）"></a>9、读写锁（一写多读）</h2><p>ReadWriteLock</p><p>独占锁（写锁）一次只能被一个线程占有</p><p>共享锁（读锁）多个线程可以同时占有</p><p>读-读   可以共存</p><p>读-写    不可以共存</p><p>写-写    不可以共存</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_10-58-40.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_11-28-57.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_11-29-31.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>ReadWriteLock 和 Lock 一样的作用，但是readWriteLock的粒度比Lock更加的细</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.rw;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReadWriteLock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantReadWriteLock;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/10 11:01</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * 读写锁</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadWriteLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        MyCache cache = <span class="hljs-keyword">new</span> MyCache();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span> ; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> temp = i;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                cache.put(temp+<span class="hljs-string">""</span>,temp+<span class="hljs-string">""</span>);            &#125;).start();        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;=<span class="hljs-number">5</span> ; i++) &#123;            <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> temp = i;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                cache.get(temp+<span class="hljs-string">""</span>);            &#125;).start();        &#125;    &#125;&#125;<span class="hljs-comment">//自定义缓存</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCache</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> HashMap();    <span class="hljs-comment">//readWriteLock : 读写锁更加细粒度的锁</span>    ReadWriteLock readWriteLock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-comment">//存，写入的时候，同时只有一个线程写</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(String key, Object value)</span></span>&#123;        <span class="hljs-comment">//加锁（和普通的reentrantLock相比锁的粒度更加细）</span>        readWriteLock.writeLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"写入"</span>+key);            map.put(key,value);            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"写入Ok"</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放读锁</span>            readWriteLock.writeLock().unlock();        &#125;    &#125;    <span class="hljs-comment">//读，同时可以有多个线程读</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>&#123;        <span class="hljs-comment">//加锁，读锁（读锁既然允许多个线程同时读，为什么还要加锁）</span>        <span class="hljs-comment">//读的时候加锁是因为，防止读的时候有写的操作，造成脏读，幻读</span>        readWriteLock.readLock().lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"读取"</span>+key);            Object o = map.get(key);            System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"读取Ok"</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//释放锁</span>            readWriteLock.readLock().unlock();        &#125;    &#125;&#125;</code></pre></div><h2 id="10、阻塞队列"><a href="#10、阻塞队列" class="headerlink" title="10、阻塞队列"></a>10、阻塞队列</h2><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_16-20-45.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_16-18-36.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_16-23-51.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>ArrayBlockingQueue </p></blockquote><p>什么情况下我们会使用 阻塞队列：多线程并发处理，线程池！<br>学会使用队列<br><strong>添加、移除  四组API</strong></p><table><thead><tr><th>方式</th><th>抛出异常</th><th>有返回值，不抛出异常</th><th>阻塞 等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add()</td><td>offer()</td><td>put()</td><td>offer(,,)</td></tr><tr><td>移除</td><td>remove</td><td>poll()</td><td>take()</td><td>poll(,)</td></tr><tr><td>检查队首元素</td><td>element</td><td>peek</td><td></td><td></td></tr></tbody></table><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 抛出异常</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 队列的大小</span>    ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);    System.out.println(blockingQueue.add(<span class="hljs-string">"a"</span>));    System.out.println(blockingQueue.add(<span class="hljs-string">"b"</span>));    System.out.println(blockingQueue.add(<span class="hljs-string">"c"</span>));    <span class="hljs-comment">// IllegalStateException: Queue full 抛出异常！</span>    <span class="hljs-comment">// System.out.println(blockingQueue.add("d"));</span>    System.out.println(<span class="hljs-string">"=-==========="</span>);    System.out.println(blockingQueue.remove());    System.out.println(blockingQueue.remove());    System.out.println(blockingQueue.remove());    <span class="hljs-comment">// java.util.NoSuchElementException 抛出异常！</span>    <span class="hljs-comment">// System.out.println(blockingQueue.remove());</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 有返回值，没有异常</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">// 队列的大小</span>    ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);    System.out.println(blockingQueue.offer(<span class="hljs-string">"a"</span>));    System.out.println(blockingQueue.offer(<span class="hljs-string">"b"</span>));    System.out.println(blockingQueue.offer(<span class="hljs-string">"c"</span>));    <span class="hljs-comment">// System.out.println(blockingQueue.offer("d")); // false 不抛出异常！</span>    System.out.println(<span class="hljs-string">"============================"</span>);    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll()); <span class="hljs-comment">// null 不抛出异常！</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 等待，阻塞（一直阻塞）</span><span class="hljs-comment">*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-comment">// 队列的大小</span>    ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);    SynchronousQueue 同步队列    没有容量，    进去一个元素，必须等待取出来之后，才能再往里面放一个元素！    put、take    <span class="hljs-comment">// 一直阻塞</span>    blockingQueue.put(<span class="hljs-string">"a"</span>);    blockingQueue.put(<span class="hljs-string">"b"</span>);    blockingQueue.put(<span class="hljs-string">"c"</span>);    <span class="hljs-comment">// blockingQueue.put("d"); // 队列没有位置了，一直阻塞</span>    System.out.println(blockingQueue.take());    System.out.println(blockingQueue.take());    System.out.println(blockingQueue.take());    System.out.println(blockingQueue.take()); <span class="hljs-comment">// 没有这个元素，一直阻塞</span>&#125;<span class="hljs-comment">/**</span></code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* 等待，阻塞（等待超时）</span><span class="hljs-comment">*/</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    <span class="hljs-comment">// 队列的大小</span>    ArrayBlockingQueue blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>);    blockingQueue.offer(<span class="hljs-string">"a"</span>);    blockingQueue.offer(<span class="hljs-string">"b"</span>);    blockingQueue.offer(<span class="hljs-string">"c"</span>);    <span class="hljs-comment">// blockingQueue.offer("d",2,TimeUnit.SECONDS); // 等待超过2秒就退出</span>    System.out.println(<span class="hljs-string">"==============="</span>);    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll());    System.out.println(blockingQueue.poll());    blockingQueue.poll(<span class="hljs-number">2</span>,TimeUnit.SECONDS); <span class="hljs-comment">// 等待超过2秒就退出</span>&#125;</code></pre></div><blockquote><p>SynchronizedQueue同步队列 也是blockingQueue的一种实现类</p></blockquote><p>没有容量</p><p>进去一个元素，必须等待取出来之后，才可以往里面放一个元素。</p><p>put 、take</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.synchronizredQueue;<span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<span class="hljs-keyword">import</span> java.util.concurrent.SynchronousQueue;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/10 16:09</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedQueueDemo</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 同步队列--</span><span class="hljs-comment">     *     put一个，就必须哪一个</span><span class="hljs-comment">     *    每一只能put进去一个，必须等到取出了之后，再put下一个</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//同步队列</span>        BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> SynchronousQueue&lt;&gt;();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"put 1"</span>);                    blockingQueue.put(<span class="hljs-string">"1"</span>);                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"put 2"</span>);                    blockingQueue.put(<span class="hljs-string">"2"</span>);                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"put 3"</span>);                    blockingQueue.put(<span class="hljs-string">"3"</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,<span class="hljs-string">"AAA"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;                <span class="hljs-keyword">try</span> &#123;                    System.out.println(Thread.currentThread().getName() +<span class="hljs-string">"==&gt;"</span>+ blockingQueue.take());                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                    System.out.println(Thread.currentThread().getName() +<span class="hljs-string">"==&gt;"</span>+ blockingQueue.take());                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                    System.out.println(Thread.currentThread().getName() +<span class="hljs-string">"==&gt;"</span>+ blockingQueue.take());                    TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;,<span class="hljs-string">"BBB"</span>).start();    &#125;&#125;</code></pre></div><p><strong>学了技术不会用！ 还是看的少！！！</strong> </p><h2 id="11、线程池（重点）"><a href="#11、线程池（重点）" class="headerlink" title="11、线程池（重点）"></a>11、线程池（<code>重点</code>）</h2><p><strong>线程池：三大方法、七大参数、四种拒绝策略</strong></p><blockquote><p><strong>池化技术</strong></p></blockquote><p>程序的运行，是很消耗资源的，池化技术可以优化资源的使用</p><p><strong>线程池的好处：</strong></p><p>1、降低资源的消耗、</p><p>2、提高响应到速度</p><p>3、方便管理</p><p><strong><code>线程复用、可以控制最大并发连接数、管理线程</code></strong></p><blockquote><p><strong>线程池： 三大方法</strong></p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_18-49-36.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.bq;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/10 16:34</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Executors [ɪɡˈzekjətə(r)] 工具类 3大方法</span>        <span class="hljs-comment">//ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</span>        <span class="hljs-comment">//ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建一个固定大小的线程池</span>        ExecutorService threadPool = Executors.newCachedThreadPool(); <span class="hljs-comment">//可伸缩的，遇强则强（理论上是你要多少个就有多少个，但是和cpu电脑性能有关）</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;                <span class="hljs-comment">//使用线程池，从线程池获取线程</span>                threadPool.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"  Ok"</span>);                &#125;);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭连接池</span>            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre></div><div class="note note-primary">            <p>Executors [ɪɡˈzekjətə(r)] 工具类 3大方法</p><p>ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</p><p>ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建一个固定大小的线程池 ExecutorService </p><p>threadPool = Executors.newCachedThreadPool(); //可伸缩的，遇强则强（理论上是你要多少个就有多少个，但是和cpu电脑性能有关）</p>          </div><blockquote><p><strong>七大参数</strong></p></blockquote><p><strong>源码分析</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FinalizableDelegatedExecutorService            (<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,                                    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                    <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> nThreads)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,                                      <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">0</span>, Integer.MAX_VALUE,                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,                                  <span class="hljs-keyword">new</span> SynchronousQueue&lt;Runnable&gt;());&#125;<span class="hljs-comment">//本质</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, //核心线程池大小(可以理解为最小线程数)</span></span><span class="hljs-function">                              <span class="hljs-keyword">int</span> maximumPoolSize,<span class="hljs-comment">//最大线程池大小</span></span><span class="hljs-function">                              <span class="hljs-keyword">long</span> keepAliveTime, <span class="hljs-comment">//超时了没有人调用就会释放</span></span><span class="hljs-function">                              TimeUnit unit,  <span class="hljs-comment">//超时单位</span></span><span class="hljs-function">                              BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//阻塞队列</span></span><span class="hljs-function">                              ThreadFactory threadFactory,  <span class="hljs-comment">//线程工厂；创建线程的，一般不动</span></span><span class="hljs-function">                              RejectedExecutionHandler handler ) </span>&#123; <span class="hljs-comment">//拒绝策略</span>        <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||            maximumPoolSize &lt;= <span class="hljs-number">0</span> ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; <span class="hljs-number">0</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();        <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();        <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?                <span class="hljs-keyword">null</span> :                AccessController.getContext();        <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;        <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;        <span class="hljs-keyword">this</span>.workQueue = workQueue;        <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);        <span class="hljs-keyword">this</span>.threadFactory = threadFactory;        <span class="hljs-keyword">this</span>.handler = handler;    &#125;</code></pre></div><p>图形理解</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_19-04-01.jpg" srcset="/img/loading.gif" alt></p><p><strong>自定义线程</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.bq;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/10 16:34</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayBlockingQueueDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Executors [ɪɡˈzekjətə(r)] 工具类 3大方法</span>        <span class="hljs-comment">//ExecutorService threadPool = Executors.newSingleThreadExecutor();//单个线程</span>        <span class="hljs-comment">//ExecutorService threadPool = Executors.newFixedThreadPool(5); //创建一个固定大小的线程池</span>        <span class="hljs-comment">//ExecutorService threadPool = Executors.newCachedThreadPool(); //可伸缩的，遇强则强（理论上是你要多少个就有多少个，但是和cpu电脑性能有关）</span>        <span class="hljs-comment">//自定义线程池</span>        ExecutorService threadPool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(                <span class="hljs-number">2</span>,                <span class="hljs-number">3</span>,                <span class="hljs-number">3</span>,                TimeUnit.SECONDS,                <span class="hljs-keyword">new</span> ArrayBlockingQueue(<span class="hljs-number">4</span>),                Executors.defaultThreadFactory(),                <span class="hljs-comment">//new ThreadPoolExecutor.AbortPolicy() //线程池没有可用线程了（需要的线程数 &gt; queue+max），还有要获取线程的拒绝就抛出异常</span>                <span class="hljs-comment">//new ThreadPoolExecutor.CallerRunsPolicy()  //哪来的回哪里去，回main 方法执行</span>                <span class="hljs-comment">//new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试和最早的竞争，不抛出异常</span>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy() <span class="hljs-comment">//队列满了，丢掉任务，不抛出异常</span>        );        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++) &#123;                <span class="hljs-comment">//使用线程池，从线程池获取线程</span>                threadPool.execute(()-&gt;&#123;                    System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"  Ok"</span>);                &#125;);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//关闭连接池</span>            threadPool.shutdown();        &#125;    &#125;&#125;</code></pre></div><blockquote><p><strong>四种拒绝策略</strong></p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_19-06-59.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* new ThreadPoolExecutor.AbortPolicy() // 银行满了，还有人进来，不处理这个人的，抛出异常</span><span class="hljs-comment">*</span><span class="hljs-comment">* new ThreadPoolExecutor.CallerRunsPolicy() // 哪来的去哪里！</span><span class="hljs-comment">*</span><span class="hljs-comment">* new ThreadPoolExecutor.DiscardPolicy() //队列满了，丢掉任务，不会抛出异常！</span><span class="hljs-comment">*</span><span class="hljs-comment">* new ThreadPoolExecutor.DiscardOldestPolicy() //队列满了，尝试去和最早的竞争，也不会抛出异常！</span><span class="hljs-comment">*/</span></code></pre></div><blockquote><p>小结和扩展</p></blockquote><p>最大线程池如何定义</p><p>CPU 密集型，几核就设置几，可以保持CPU的效率最高</p><p>IO 密集型  判断程序中什么耗IO的线程就几个，一般设置2倍就行</p><p>​        程序 15个大型任务 io什么占资源</p><h2 id="12、四大函数式接口（掌握）"><a href="#12、四大函数式接口（掌握）" class="headerlink" title="12、四大函数式接口（掌握）"></a>12、四大函数式接口（掌握）</h2><p><strong>jdk1.8 新特新 stream 流  链式编程 lambda表达式  函数式接口</strong></p><blockquote><p>函数式接口：有且只有一个抽象方法的接口 @FunctionnalInterface</p></blockquote><p>foreach的参数就是一个函数式接口</p><p>只要是函数式接口 可以用lambda表达式简化</p><p><strong>四大函数式接口</strong></p><ul><li><strong>Function</strong></li></ul><blockquote><p>Function 传入一个参数，返回指定类型的值</p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_23-20-22.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.functionInterface;<span class="hljs-keyword">import</span> java.util.function.Function;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/10 23:56</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FunctionDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//函数式接口 ： 有且只有一个抽象方法的接口</span>        <span class="hljs-comment">//参数类型可以省掉，他可一根据上下文自己推断出</span>        <span class="hljs-comment">//传入一个参数返回指定类型的值</span>        Function&lt;String,String&gt; function =  (s)-&gt; &#123;<span class="hljs-keyword">return</span> s+<span class="hljs-string">"Function"</span>;&#125;;        System.out.println(function.apply(<span class="hljs-string">"yang"</span>));    &#125;&#125;</code></pre></div><ul><li><strong>Predicate</strong></li></ul><blockquote><p>Predicate 断定性接口，有一个输入参数，返回值只能是boolean值</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.functionInterface;<span class="hljs-keyword">import</span> java.util.function.Predicate;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 0:07</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PredicateDemo</span> </span>&#123;    <span class="hljs-comment">//predicate 断言型接口 : 传入一个参数，返回值只能是boolean类型</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Predicate&lt;String&gt; predicate = (String s) -&gt;&#123; <span class="hljs-keyword">return</span> s.isEmpty(); &#125;;        System.out.println(predicate.test(<span class="hljs-string">""</span>));    &#125;&#125;</code></pre></div><ul><li>Consumer </li></ul><blockquote><p>Consumer 消费性接口局，只有输入没有返回值</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.functionInterface;<span class="hljs-keyword">import</span> java.util.function.Consumer;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 0:11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Consumer&lt;String&gt;  consumer = (String s) -&gt; &#123; System.out.println(s + <span class="hljs-string">"只有输入没有输出，对给定的参数进行操作"</span>); &#125;;        consumer.accept(<span class="hljs-string">"consumer"</span>);    &#125;&#125;</code></pre></div><ul><li>Supplier</li></ul><blockquote><p>Supplier 供给性接口，没有参数，只有返回值</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.functionInterface;<span class="hljs-keyword">import</span> java.util.function.Supplier;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 0:15</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuppilerDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// supplier 供给行接口 没有参数只有返回值 可以理解省生产者</span>        Supplier&lt;String&gt; supplier = ()-&gt;&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"我是supplier 供给型接口"</span>; &#125;;        System.out.println(supplier.get());    &#125;&#125;</code></pre></div><p>在stream流中可看见很多函数式接口的工具类</p><h2 id="13、Stream流式计算"><a href="#13、Stream流式计算" class="headerlink" title="13、Stream流式计算"></a>13、Stream流式计算</h2><blockquote><p>什么是Stream流式计算</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.stream;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 9:08</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StreamDemo</span> </span>&#123;    <span class="hljs-comment">//Stream流式计算</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 题目要求：一分钟内完成此题，只能用一行代码实现！</span><span class="hljs-comment">     * 现在有5个用户！筛选：</span><span class="hljs-comment">     * 1、ID 必须是偶数</span><span class="hljs-comment">     * 2、年龄必须大于23岁</span><span class="hljs-comment">     * 3、用户名转为大写字母</span><span class="hljs-comment">     * 4、用户名字母倒着排序</span><span class="hljs-comment">     * 5、只输出一个用户！</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        User u1 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>,<span class="hljs-string">"erw"</span>,<span class="hljs-number">35</span>);        User u2 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>,<span class="hljs-string">"trt"</span>,<span class="hljs-number">42</span>);        User u3 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>,<span class="hljs-string">"fgf"</span>,<span class="hljs-number">12</span>);        User u4 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>,<span class="hljs-string">"hgh"</span>,<span class="hljs-number">17</span>);        User u5 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">5</span>,<span class="hljs-string">"iop"</span>,<span class="hljs-number">12</span>);        List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(u1);        list.add(u2);        list.add(u3);        list.add(u4);        list.add(u5);        <span class="hljs-comment">//使用stream流进行计算 ，结合lambda表达式 ， 函数式接口，链式编程 一条代码完成以上5个需求</span>        list.stream().filter((user)-&gt;&#123;<span class="hljs-keyword">return</span> user.getId() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;&#125;).                filter((user)-&gt;&#123;<span class="hljs-keyword">return</span> user.getAge()&gt;<span class="hljs-number">23</span>;&#125;).                map((user)-&gt;&#123;<span class="hljs-keyword">return</span> user.getName().toUpperCase();&#125;).                limit(<span class="hljs-number">1</span>)                .forEach((user)-&gt;&#123; System.out.println(user);&#125;);    &#125;&#125;</code></pre></div><div class="note note-primary">            <p>总结：stream 流式计算简化了开发，其中的方法都有函数式接口。获取stream流针对collection 和 map 和数组</p><p>collection集合通过 stream（）获取流对象</p><p>Map 可以分别为 keys 和 values 以及entrySet 获取stream流  keys.stream( )  values.stream( )  entrySet.stream( )</p><p>Array  通过Stream接口提供的默认of 方法获取stream 流 Stream.of（array）</p>          </div><h2 id="14、ForkJoin"><a href="#14、ForkJoin" class="headerlink" title="14、ForkJoin"></a>14、ForkJoin</h2><blockquote><p>什么是ForkJoin</p></blockquote><p>将一个大任务分割成若干小任务，最终汇总每个小任务的结果得到这个大任务的结果。</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-10_23-51-37.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>ForkJion特点：工作窃取</p></blockquote><p>这里面维护的都是双端队列</p><p>一个大的任务被分成多个小任务，这些任务被分配到不同的队列中执行，这些队列有的干活快，有的干活慢。于是干活快的，做完自己的之后就会去其他的队列中拿任务去执行。</p><h2 id="16、JMM"><a href="#16、JMM" class="headerlink" title="16、JMM"></a>16、JMM</h2><blockquote><p>请你谈谈你对Volatile的理解</p></blockquote><p>Volatile是java虚拟机提供轻量级的同步机制</p><p>特点：</p><p>1、只保证可见性</p><p>2、<code>不保证原子性</code></p><p>3、禁止指令重排</p><p>说到可见性就不得不说JMM</p><blockquote><p>什么是JMM</p></blockquote><p>JMM ： java内存模型，不存在的东西，是概念性的。</p><p><strong>关于JMM的一些同步约定</strong></p><p>1、线程解锁前，必须把共享变量<code>立刻刷回主存</code>。（线程执行时，会复制一份数据到自己的内存中执行）</p><p>2、线程加锁前，必须读取主存中的最新值到工作内存中</p><p>3、加锁和解锁必须是同一把锁</p><p><strong>8中操作：</strong></p><hr><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_10-41-59.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_10-45-56.jpg" srcset="/img/loading.gif" alt></p><p><strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的（对于double和long类</strong><br><strong>型的变量来说，load、store、read和write操作在某些平台上允许例外）</strong></p><ul><li>lock （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li><li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量<br>才可以被其他线程锁定</li><li>read （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便<br>随后的load动作使用</li><li>load （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li><li>use （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机<br>遇到一个需要使用到变量的值，就会使用到这个指令</li><li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变<br>量副本中</li><li>store （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，<br>以便后续的write使用</li><li>write （写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内<br>存的变量中</li></ul><p><strong>MM对这八种指令的使用，制定了如下规则：</strong></p><ul><li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</p></li><li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存<br>不允许一个线程将没有assign的数据从工作内存同步回主内存</p></li><li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p></li><li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解<br>锁</p></li><li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p></li><li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量<br>对一个变量进行unlock操作之前，必须把此变量同步回主内存</p></li></ul><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_17-00-15.jpg" srcset="/img/loading.gif" alt></p><h2 id="17、Volatile"><a href="#17、Volatile" class="headerlink" title="17、Volatile"></a>17、Volatile</h2><blockquote><p><strong>1、保证可见性</strong></p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.volatile00;<span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 18:52</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo01</span> </span>&#123;    <span class="hljs-comment">//不加volatile 程序就会死循环</span>    <span class="hljs-comment">//加了volatile 保证了可见性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123; <span class="hljs-comment">//线程1对主内存的变化不知道的</span>            <span class="hljs-keyword">while</span> (num == <span class="hljs-number">0</span>) &#123;            &#125;        &#125;, <span class="hljs-string">"线程1"</span>).start();        <span class="hljs-keyword">try</span> &#123;            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">//main线程来修改了主存中的值,但是线程1不知道，还是死循环状态</span>        num = <span class="hljs-number">1</span>;        System.out.println(num);    &#125;&#125;</code></pre></div><blockquote><p><strong>2、不保证原子性</strong></p></blockquote><p>原子性：不可分割</p><p>线程A在执行任务的时候，不能被打扰也不能分割。要么成功，要么失败。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.volatile00;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 20:53</span><span class="hljs-comment"> */</span><span class="hljs-comment">// volatile 不保证原子性</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> </span>&#123;    <span class="hljs-comment">// volatile 不保证原子性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;        num++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//理论上num结果应该为 2 万</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span> ; j++) &#123;                    add();                &#125;            &#125;).start();        &#125;        <span class="hljs-keyword">while</span> (Thread.activeCount()&gt;<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// main gc</span>            Thread.yield();        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + num);    &#125;&#125;</code></pre></div><p>如果不使用lock和synchronized，怎么保证原子性</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_21-22-22.jpg" srcset="/img/loading.gif" alt></p><p>使用原子类，解决原子性问题</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_21-24-11.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.volatile00;<span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/11 20:53</span><span class="hljs-comment"> */</span><span class="hljs-comment">// volatile 不保证原子性</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> </span>&#123;    <span class="hljs-comment">// volatile 不保证原子性</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> AtomicInteger num = <span class="hljs-keyword">new</span> AtomicInteger();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// num++; // 不是一个原子性操作</span>        num.getAndIncrement(); <span class="hljs-comment">// AtomicInteger + 1 方法， CAS(乐观锁)</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//理论上num结果应该为 2 万</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span> ; j++) &#123;                    add();                &#125;            &#125;).start();        &#125;        <span class="hljs-keyword">while</span> (Thread.activeCount()&gt;<span class="hljs-number">2</span>)&#123; <span class="hljs-comment">// main gc</span>            Thread.yield();        &#125;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">" "</span> + num);    &#125;&#125;</code></pre></div><p>这些类的底层直接和操作系统挂钩！在内存中修改值！UnSafe类是一个特殊的存在！</p><blockquote><p><strong>3、指令重排</strong></p></blockquote><p>什么是指令重排：你写的程序代码，计算机并不是按照你写的那样去执行的</p><p>源代码–&gt;编译器优化的重排–&gt;指令并行也可能会重排–&gt;内存系统也会重排—&gt;执行</p><p><strong>volatile可以避免指令重排：</strong></p><p>内存屏障。CPU指令。作用：</p><p>1、保证特定的操作的执行顺序！</p><p>2、可以保证某些变量的内存可见性（利用这些特性volatile实现的可见性）</p><p>处理器在进行指令重排的时候，考虑：数据之间的依赖性！</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// 1</span><span class="hljs-keyword">int</span> y = <span class="hljs-number">2</span>; <span class="hljs-comment">// 2</span>x = x + <span class="hljs-number">5</span>; <span class="hljs-comment">// 3</span>y = x * x; <span class="hljs-comment">// 4</span>我们所期望的：<span class="hljs-number">1234</span> 但是可能执行的时候回变成 <span class="hljs-number">2134</span> <span class="hljs-number">1324</span>可不可能是 <span class="hljs-number">4123</span>！</code></pre></div><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_20-51-48.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_20-52-00.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-11_20-43-55.jpg" srcset="/img/loading.gif" alt></p><p><strong>Volatile是可以保持可见性。不能保证原子性，由于内存屏障，可以保证指令重排的现象的产生。</strong></p><h2 id="18、彻底玩转单例模式"><a href="#18、彻底玩转单例模式" class="headerlink" title="18、彻底玩转单例模式"></a>18、彻底玩转单例模式</h2><p>饿汉式 DCL懒汉式（双重检验锁），深究！</p><ul><li>饿汉式：线程安全（不排除反射），调用效率高，不能延时加载</li><li>懒汉式：线程安全（不排除反射）,调用效率不高，可以延时加载</li><li>DCL懒汉式：由于JVM底层模型原因，偶尔出现问题，不建议使用</li><li>静态内部类式：线程安全（不排除反射），调用效率高，可以延时加载</li><li>枚举单例：线程安全，调用效率高，不能延时加载</li></ul><blockquote><p>饿汉式  在类加载时就创建对象，由于在类加载时就创建单例，因此不存在线程安全问题</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.signal;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 12:14</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hungry</span> </span>&#123;    <span class="hljs-comment">//饿汉式的单例模式</span>    <span class="hljs-comment">// 可能会浪费空间</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] data4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];    <span class="hljs-comment">//1.私有化构造方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Hungry</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-comment">// 2.提供一私有的静态实例</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span>  <span class="hljs-keyword">static</span> Hungry HUNGRY = <span class="hljs-keyword">new</span> Hungry();    <span class="hljs-comment">//3.对外提供一个静态的方法来获取实例</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Hungry <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> HUNGRY;    &#125;&#125;</code></pre></div><blockquote><p>懒汉式    懒汉式使用同步锁锁住了整个方法，效率较低</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.signal;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 12:31</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo2</span> </span>&#123;    <span class="hljs-comment">//懒汉式--类加载的时候不会立即创建对象，只是生成了一个单例的引用，可以延迟加载</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo2</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-comment">//对象的空引用</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonDemo2 singletonDemo2 = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//提供公共的获取方法</span>    <span class="hljs-comment">//问题是 这个synchronized 锁着整个方法，效率低 使用DCL懒汉式来解决这个问题</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">synchronized</span> SingletonDemo2 <span class="hljs-title">getInstance2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//因为不是类加载的时候创建的实例，在多线程的情况有安全问题，使用synchronized来保证线程的安全问题</span>        <span class="hljs-keyword">if</span>(singletonDemo2 == <span class="hljs-keyword">null</span>)&#123;            singletonDemo2 = <span class="hljs-keyword">new</span> SingletonDemo2();        &#125;        <span class="hljs-keyword">return</span> singletonDemo2;    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo2Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SingletonDemo2 instance = SingletonDemo2.getInstance2();        SingletonDemo2 instance1 = SingletonDemo2.getInstance2();        System.out.println(instance == instance1); <span class="hljs-comment">//输出true</span>    &#125;&#125;</code></pre></div><blockquote><p>DCL懒汉式   同样是在类加载时只提供一个引用，不会直接创建单例对象，不需要对整个方法进行同步，缩小了锁的范围，只有第一次会进入创建对象的方法，提高了效率</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.signal;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 14:36</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo05</span> </span>&#123;    <span class="hljs-comment">//DCL懒汉式</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo05</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-comment">//volatile 保证可见性 其他线程修改了值，其他在执行的能立即知道</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonDemo05 singletonDemo05 = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">// 不让线程每次调用getInstanceC()方法时都加锁，而只是在实例未被创建时再加锁,只走一次同步方法。</span>    <span class="hljs-comment">// 在加锁处理里面还需要判断一次实例是否已存在。</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  SingletonDemo05 <span class="hljs-title">getSingletonDemo05</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(singletonDemo05 == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span> (SingletonDemo05<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;                <span class="hljs-keyword">if</span> (singletonDemo05 == <span class="hljs-keyword">null</span>)&#123;                    singletonDemo05 = <span class="hljs-keyword">new</span> SingletonDemo05(); <span class="hljs-comment">//不是一个原子操作</span>                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> singletonDemo05;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SingletonDemo05 singletonDemo1 = SingletonDemo05.getSingletonDemo05();        SingletonDemo05 singletonDemo2 = SingletonDemo05.getSingletonDemo05();        System.out.println(singletonDemo1 == singletonDemo2);    &#125;&#125;</code></pre></div><blockquote><p>静态内部类</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.signal;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 12:50</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo4</span> </span>&#123;    <span class="hljs-comment">//使用静态内部类的方式实现单例模式</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonDemo4</span><span class="hljs-params">()</span></span>&#123;    &#125;    <span class="hljs-comment">//不会在外部内初始化的时候直接就加载，只有当调用了公共方法获取时才会加载，线程安全</span>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClass</span></span>&#123;        <span class="hljs-comment">//final 保证了只有一份</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonDemo4 SINGLETON_DEMO_4 = <span class="hljs-keyword">new</span> SingletonDemo4();    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonDemo4 <span class="hljs-title">getInstance4</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//通过静态内部类的类名去获取</span>        <span class="hljs-keyword">return</span> InnerClass.SINGLETON_DEMO_4;    &#125;&#125;<span class="hljs-comment">//测试</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonDemo4Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SingletonDemo4 instance = SingletonDemo4.getInstance4();        SingletonDemo4 instance1 = SingletonDemo4.getInstance4();        System.out.println(instance == instance1); <span class="hljs-comment">//输出true</span>    &#125;&#125;</code></pre></div><p><strong>因为反射机制的存在，以上四种都是不安全的，反射可以破坏私有的属性，创建对象*</strong></p><p>//关闭权限检测*        declaredConstructor.setAccessible(true);</p><p><strong><code>枚举是创建单例的不二之选</code></strong></p><blockquote><p>枚举    当反射遇到枚举时直接抛出异常，因此，枚举是创建单例的不二之选</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.signal;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 13:01</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnumDemo</span> </span>&#123;    <span class="hljs-comment">//枚举的方式--单例模式</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Single single = Single.SINGLE;        single.print();        Single single2 = Single.SINGLE;        System.out.println(single == single2);    &#125;    <span class="hljs-keyword">enum</span> Single&#123;        SINGLE;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;        &#125;;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">"hello world"</span>);        &#125;    &#125;&#125;</code></pre></div><p>总结：要想线程安全并且避免反射创建对象  使用 饿汉式 和 枚举</p><h2 id="19、深入理解CAS"><a href="#19、深入理解CAS" class="headerlink" title="19、深入理解CAS"></a>19、深入理解CAS</h2><blockquote><p>什么是CAS</p></blockquote><p>搞明白在写。。。。</p><h2 id="20、原子引用"><a href="#20、原子引用" class="headerlink" title="20、原子引用"></a>20、原子引用</h2><blockquote><p>解决ABA 问题，引入原子引用！ 对应的思想：乐观锁！</p></blockquote><p>带版本号 的原子操作！</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CASDemo</span> </span>&#123;    <span class="hljs-comment">//AtomicStampedReference 注意，如果泛型是一个包装类，注意对象的引用问题</span>    <span class="hljs-comment">// 正常在业务操作，这里面比较的都是一个个对象</span>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="hljs-keyword">new</span>    AtomicStampedReference&lt;&gt;(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);    <span class="hljs-comment">// CAS compareAndSet : 比较并交换！</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="hljs-comment">// 获得版本号</span>        System.out.println(<span class="hljs-string">"a1=&gt;"</span>+stamp);        <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();    &#125;        atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,        atomicStampedReference.getStamp(),        atomicStampedReference.getStamp() + <span class="hljs-number">1</span>);        System.out.println(<span class="hljs-string">"a2=&gt;"</span>+atomicStampedReference.getStamp());        System.out.println(atomicStampedReference.compareAndSet(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>,        atomicStampedReference.getStamp(),        atomicStampedReference.getStamp() + <span class="hljs-number">1</span>));        System.out.println(<span class="hljs-string">"a3=&gt;"</span>+atomicStampedReference.getStamp());    &#125;,<span class="hljs-string">"a"</span>).start();    <span class="hljs-comment">// 乐观锁的原理相同！</span>    <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;        <span class="hljs-keyword">int</span> stamp = atomicStampedReference.getStamp(); <span class="hljs-comment">// 获得版本号</span>        System.out.println(<span class="hljs-string">"b1=&gt;"</span>+stamp);        <span class="hljs-keyword">try</span> &#123;        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;        e.printStackTrace();        &#125;        System.out.println(atomicStampedReference.compareAndSet(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>,        stamp, stamp + <span class="hljs-number">1</span>));        System.out.println(<span class="hljs-string">"b2=&gt;"</span>+atomicStampedReference.getStamp());    &#125;,<span class="hljs-string">"b"</span>).start();    &#125;&#125;</code></pre></div><h2 id="21、各种锁的理解"><a href="#21、各种锁的理解" class="headerlink" title="21、各种锁的理解"></a>21、各种锁的理解</h2><h3 id="1、公平锁、非公平锁"><a href="#1、公平锁、非公平锁" class="headerlink" title="1、公平锁、非公平锁"></a>1、公平锁、非公平锁</h3><p>公平锁：非常公平，不能够插队，必须先来后到！</p><p>非公平锁：非常不公平，可以插队（比如一个任务2小时，一个1秒）<code>默认都是非公平</code>,为了保证性能问题</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_12-11-40.jpg" srcset="/img/loading.gif" alt></p><h3 id="2、可重入锁"><a href="#2、可重入锁" class="headerlink" title="2、可重入锁"></a>2、可重入锁</h3><p>可重入锁（递归锁）</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_12-03-13.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>Synchronized</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lockdemo;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 12:09</span><span class="hljs-comment"> */</span><span class="hljs-comment">// Synchronized</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone phone = <span class="hljs-keyword">new</span> Phone();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone.sms();        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone.sms();        &#125;,<span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">()</span></span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"sms"</span>);        call(); <span class="hljs-comment">// 这里也有锁</span>    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"call"</span>);    &#125;&#125;</code></pre></div><blockquote><p>lock</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lockdemo;<span class="hljs-keyword">import</span> java.util.concurrent.locks.Lock;<span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo02</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Phone2 phone = <span class="hljs-keyword">new</span> Phone2();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone.sms();        &#125;,<span class="hljs-string">"A"</span>).start();        <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;            phone.sms();        &#125;,<span class="hljs-string">"B"</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone2</span></span>&#123;    Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sms</span><span class="hljs-params">()</span></span>&#123;        lock.lock(); <span class="hljs-comment">// 细节问题：lock.lock(); lock.unlock(); // lock 锁必须配对，否则就会死在里面</span>        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"sms"</span>);            call(); <span class="hljs-comment">// 这里也有锁</span>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();            lock.unlock();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">call</span><span class="hljs-params">()</span></span>&#123;        lock.lock();        <span class="hljs-keyword">try</span> &#123;            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"call"</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            lock.unlock();        &#125;    &#125;&#125;</code></pre></div><h3 id="3、自旋锁"><a href="#3、自旋锁" class="headerlink" title="3、自旋锁"></a>3、自旋锁</h3><p>不断的尝试，直到成功为止</p><p>当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放</p><h3 id="4、死锁"><a href="#4、死锁" class="headerlink" title="4、死锁"></a>4、死锁</h3><blockquote><p>什么是死锁</p></blockquote><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_11-42-50.jpg" srcset="/img/loading.gif" alt></p><p>死锁测试，怎么排除死锁：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.lockdemo;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/7/12 11:45</span><span class="hljs-comment"> */</span><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockDemo</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String lockA = <span class="hljs-string">"lockA"</span>;        String lockB = <span class="hljs-string">"lockB"</span>;        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(lockA, lockB), <span class="hljs-string">"T1"</span>).start();        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MyThread(lockB, lockA), <span class="hljs-string">"T2"</span>).start();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;    <span class="hljs-keyword">private</span> String lockA;    <span class="hljs-keyword">private</span> String lockB;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(String lockA, String lockB)</span> </span>&#123;        <span class="hljs-keyword">this</span>.lockA = lockA;        <span class="hljs-keyword">this</span>.lockB = lockB;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">synchronized</span> (lockA)&#123;            System.out.println(Thread.currentThread().getName() +                    <span class="hljs-string">"lock:"</span>+lockA+<span class="hljs-string">"=&gt;get"</span>+lockB);            <span class="hljs-keyword">try</span> &#123;                TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;            <span class="hljs-keyword">synchronized</span> (lockB)&#123;                System.out.println(Thread.currentThread().getName() +                        <span class="hljs-string">"lock:"</span>+lockB+<span class="hljs-string">"=&gt;get"</span>+lockA);            &#125;        &#125;    &#125;&#125;</code></pre></div><blockquote><p><strong>死锁产生的4个必要条件</strong></p></blockquote><p><strong>互斥、请求和保持、不剥夺、环路等待</strong></p><p>产生死锁的必要条件：</p><p>1、互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</p><p>2、请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</p><p>2、不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</p><p>3、环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</p><blockquote><p>解决问题 死锁检查找到死锁的原因</p></blockquote><p>jstack是java虚拟机自带的一种堆栈跟踪工具</p><p>1、使用<code>jsp -l</code>定位进程号</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_11-48-44.jpg" srcset="/img/loading.gif" alt></p><p>2、使用 <code>jstack 进程号</code>找到死锁问题</p><p><img src="https://www.qfeng.online/imgs/JUC/JUC_2020-07-12_11-51-14.jpg" srcset="/img/loading.gif" alt></p><p>面试，工作中！ 排查问题：</p><p>1、查看日志</p><p>2、查看堆栈信息</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChangGou项目api文档</title>
    <link href="/2020/07/11/ChangGou%E9%A1%B9%E7%9B%AEapi%E6%96%87%E6%A1%A3/"/>
    <url>/2020/07/11/ChangGou%E9%A1%B9%E7%9B%AEapi%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>ChangGou</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务解决方案</title>
    <link href="/2020/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2020/07/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h1><h2 id="1-分布式事务解决方案"><a href="#1-分布式事务解决方案" class="headerlink" title="1.分布式事务解决方案"></a>1.分布式事务解决方案</h2><h3 id="1-1-本地事务与分布式事务"><a href="#1-1-本地事务与分布式事务" class="headerlink" title="1.1 本地事务与分布式事务"></a>1.1 本地事务与分布式事务</h3><h4 id="1-1-1-事务"><a href="#1-1-1-事务" class="headerlink" title="1.1.1 事务"></a>1.1.1 事务</h4><p>数据库事务(简称：事务，Transaction)是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。</p><p>事务拥有以下四个特性，习惯上被称为ACID特性：</p><p><strong>原子性(Atomicity)</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</p><p><strong>一致性(Consistency)</strong>：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态是指数据库中的数据应满足完整性约束。除此之外，一致性还有另外一层语义，就是事务的中间状态不能被观察到(这层语义也有说应该属于原子性)。</p><p><strong>隔离性(Isolation)</strong>：多个事务并发执行时，一个事务的执行不应影响其他事务的执行，如同只有这一个操作在被数据库所执行一样。</p><p><strong>持久性(Durability)</strong>：已被提交的事务对数据库的修改应该永久保存在数据库中。在事务结束时，此操作将不可逆转。</p><h4 id="1-1-2-本地事务"><a href="#1-1-2-本地事务" class="headerlink" title="1.1.2 本地事务"></a>1.1.2 本地事务</h4><p>起初，事务仅限于对单一数据库资源的访问控制,架构服务化以后，事务的概念延伸到了服务中。倘若将一个单一的服务操作作为一个事务，那么整个服务操作只能涉及一个单一的数据库资源,这类基于单个服务单一数据库资源访问的事务，被称为本地事务(Local Transaction)。 </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-10.png" srcset="/img/loading.gif" alt></p><h4 id="1-1-3-分布式事务"><a href="#1-1-3-分布式事务" class="headerlink" title="1.1.3 分布式事务"></a>1.1.3 分布式事务</h4><p>​        分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上,且属于不同的应用，分布式事务需要保证这些操作要么全部成功，要么全部失败。本质上来说，<strong>分布式事务就是为了保证不同数据库的数据一致性</strong>。 </p><p>​       最早的分布式事务应用架构很简单，不涉及服务间的访问调用，仅仅是服务内操作涉及到对多个数据库资源的访问。  </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-11.png" srcset="/img/loading.gif" alt></p><p>​        当一个服务操作访问不同的数据库资源，又希望对它们的访问具有事务特性时，就需要采用分布式事务来协调所有的事务参与者。</p><p>​        对于上面介绍的分布式事务应用架构，尽管一个服务操作会访问多个数据库资源，但是毕竟整个事务还是控制在单一服务的内部。如果一个服务操作需要调用另外一个服务，这时的事务就需要跨越多个服务了。在这种情况下，起始于某个服务的事务在调用另外一个服务的时候，需要以某种机制流转到另外一个服务，从而使被调用的服务访问的资源也自动加入到该事务当中来。下图反映了这样一个跨越多个服务的分布式事务：</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-12.png" srcset="/img/loading.gif" alt></p><p>​        如果将上面这两种场景(一个服务可以调用多个数据库资源，也可以调用其他服务)结合在一起，对此进行延伸，整个分布式事务的参与者将会组成如下图所示的树形拓扑结构。在一个跨服务的分布式事务中，事务的发起者和提交均系同一个，它可以是整个调用的客户端，也可以是客户端最先调用的那个服务。 </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-13.png" srcset="/img/loading.gif" alt></p><p>​         较之基于单一数据库资源访问的本地事务，分布式事务的应用架构更为复杂。在不同的分布式应用架构下，实现一个分布式事务要考虑的问题并不完全一样，比如对多资源的协调、事务的跨服务传播等，实现机制也是复杂多变。</p><h3 id="1-2-分布式事务相关理论"><a href="#1-2-分布式事务相关理论" class="headerlink" title="1.2 分布式事务相关理论"></a>1.2 分布式事务相关理论</h3><h4 id="1-2-1-CAP定理"><a href="#1-2-1-CAP定理" class="headerlink" title="1.2.1 CAP定理"></a>1.2.1 CAP定理</h4><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-20.jpg" srcset="/img/loading.gif" alt></p><p>CAP定理是在 1998年加州大学的计算机科学家 Eric Brewer （埃里克.布鲁尔）提出，分布式系统有三个指标</p><ul><li>Consistency   一致性</li><li>Availability     可用性</li><li>Partition tolerance   分区容错性</li></ul><p><strong>它们的第一个字母分别是 C、A、P。Eric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</strong></p><h5 id="分区容错-Partition-tolerance"><a href="#分区容错-Partition-tolerance" class="headerlink" title="分区容错  Partition tolerance"></a>分区容错  Partition tolerance</h5><p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-21.png" srcset="/img/loading.gif" alt></p><p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p><p>一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><h5 id="可用性-Availability"><a href="#可用性-Availability" class="headerlink" title="可用性 Availability"></a>可用性 Availability</h5><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p><p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-22.png" srcset="/img/loading.gif" alt></p><h5 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性 Consistency"></a>一致性 Consistency</h5><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。</p><p>举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-23.png" srcset="/img/loading.gif" alt></p><p>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-24.png" srcset="/img/loading.gif" alt></p><p>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-25.png" srcset="/img/loading.gif" alt></p><h5 id="一致性和可用性的矛盾"><a href="#一致性和可用性的矛盾" class="headerlink" title="一致性和可用性的矛盾"></a>一致性和可用性的矛盾</h5><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p><p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性。</p><p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p><p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p><h4 id="1-2-2-BASE理论"><a href="#1-2-2-BASE理论" class="headerlink" title="1.2.2 BASE理论"></a>1.2.2 BASE理论</h4><p>BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。BASE 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是：</p><blockquote><p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p></blockquote><h5 id="Basically-Available-基本可用"><a href="#Basically-Available-基本可用" class="headerlink" title="Basically Available(基本可用)"></a>Basically Available(基本可用)</h5><p><strong>损失部分可用功能，保证核心功能可用</strong></p><p>什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：</p><ol><li>响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而<strong>基本可用</strong>的搜索引擎可以在 1 秒作用返回结果。</li><li>功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ol><h5 id="Soft-state（软状态）"><a href="#Soft-state（软状态）" class="headerlink" title="Soft state（软状态）"></a>Soft state（软状态）</h5><p>什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。</p><p>软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。</p><h5 id="Eventually-consistent（最终一致性）"><a href="#Eventually-consistent（最终一致性）" class="headerlink" title="Eventually consistent（最终一致性）"></a>Eventually consistent（最终一致性）</h5><p>系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。</p><h3 id="1-3-分布式事务解决方案"><a href="#1-3-分布式事务解决方案" class="headerlink" title="1.3 分布式事务解决方案"></a>1.3 分布式事务解决方案</h3><h4 id="1-3-1-基于XA协议的两阶段提交-2PC"><a href="#1-3-1-基于XA协议的两阶段提交-2PC" class="headerlink" title="1.3.1 基于XA协议的两阶段提交 2PC"></a>1.3.1 基于XA协议的两阶段提交 2PC</h4><p>首先我们来简要看下分布式事务处理的XA规范 ： </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-14.png" srcset="/img/loading.gif" alt></p><p>可知XA规范中分布式事务有AP，RM，TM组成：</p><p>其中应用程序(Application Program ，简称AP)：AP定义事务边界（定义事务开始和结束）并访问事务边界内的资源。</p><p>资源管理器(Resource Manager，简称RM)：Rm管理计算机共享的资源，许多软件都可以去访问这些资源，资源包含比如数据库、文件系统、打印机服务器等。</p><p>事务管理器(Transaction Manager ，简称TM)：负责管理全局事务，分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚、失败恢复等。</p><p><strong>二阶段协议:</strong></p><p><strong>第一阶段</strong>TM要求所有的RM准备提交对应的事务分支，询问RM是否有能力保证成功的提交事务分支，RM根据自己的情况，如果判断自己进行的工作可以被提交，那就对工作内容进行持久化，并给TM回执OK；否者给TM的回执NO。RM在发送了否定答复并回滚了已经完成的工作后，就可以丢弃这个事务分支信息了。</p><p><strong>第二阶段</strong>TM根据阶段1各个RM prepare的结果，决定是提交还是回滚事务。如果所有的RM都prepare成功，那么TM通知所有的RM进行提交；如果有RM prepare回执NO的话，则TM通知所有RM回滚自己的事务分支。</p><p>也就是TM与RM之间是通过两阶段提 交协议进行交互的.</p><p><strong>优点：</strong> 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）</p><p><strong>缺点：</strong> 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。</p><h4 id="1-3-2-TCC补偿机制"><a href="#1-3-2-TCC补偿机制" class="headerlink" title="1.3.2 TCC补偿机制"></a>1.3.2 TCC补偿机制</h4><p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p><ul><li>Try 阶段主要是对业务系统做检测及资源预留</li><li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li><li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li></ul><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-15.png" srcset="/img/loading.gif" alt></p><p>例如： A要向 B 转账，思路大概是： </p><div class="hljs"><pre><code class="hljs angelscript">我们有一个本地方法，里面依次调用 <span class="hljs-number">1</span>、首先在 Try 阶段，要先调用远程接口把 B和 A的钱给冻结起来。 <span class="hljs-number">2</span>、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。 <span class="hljs-number">3</span>、如果第<span class="hljs-number">2</span>步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</code></pre></div><p><strong>优点：</strong> 相比两阶段提交，可用性比较强</p><p><strong>缺点：</strong> 数据的一致性要差一些。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p><h4 id="1-3-3-消息最终一致性"><a href="#1-3-3-消息最终一致性" class="headerlink" title="1.3.3 消息最终一致性"></a>1.3.3 消息最终一致性</h4><p>消息最终一致性应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节： </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/9-16.png" srcset="/img/loading.gif" alt></p><p>基本思路就是：</p><p>消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。</p><p>消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。</p><p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。</p><p><strong>优点：</strong> 一种非常经典的实现，避免了分布式事务，实现了最终一致性。</p><p><strong>缺点：</strong> 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p><h2 id="2-基于Seata实现分布式事务"><a href="#2-基于Seata实现分布式事务" class="headerlink" title="2. 基于Seata实现分布式事务"></a>2. 基于Seata实现分布式事务</h2><h3 id="2-1-Seata简介"><a href="#2-1-Seata简介" class="headerlink" title="2.1 Seata简介"></a>2.1 Seata简介</h3><p>​    Seata（原名Fescar） 是阿里18年开源的分布式事务的框架。Fescar的开源对分布式事务框架领域影响很大。作为开源大户，Fescar来自阿里的GTS，经历了好几次双十一的考验，一经开源便颇受关注。后来Fescar改名为Seata。</p><div class="hljs"><pre><code>Fescar虽然是二阶段提交协议的分布式事务，但是其解决了XA的一些缺点:</code></pre></div><ul><li>单点问题:</li><li>同步阻塞:Fescar的二阶段，其再第一阶段的时候本地事务就已经提交释放资源了，不会像XA会再两个prepare和commit阶段资源都锁住，并且Fescar,commit是异步操作，也是提升性能的一大关键。</li><li>数据不一致:如果出现部分commit失败，那么fescar-server会根据当前的事务模式和分支事务的返回状态的结果来进行不同的重试策略。并且fescar的本地事务会在一阶段的时候进行提交，其实单看数据库来说在commit的时候数据库已经是一致的了。</li><li>只能用于单一数据库: Fescar提供了两种模式，AT和MT。在AT模式下事务资源可以是任何支持ACID的数据库，在MT模式下事务资源没有限制，可以是缓存，可以是文件，可以是其他的等等。当然这两个模式也可以混用。</li></ul><p>同时Fescar也保留了接近0业务入侵的优点，只需要简单的配置Fescar的数据代理和加个注解，加一个Undolog表，就可以达到我们想要的目的。</p><h3 id="2-2-实现原理"><a href="#2-2-实现原理" class="headerlink" title="2.2 实现原理"></a>2.2 实现原理</h3><p>Fescar将一个本地事务做为一个分布式事务分支，所有若干个分布在不同微服务中的本地事务共同组成了一个全局事务，结构如下。 </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/12-1.png" srcset="/img/loading.gif" alt></p><p><strong>Transaction Coordinator (TC)：</strong> 事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。</p><p><strong>Transaction Manager (TM)：</strong> 控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。</p><p><strong>Resource Manager (RM)：</strong> 控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</p><p>一个典型的分布式事务过程：</p><ol><li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID。</li><li>XID 在微服务调用链路的上下文中传播。</li><li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖。</li><li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li><li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li></ol><h3 id="2-3-Fescar模式"><a href="#2-3-Fescar模式" class="headerlink" title="2.3 Fescar模式"></a>2.3 Fescar模式</h3><p>Fescar对分布式事务的实现提供了3种模式，AT模式、MT模式和混合模式：</p><h4 id="2-3-1-AT模式"><a href="#2-3-1-AT模式" class="headerlink" title="2.3.1 AT模式"></a>2.3.1 AT模式</h4><p>业务逻辑不需要关注事务机制，分支与全局事务的交互过程自动进行。</p><p><strong>AT模式</strong>：主要关注多 DB 访问的数据一致性，实现起来比较简单，对业务的侵入较小。</p><p>AT模式部分代码如下：不需要关注执行状态，对业务代码侵入较小。类似代码如下，只需要为方法添加<code>@GlobalTransactional</code>注解即可。</p><p>AT模式的核心是对业务无侵入，是一种改进后的两阶段提交，其设计思路如图：</p><p><strong>第一阶段：</strong></p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1558409540227.png" srcset="/img/loading.gif" alt></p><p>核心在于对业务sql进行解析，转换成undolog，两阶段提交往往对资源的锁定需要持续到第二阶段实际的提交或者回滚操作，而有了回滚日志之后，可以在第一阶段释放对资源的锁定，降低了锁范围，提高效率，即使第二阶段发生异常需要回滚，只需找对undolog中对应数据并反解析成sql来达到回滚目的。Seata通过代理数据源将业务sql的执行解析成undolog来与业务数据的更新同时入库，达到了对业务无侵入的效果。</p><p><strong>第二阶段：</strong></p><p>如果决议是全局提交，此时分支事务此时已经完成提交，不需要同步协调处理（只需要异步清理回滚日志），Phase2 可以非常快速地完成。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1558409853936.png" srcset="/img/loading.gif" alt></p><p>如果决议是全局回滚，RM 收到协调器发来的回滚请求，通过 XID 和 Branch ID 找到相应的回滚日志记录，通过回滚记录生成反向的更新 SQL 并执行，以完成分支的回滚。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1558409898660.png" srcset="/img/loading.gif" alt></p><h4 id="2-3-2-MT模式"><a href="#2-3-2-MT模式" class="headerlink" title="2.3.2 MT模式"></a>2.3.2 MT模式</h4><p>业务逻辑需要被分解为 Prepare/Commit/Rollback 3 部分，形成一个 MT 分支，加入全局事务。</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/12-2.png" srcset="/img/loading.gif" alt></p><p>MT 模式一方面是 AT 模式的补充。另外，更重要的价值在于，通过 MT 模式可以把众多非事务性资源纳入全局事务的管理中</p><h4 id="2-3-3-混合模式"><a href="#2-3-3-混合模式" class="headerlink" title="2.3.3 混合模式"></a>2.3.3 混合模式</h4><p>因为 AT 和 MT 模式的分支从根本上行为模式是一致的，所以可以完全兼容，即，一个全局事务中，可以同时存在 AT 和 MT 的分支。这样就可以达到全面覆盖业务场景的目的：AT 模式可以支持的，使用 AT 模式；AT 模式暂时支持不了的，用 MT 模式来替代。另外，自然的，MT 模式管理的非事务性资源也可以和支持事务的关系型数据库资源一起，纳入同一个分布式事务的管理中。</p><h3 id="2-4-代码实现"><a href="#2-4-代码实现" class="headerlink" title="2.4 代码实现"></a>2.4 代码实现</h3><h4 id="2-4-1-分布式事务公共模块"><a href="#2-4-1-分布式事务公共模块" class="headerlink" title="2.4.1 分布式事务公共模块"></a>2.4.1 分布式事务公共模块</h4><p>（1）创建工程 changgou_common_fescar，引入依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">fescar.version</span>&gt;</span>0.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">fescar.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fescar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fescar-tm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fescar.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.fescar<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>fescar-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;fescar.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><p>（2）将<code>fescar配置文件</code>文件夹中的所有配置文件拷贝到resources工程下，如下图：</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1558411118206.png" srcset="/img/loading.gif" alt></p><p>其中file.conf有2个配置</p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1558411274927.png" srcset="/img/loading.gif" alt></p><p>service.vgroup_mapping.my_test_tx_group 映射到相应的 Fescar-Server 集群名称，然后再根据集群名称.grouplist 获取到可用服务列表。</p><p>（3）创建FescarRMRequestFilter，给每个线程绑定一个XID （资源提供）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FescarRMRequestFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OncePerRequestFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = org.slf4j.LoggerFactory.getLogger( FescarRMRequestFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 给每次线程请求绑定一个XID</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> filterChain</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterInternal</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;        String currentXID = request.getHeader( FescarAutoConfiguration.FESCAR_XID);        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(currentXID))&#123;            RootContext.bind(currentXID);            LOGGER.info(<span class="hljs-string">"当前线程绑定的XID :"</span> + currentXID);        &#125;        <span class="hljs-keyword">try</span>&#123;            filterChain.doFilter(request, response);        &#125; <span class="hljs-keyword">finally</span> &#123;            String unbindXID = RootContext.unbind();            <span class="hljs-keyword">if</span>(unbindXID != <span class="hljs-keyword">null</span>)&#123;                LOGGER.info(<span class="hljs-string">"当前线程从指定XID中解绑 XID :"</span> + unbindXID);                <span class="hljs-keyword">if</span>(!currentXID.equals(unbindXID))&#123;                    LOGGER.info(<span class="hljs-string">"当前线程的XID发生变更"</span>);                &#125;            &#125;            <span class="hljs-keyword">if</span>(currentXID != <span class="hljs-keyword">null</span>)&#123;                LOGGER.info(<span class="hljs-string">"当前线程的XID发生变更"</span>);            &#125;        &#125;    &#125;&#125;</code></pre></div><p>（4）创建FescarRestInterceptor过滤器，每次请求其他微服务的时候，都将XID携带过去。（资源提供）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FescarRestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span>, <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> </span>&#123;        String xid = RootContext.getXID();        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(xid))&#123;            requestTemplate.header( FescarAutoConfiguration.FESCAR_XID, xid);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(HttpRequest request, <span class="hljs-keyword">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        String xid = RootContext.getXID();        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(xid))&#123;            HttpHeaders headers = request.getHeaders();            headers.put( FescarAutoConfiguration.FESCAR_XID, Collections.singletonList(xid));        &#125;        <span class="hljs-keyword">return</span> execution.execute(request, body);    &#125;&#125;</code></pre></div><p>（5）创建FescarAutoConfiguration类  （资源提供）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *  * 创建数据源</span><span class="hljs-comment"> *  * 定义全局事务管理器扫描对象</span><span class="hljs-comment"> *  * 给所有RestTemplate添加头信息防止微服务之间调用问题</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FescarAutoConfiguration</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FESCAR_XID = <span class="hljs-string">"fescarXID"</span>;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 创建代理数据库</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> environment</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(Environment environment)</span></span>&#123;        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();        dataSource.setUrl(environment.getProperty(<span class="hljs-string">"spring.datasource.url"</span>));        <span class="hljs-keyword">try</span> &#123;            dataSource.setDriver(DriverManager.getDriver(environment.getProperty(<span class="hljs-string">"spring.datasource.url"</span>)));        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"can't recognize dataSource Driver"</span>);        &#125;        dataSource.setUsername(environment.getProperty(<span class="hljs-string">"spring.datasource.username"</span>));        dataSource.setPassword(environment.getProperty(<span class="hljs-string">"spring.datasource.password"</span>));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceProxy(dataSource);    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 全局事务扫描器</span><span class="hljs-comment">     * 用来解析带有<span class="hljs-doctag">@GlobalTransactional</span>注解的方法，然后采用AOP的机制控制事务</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> environment</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> GlobalTransactionScanner <span class="hljs-title">globalTransactionScanner</span><span class="hljs-params">(Environment environment)</span></span>&#123;        String applicationName = environment.getProperty(<span class="hljs-string">"spring.application.name"</span>);        String groupName = environment.getProperty(<span class="hljs-string">"fescar.group.name"</span>);        <span class="hljs-keyword">if</span>(applicationName == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GlobalTransactionScanner(groupName == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"my_test_tx_group"</span> : groupName);        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> GlobalTransactionScanner(applicationName, groupName == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"my_test_tx_group"</span> : groupName);        &#125;    &#125;    <span class="hljs-comment">/***</span><span class="hljs-comment">     * 每次微服务和微服务之间相互调用</span><span class="hljs-comment">     * 要想控制全局事务，每次TM都会请求TC生成一个XID，每次执行下一个事务，也就是调用其他微服务的时候都需要将该XID传递过去</span><span class="hljs-comment">     * 所以我们可以每次请求的时候，都获取头中的XID，并将XID传递到下一个微服务</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> restTemplates</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@ConditionalOnBean</span>(&#123;RestTemplate<span class="hljs-class">.<span class="hljs-keyword">class</span>&#125;)</span><span class="hljs-class">    @<span class="hljs-title">Bean</span></span><span class="hljs-class">    <span class="hljs-title">public</span> <span class="hljs-title">Object</span> <span class="hljs-title">addFescarInterceptor</span>(<span class="hljs-title">Collection</span>&lt;<span class="hljs-title">RestTemplate</span>&gt; <span class="hljs-title">restTemplates</span>)</span>&#123;        restTemplates.stream()                .forEach(restTemplate -&gt; &#123;                    List&lt;ClientHttpRequestInterceptor&gt; interceptors = restTemplate.getInterceptors();                    <span class="hljs-keyword">if</span>(interceptors != <span class="hljs-keyword">null</span>)&#123;                        interceptors.add(fescarRestInterceptor());                    &#125;                &#125;);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FescarRMRequestFilter <span class="hljs-title">fescarRMRequestFilter</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FescarRMRequestFilter();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> FescarRestInterceptor <span class="hljs-title">fescarRestInterceptor</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FescarRestInterceptor();    &#125;&#125;</code></pre></div><h4 id="2-4-2-分布式事务的实现"><a href="#2-4-2-分布式事务的实现" class="headerlink" title="2.4.2 分布式事务的实现"></a>2.4.2 分布式事务的实现</h4><p>（1）涉及到分布式事务的数据库添加表</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`undo_log`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT,  <span class="hljs-string">`branch_id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`xid`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`rollback_info`</span> longblob <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`log_status`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`log_created`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`log_modified`</span> datetime <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`ext`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>),  <span class="hljs-keyword">KEY</span> <span class="hljs-string">`idx_unionkey`</span> (<span class="hljs-string">`xid`</span>,<span class="hljs-string">`branch_id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">200</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre></div><p>核心在于对业务sql进行解析，转换成undolog,所以只要支持Fescar分布式事务的微服务数据都需要导入该表结构</p><p>（2）需要添加分布式事务的微服务（<strong>商品微服务、订单微服务</strong>）添加对 changgou_common_fescar的依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--fescar依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.changgou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>changgou_common_fescar<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>（3）在订单微服务的OrderServiceImpl的add方法上增加@GlobalTransactional(name = “order_add”)注解</p><p>（4）启动Fescar-server，打开seata包/fescar-server-0.4.2/bin,双击fescar-server.bat启动fescar-server，如下：  </p><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1558413893986.png" srcset="/img/loading.gif" alt></p><p><a href="https://github.com/seata/seata/releases" target="_blank" rel="noopener">https://github.com/seata/seata/releases</a></p><h4 id="2-4-3-测试"><a href="#2-4-3-测试" class="headerlink" title="2.4.3 测试"></a>2.4.3 测试</h4><p>（1）功能测试，看功能能否正常执行。</p><p>（2）异常测试，我们在方法中添加<code>int x=1/0</code>  ，看库存信息是否能够回滚。</p><h2 id="3-基于消息队列实现分布式事务"><a href="#3-基于消息队列实现分布式事务" class="headerlink" title="3.基于消息队列实现分布式事务"></a>3.基于消息队列实现分布式事务</h2><p><img src="https://www.qfeng.online/imgs/springcloud/assets/1563784993295.png" srcset="/img/loading.gif" alt="1563784993295"></p><h3 id="3-1-准备工作"><a href="#3-1-准备工作" class="headerlink" title="3.1 准备工作"></a>3.1 准备工作</h3><h4 id="3-1-1-changgou-order库新增数据表"><a href="#3-1-1-changgou-order库新增数据表" class="headerlink" title="3.1.1 changgou_order库新增数据表"></a>3.1.1 changgou_order库新增数据表</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`tb_task`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`tb_task`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务id'</span>,  <span class="hljs-string">`create_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`update_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`delete_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`task_type`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务类型'</span>,  <span class="hljs-string">`mq_exchange`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'交换机名称'</span>,  <span class="hljs-string">`mq_routingkey`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'routingkey'</span>,  <span class="hljs-string">`request_body`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">512</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务请求的内容'</span>,  <span class="hljs-string">`status`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务状态'</span>,  <span class="hljs-string">`errormsg`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">512</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务错误信息'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre></div><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`tb_task_his`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`tb_task_his`</span> (  <span class="hljs-string">`id`</span> <span class="hljs-built_in">bigint</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> AUTO_INCREMENT <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务id'</span>,  <span class="hljs-string">`create_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`update_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`delete_time`</span> datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`task_type`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务类型'</span>,  <span class="hljs-string">`mq_exchange`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'交换机名称'</span>,  <span class="hljs-string">`mq_routingkey`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'routingkey'</span>,  <span class="hljs-string">`request_body`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">512</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务请求的内容'</span>,  <span class="hljs-string">`status`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">COMMENT</span> <span class="hljs-string">'任务状态'</span>,  <span class="hljs-string">`errormsg`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">512</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number">9</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre></div><h4 id="3-1-2-changgou-service-order-api添加相关实体类"><a href="#3-1-2-changgou-service-order-api添加相关实体类" class="headerlink" title="3.1.2 changgou_service_order_api添加相关实体类"></a>3.1.2 changgou_service_order_api添加相关实体类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_task"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"create_time"</span>)    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"update_time"</span>)    <span class="hljs-keyword">private</span> Date updateTime;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"delete_time"</span>)    <span class="hljs-keyword">private</span> Date deleteTime;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"task_type"</span>)    <span class="hljs-keyword">private</span> String taskType;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"mq_exchange"</span>)    <span class="hljs-keyword">private</span> String mqExchange;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"mq_routingkey"</span>)    <span class="hljs-keyword">private</span> String mqRoutingkey;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"request_body"</span>)    <span class="hljs-keyword">private</span> String requestBody;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"status"</span>)    <span class="hljs-keyword">private</span> String status;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"errormsg"</span>)    <span class="hljs-keyword">private</span> String errormsg;        <span class="hljs-comment">//getter，setter略</span>&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_task_his"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskHis</span> </span>&#123;    <span class="hljs-meta">@Id</span>    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"create_time"</span>)    <span class="hljs-keyword">private</span> Date createTime;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"update_time"</span>)    <span class="hljs-keyword">private</span> Date updateTime;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"delete_time"</span>)    <span class="hljs-keyword">private</span> Date deleteTime;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"task_type"</span>)    <span class="hljs-keyword">private</span> String taskType;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"mq_exchange"</span>)    <span class="hljs-keyword">private</span> String mqExchange;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"mq_routingkey"</span>)    <span class="hljs-keyword">private</span> String mqRoutingkey;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"request_body"</span>)    <span class="hljs-keyword">private</span> String requestBody;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"status"</span>)    <span class="hljs-keyword">private</span> String status;    <span class="hljs-meta">@Column</span>(name = <span class="hljs-string">"errormsg"</span>)    <span class="hljs-keyword">private</span> String errormsg;    <span class="hljs-comment">//getter，setter略</span>&#125;</code></pre></div><h4 id="3-1-3-changgou-user新增积分日志表"><a href="#3-1-3-changgou-user新增积分日志表" class="headerlink" title="3.1.3 changgou_user新增积分日志表"></a>3.1.3 changgou_user新增积分日志表</h4><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-string">`tb_point_log`</span>;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`tb_point_log`</span> (  <span class="hljs-string">`order_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`user_id`</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-string">`point`</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-string">`order_id`</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre></div><h4 id="3-1-4-changgou-service-user-api添加实体类-PointLog"><a href="#3-1-4-changgou-service-user-api添加实体类-PointLog" class="headerlink" title="3.1.4 changgou_service_user_api添加实体类 PointLog"></a>3.1.4 changgou_service_user_api添加实体类 PointLog</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name=<span class="hljs-string">"tb_point_log"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PointLog</span> </span>&#123;    <span class="hljs-keyword">private</span> String orderId;    <span class="hljs-keyword">private</span> String userId;    <span class="hljs-keyword">private</span> Integer point;    <span class="hljs-comment">//getter，setter略</span>&#125;</code></pre></div><h4 id="3-1-5-changgou-service-order添加rabbitMQ配置类"><a href="#3-1-5-changgou-service-order添加rabbitMQ配置类" class="headerlink" title="3.1.5 changgou_service_order添加rabbitMQ配置类"></a>3.1.5 changgou_service_order添加rabbitMQ配置类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-comment">//添加积分任务交换机</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_BUYING_ADDPOINTUSER = <span class="hljs-string">"ex_buying_addpointuser"</span>;    <span class="hljs-comment">//添加积分消息队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT = <span class="hljs-string">"cg_buying_addpoint"</span>;    <span class="hljs-comment">//完成添加积分消息队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT = <span class="hljs-string">"cg_buying_finishaddpoint"</span>;    <span class="hljs-comment">//添加积分路由key</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT_KEY = <span class="hljs-string">"addpoint"</span>;    <span class="hljs-comment">//完成添加积分路由key</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT_KEY = <span class="hljs-string">"finishaddpoint"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换机配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the exchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EX_BUYING_ADDPOINTUSER)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_BUYING_ADDPOINTUSER</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_BUYING_ADDPOINTUSER).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">//声明队列</span>    <span class="hljs-meta">@Bean</span>(CG_BUYING_FINISHADDPOINT)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_CG_BUYING_FINISHADDPOINT</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_FINISHADDPOINT);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">//声明队列</span>    <span class="hljs-meta">@Bean</span>(CG_BUYING_ADDPOINT)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_CG_BUYING_ADDPOINT</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_ADDPOINT);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定队列到交换机 .</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    the queue</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange the exchange</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the binding</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_FINISHADDPOINT</span><span class="hljs-params">(@Qualifier(CG_BUYING_FINISHADDPOINT)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_BUYING_ADDPOINTUSER)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_FINISHADDPOINT_KEY).noargs();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_ADDPOINT</span><span class="hljs-params">(@Qualifier(CG_BUYING_ADDPOINT)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_BUYING_ADDPOINTUSER)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_ADDPOINT_KEY).noargs();    &#125;&#125;</code></pre></div><h3 id="3-2-订单服务添加任务并发送"><a href="#3-2-订单服务添加任务并发送" class="headerlink" title="3.2 订单服务添加任务并发送"></a>3.2 订单服务添加任务并发送</h3><h4 id="3-2-1-修改添加订单方法"><a href="#3-2-1-修改添加订单方法" class="headerlink" title="3.2.1 修改添加订单方法"></a>3.2.1 修改添加订单方法</h4><p>当添加订单的时候，添加任务表中相关数据, 局部代码如下</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//增加任务表记录</span>Task task = <span class="hljs-keyword">new</span> Task();task.setCreateTime(<span class="hljs-keyword">new</span> Date());task.setUpdateTime(<span class="hljs-keyword">new</span> Date());task.setMqExchange(RabbitMQConfig.EX_BUYING_ADDPOINTURSE);task.setMqRoutingkey(RabbitMQConfig.CG_BUYING_ADDPOINT_KEY);Map map = <span class="hljs-keyword">new</span> HashMap();map.put(<span class="hljs-string">"userName"</span>,order.getUsername());map.put(<span class="hljs-string">"orderId"</span>,order.getId());map.put(<span class="hljs-string">"point"</span>,order.getPayMoney());task.setRequestBody(JSON.toJSONString(map));taskMapper.insertSelective(task);</code></pre></div><h4 id="3-2-2-定时扫描任务表最新数据"><a href="#3-2-2-定时扫描任务表最新数据" class="headerlink" title="3.2.2 定时扫描任务表最新数据"></a>3.2.2 定时扫描任务表最新数据</h4><p>订单服务新增定时任务类，获取小于系统当前时间的所有任务数据</p><h5 id="3-2-2-1-修改订单服务启动类，添加开启定时任务注解"><a href="#3-2-2-1-修改订单服务启动类，添加开启定时任务注解" class="headerlink" title="3.2.2.1 修改订单服务启动类，添加开启定时任务注解"></a>3.2.2.1 修改订单服务启动类，添加开启定时任务注解</h5><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableScheduling</span></code></pre></div><h5 id="3-2-2-2-定义定时任务类"><a href="#3-2-2-2-定义定时任务类" class="headerlink" title="3.2.2.2 定义定时任务类"></a>3.2.2.2 定义定时任务类</h5><h6 id="3-2-2-2-1-查询最新数据"><a href="#3-2-2-2-1-查询最新数据" class="headerlink" title="3.2.2.2.1 查询最新数据"></a>3.2.2.2.1 查询最新数据</h6><p>更新taskMapper新增方法，查询所有小于系统当前时间的数据</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TaskMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">Task</span>&gt; </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"SELECT * from tb_task WHERE update_time&lt;#&#123;currentTime&#125;"</span>)    <span class="hljs-meta">@Results</span>(&#123;<span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"create_time"</span>,property = <span class="hljs-string">"createTime"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"update_time"</span>,property = <span class="hljs-string">"updateTime"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"delete_time"</span>,property = <span class="hljs-string">"deleteTime"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"task_type"</span>,property = <span class="hljs-string">"taskType"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"mq_exchange"</span>,property = <span class="hljs-string">"mqExchange"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"mq_routingkey"</span>,property = <span class="hljs-string">"mqRoutingkey"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"request_body"</span>,property = <span class="hljs-string">"requestBody"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"status"</span>,property = <span class="hljs-string">"status"</span>),            <span class="hljs-meta">@Result</span>(column = <span class="hljs-string">"errormsg"</span>,property = <span class="hljs-string">"errormsg"</span>)&#125;)    <span class="hljs-function">List&lt;Task&gt; <span class="hljs-title">findTaskLessTanCurrentTime</span><span class="hljs-params">(Date currentTime)</span></span>;&#125;</code></pre></div><h6 id="3-2-2-2-2-任务类实现"><a href="#3-2-2-2-2-任务类实现" class="headerlink" title="3.2.2.2.2 任务类实现"></a>3.2.2.2.2 任务类实现</h6><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryPointTask</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TaskMapper taskMapper;    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 0/2 * * * ?"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryTask</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//1.获取小于系统当前时间数据</span>        List&lt;Task&gt; taskList = taskMapper.findTaskLessTanCurrentTime(<span class="hljs-keyword">new</span> Date());        <span class="hljs-keyword">if</span> (taskList!=<span class="hljs-keyword">null</span> &amp;&amp; taskList.size()&gt;<span class="hljs-number">0</span>)&#123;            <span class="hljs-comment">//将任务数据发送到消息队列</span>            <span class="hljs-keyword">for</span> (Task task : taskList) &#123; rabbitTemplate.convertAndSend(RabbitMQConfig.EX_BUYING_ADDPOINTURSE,RabbitMQConfig.CG_BUYING_ADDPOINT_KEY, JSON.toJSONString(task));            &#125;        &#125;    &#125;&#125;</code></pre></div><h3 id="3-3-用户服务更改积分"><a href="#3-3-用户服务更改积分" class="headerlink" title="3.3 用户服务更改积分"></a>3.3 用户服务更改积分</h3><h4 id="3-3-1-添加rabbitmq配置类-与订单服务相同"><a href="#3-3-1-添加rabbitmq配置类-与订单服务相同" class="headerlink" title="3.3.1 添加rabbitmq配置类(与订单服务相同)"></a>3.3.1 添加rabbitmq配置类(与订单服务相同)</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQConfig</span> </span>&#123;    <span class="hljs-comment">//添加积分任务交换机</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EX_BUYING_ADDPOINTURSE = <span class="hljs-string">"ex_buying_addpointurse"</span>;    <span class="hljs-comment">//添加积分消息队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT = <span class="hljs-string">"cg_buying_addpoint"</span>;    <span class="hljs-comment">//完成添加积分消息队列</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT = <span class="hljs-string">"cg_buying_finishaddpoint"</span>;    <span class="hljs-comment">//添加积分路由key</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_ADDPOINT_KEY = <span class="hljs-string">"addpoint"</span>;    <span class="hljs-comment">//完成添加积分路由key</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CG_BUYING_FINISHADDPOINT_KEY = <span class="hljs-string">"finishaddpoint"</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 交换机配置</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the exchange</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>(EX_BUYING_ADDPOINTURSE)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">EX_DECLARE</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> ExchangeBuilder.directExchange(EX_BUYING_ADDPOINTURSE).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">//声明队列</span>    <span class="hljs-meta">@Bean</span>(CG_BUYING_FINISHADDPOINT)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_CG_BUYING_FINISHADDPOINT</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_FINISHADDPOINT);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">//声明队列</span>    <span class="hljs-meta">@Bean</span>(CG_BUYING_ADDPOINT)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">QUEUE_CG_BUYING_ADDPOINT</span><span class="hljs-params">()</span> </span>&#123;        Queue queue = <span class="hljs-keyword">new</span> Queue(CG_BUYING_ADDPOINT);        <span class="hljs-keyword">return</span> queue;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 绑定队列到交换机 .</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> queue    the queue</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exchange the exchange</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the binding</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_FINISHADDPOINT</span><span class="hljs-params">(@Qualifier(CG_BUYING_FINISHADDPOINT)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_BUYING_ADDPOINTURSE)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_FINISHADDPOINT_KEY).noargs();    &#125;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">BINDING_QUEUE_ADDPOINT</span><span class="hljs-params">(@Qualifier(CG_BUYING_ADDPOINT)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(EX_BUYING_ADDPOINTURSE)</span> Exchange exchange) </span>&#123;        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(CG_BUYING_ADDPOINT_KEY).noargs();    &#125;&#125;</code></pre></div><h4 id="3-3-2-定义消息监听类"><a href="#3-3-2-定义消息监听类" class="headerlink" title="3.3.2 定义消息监听类"></a>3.3.2 定义消息监听类</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddPointListener</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitMQConfig.CG_BUYING_ADDPOINT)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String message)</span></span>&#123;        Task task = JSON.parseObject(message, Task<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span> || StringUtils.isEmpty(task.getRequestBody()))&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//判断redis中是否存在内容</span>        Object value = redisTemplate.boundValueOps(task.getId()).get();        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//更新用户积分</span>        <span class="hljs-keyword">int</span> result = userService.updateUserPoints(task);        <span class="hljs-keyword">if</span> (result&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-comment">//返回通知</span>rabbitTemplate.convertAndSend(RabbitMQConfig.EX_BUYING_ADDPOINTURSE,RabbitMQConfig.CG_BUYING_FINISHADDPOINT_KEY,JSON.toJSONString(task));    &#125;&#125;</code></pre></div><h4 id="3-3-3-定义修改用户积分实现"><a href="#3-3-3-定义修改用户积分实现" class="headerlink" title="3.3.3 定义修改用户积分实现"></a>3.3.3 定义修改用户积分实现</h4><p>实现思路：</p><p>1）判断当前订单是否操作过</p><p>2）将任务存入redis</p><p>3）修改用户积分</p><p>4）添加积分日志表记录</p><p>5）删除redis中记录</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> PointLogMapper pointLogMapper;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改用户积分</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-meta">@Transactional</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">updateUserPoints</span><span class="hljs-params">(Task task)</span> </span>&#123;        Map info = JSON.parseObject(task.getRequestBody(), Map<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        String userName = info.get(<span class="hljs-string">"userName"</span>).toString();        String orderId = info.get(<span class="hljs-string">"orderId"</span>).toString();        <span class="hljs-keyword">int</span> point = (<span class="hljs-keyword">int</span>) info.get(<span class="hljs-string">"point"</span>);        <span class="hljs-comment">//判断当前订单是否操作过</span>        PointLog pointLog = pointLogMapper.findLogInfoByOrderId(orderId);        <span class="hljs-keyword">if</span> (pointLog != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        &#125;        <span class="hljs-comment">//将任务存入redis</span>        redisTemplate.boundValueOps(task.getId()).set(<span class="hljs-string">"exist"</span>,<span class="hljs-number">1</span>,TimeUnit.MINUTES);        <span class="hljs-comment">//修改用户积分</span>        <span class="hljs-keyword">int</span> result = userMapper.updateUserPoint(userName, point);        <span class="hljs-keyword">if</span> (result&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-comment">//添加积分日志表记录</span>        pointLog = <span class="hljs-keyword">new</span> PointLog();        pointLog.setOrderId(orderId);        pointLog.setPoint(point);        pointLog.setUserId(userName);        result = pointLogMapper.insertSelective(pointLog);        <span class="hljs-keyword">if</span> (result&lt;=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">return</span> result;        &#125;        <span class="hljs-comment">//删除redis中的记录</span>        redisTemplate.delete(task.getId());        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;</code></pre></div><h4 id="3-3-4-定义根据订单id查询积分日志表"><a href="#3-3-4-定义根据订单id查询积分日志表" class="headerlink" title="3.3.4 定义根据订单id查询积分日志表"></a>3.3.4 定义根据订单id查询积分日志表</h4><p>定义PointLogMapper，实现根据订单id查询</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PointLogMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">PointLog</span>&gt; </span>&#123;    <span class="hljs-meta">@Select</span>(<span class="hljs-string">"select * from tb_point_log where order_id=#&#123;orderId&#125;"</span>)    <span class="hljs-function">PointLog <span class="hljs-title">findLogInfoByOrderId</span><span class="hljs-params">(@Param(<span class="hljs-string">"orderId"</span>)</span> String orderId)</span>;&#125;</code></pre></div><h3 id="3-4-订单服务删除原任务"><a href="#3-4-订单服务删除原任务" class="headerlink" title="3.4 订单服务删除原任务"></a>3.4 订单服务删除原任务</h3><h4 id="3-4-1-定义监听类"><a href="#3-4-1-定义监听类" class="headerlink" title="3.4.1 定义监听类"></a>3.4.1 定义监听类</h4><p>在订单服务中定义监听类，用于监听队列，如果队列中有消息，则删除原任务防止消息重复发送，并对任务信息进行记录</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelTaskListener</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TaskService taskService;    <span class="hljs-meta">@RabbitListener</span>(queues = RabbitMQConfig.CG_BUYING_FINISHADDPOINT)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receiveMessage</span><span class="hljs-params">(String message)</span></span>&#123;        Task task = JSON.parseObject(message, Task<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        taskService.delTask(task);    &#125;&#125;</code></pre></div><h4 id="3-4-2-定义任务service"><a href="#3-4-2-定义任务service" class="headerlink" title="3.4.2 定义任务service"></a>3.4.2 定义任务service</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TaskService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delTask</span><span class="hljs-params">(Task task)</span></span>;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-meta">@Transactional</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TaskMapper taskMapper;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> TaskHisMapper taskHisMapper;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delTask</span><span class="hljs-params">(Task task)</span> </span>&#123;        <span class="hljs-comment">//1. 设置删除时间</span>        task.setDeleteTime(<span class="hljs-keyword">new</span> Date());        Long id = task.getId();        task.setId(<span class="hljs-keyword">null</span>);        <span class="hljs-comment">//bean复制</span>        TaskHis taskHis = <span class="hljs-keyword">new</span> TaskHis();        BeanUtils.copyProperties(task,taskHis);       <span class="hljs-comment">//记录任务信息</span>        taskHisMapper.insertSelective(taskHis);        <span class="hljs-comment">//删除原任务</span>        task.setId(id);        taskMapper.deleteByPrimaryKey(task);    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Euraka和zookeeper的区别(ACP)</title>
    <link href="/2020/07/08/Euraka%E5%92%8Czookeeper%E7%9A%84%E5%8C%BA%E5%88%AB-ACP/"/>
    <url>/2020/07/08/Euraka%E5%92%8Czookeeper%E7%9A%84%E5%8C%BA%E5%88%AB-ACP/</url>
    
    <content type="html"><![CDATA[<h1 id="zk和eureka的区别（CAP原则）"><a href="#zk和eureka的区别（CAP原则）" class="headerlink" title="zk和eureka的区别（CAP原则）"></a>zk和eureka的区别（CAP原则）</h1><h1 id="作为服务注册中心，Eureka比Zookeeper好在哪里"><a href="#作为服务注册中心，Eureka比Zookeeper好在哪里" class="headerlink" title="作为服务注册中心，Eureka比Zookeeper好在哪里"></a>作为服务注册中心，Eureka比Zookeeper好在哪里</h1><p>著名的CAP理论指出，<code>一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性)</code>。由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。在此Zookeeper保证的是CP, 而Eureka则是AP。</p><h2 id="1-Zookeeper保证CP"><a href="#1-Zookeeper保证CP" class="headerlink" title="1 Zookeeper保证CP"></a>1 Zookeeper保证CP</h2><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是<code>zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举</code>。问题在于，<code>选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。</code>在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><h1 id="zookeeper原理"><a href="#zookeeper原理" class="headerlink" title="zookeeper原理"></a>zookeeper原理</h1><div class="hljs"><pre><code class="hljs angelscript">zookeeper也可以作为注册中心，用于服务治理（zookeeper还有其他用途，例如：分布式事务锁等）   每启动一个微服务，就会去zk中注册一个临时子节点，例如：<span class="hljs-number">5</span>台订单服务，<span class="hljs-number">4</span>台商品服务（<span class="hljs-number">5</span>台订单服务在zk中的订单目录下创建的<span class="hljs-number">5</span>个临时节点）（<span class="hljs-number">4</span>台商品服务在zk中的商品目录下创建的<span class="hljs-number">4</span>个临时接点）每当有一个服务down机，由于是临时接点，此节点会立即被删除，并通知订阅该服务的微服务更新服务列表（zk上有watch，每当有节点更新，都会通知订阅该服务的微服务更新服务列表）每当有一个新的微服务注册进来，就会在对应的目录下创建临时子节点，并通知订阅该服务的微服务更新服务列表（zk上有watch，每当有节点更新，都会通知订阅该服务的微服务更新服务列表）每个微服务<span class="hljs-number">30</span>s向zk获取新的服务列表</code></pre></div><h2 id="2-Eureka保证AP"><a href="#2-Eureka保证AP" class="headerlink" title="2 Eureka保证AP"></a>2 Eureka保证AP</h2><ol><li><p>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 </p></li><li><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) </p></li><li><p>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</p></li></ol><p>因此，<code>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</code></p><h1 id="eureka原理"><a href="#eureka原理" class="headerlink" title="eureka原理"></a>eureka原理</h1><div class="hljs"><pre><code class="hljs html">每一个微服务中都有eureka client，用于服务的注册于发现 （服务的注册：把自己注册到eureka server） （服务的发现：从eureka server获取自己需要的服务列表） 每一个微服务启动的时候，都需要去eureka server注册 当A服务需要调用B服务时，需要从eureka服务端获取B服务的服务列表，然后把列表缓存到本地，然后根据ribbon的客户端负载均衡规则，从服务列表中取到一个B服务，然后去调用此B服务 当A服务下次再此调用B服务时，如果发现本地已经存储了B的服务列表，就不需要再从eureka服务端获取B服务列表，直接根据ribbon的客户端负载均衡规则，从服务列表中取到一个B服务，然后去调用B服务 微服务，默认每30秒，就会从eureka服务端获取一次最新的服务列表 如果某台微服务down机，或者添加了几台机器， 此时eureka server会通知订阅他的客户端，并让客户端更新服务列表， 而且还会通知其他eureka server更新此信息 心跳检测，微服务每30秒向eureka server发送心跳， eureka server若90s之内都没有收到某个客户端的心跳，则认为此服务出了问题， 会从注册的服务列表中将其删除，并通知订阅它的客户端更新服务列表， 而且还会通知其他eureka server更新此信息 eureka server保护机制，通过打卡开关，可以让eureka server处于保护状态，主要是用于某eureka server由于网络或其他原因，导致接收不到其他微服务的心跳，此时不能盲目的将其他微服务从服务列表中删除。 具体规则：如果一段时间内，85%的服务都没有发送心跳，则此server进入保护状态，此状态下，可以正常接受注册，可以正常提供查询服务，但是不与其他server同步信息，也不会通知订阅它的客户端，这样就不会误杀其他微服务</code></pre></div><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p><code>Eureka作为单纯的服务注册中心来说要比zookeeper更加“专业”，因为注册服务更重要的是可用性，我们可以接受短期内达不到一致性的状况</code>。不过Eureka目前1.X版本的实现是基于servlet的java web应用，它的极限性能肯定会受到影响。期待正在开发之中的2.X版本能够从servlet中独立出来成为单独可部署执行的服务。</p>]]></content>
    
    
    <categories>
      
      <category>SpringCloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JWT微服务鉴权</title>
    <link href="/2020/06/27/JWT%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83/"/>
    <url>/2020/06/27/JWT%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%89%B4%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<h1 id="1、-什么是微服务鉴权"><a href="#1、-什么是微服务鉴权" class="headerlink" title="1、 什么是微服务鉴权"></a>1、 什么是微服务鉴权</h1><p>鉴权就是来校验用户是否有访问权限。gateway是微服务的入口，我们就在gateway进行鉴权操作。</p><h2 id="1-2-JWT"><a href="#1-2-JWT" class="headerlink" title="1.2 JWT"></a>1.2 JWT</h2><p>JSON WEB Token 是可逆的加密的操作，是一种数据加密传输的规范。</p><p><strong>JWT组成</strong></p><ul><li>头信息</li></ul><ul><li><p>载荷</p><p>存放有效信息的地方。</p></li><li><p>签名</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring&amp;SpringBoot面试题总结</title>
    <link href="/2020/06/20/Spring-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/06/20/Spring-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="1、-Component-和-Bean的区别？"><a href="#1、-Component-和-Bean的区别？" class="headerlink" title="1、@Component 和@ Bean的区别？"></a>1、@Component 和@ Bean的区别？</h3><p>@Component是贴在类上面的，自动检测和使用类路径扫描将bean添加到容器中。</p><p>@Bean的使用在方法上的，是将方法的返回值作为bean 注入到容器中，常和@Configuration结合使用。</p><h3 id="2、几种事务不生效的问题"><a href="#2、几种事务不生效的问题" class="headerlink" title="2、几种事务不生效的问题"></a>2、几种事务不生效的问题</h3><p><strong>情况1</strong>：确定创建的mysql数据库表的引擎是InnoDB,MyISAM不支持事务</p><p><strong>情况2：@Transactional</strong>注解到protected, private 方法上，事务不生效，也不会报错。</p><p><strong>情况3：</strong>在业务层手动捕捉并处理异常，未向上抛出，事务不生效。</p><p><strong>情况4：</strong>不要写到接口上，spring采用aop 针对具体实现类做的动态代理。</p><p><strong>情况5</strong>：Spring的事务传播策略在内部方法调用时将不起作用，事务注解加到</p><p>要调用方法上。</p><p><strong>情况6：</strong>遇到非检测异常时，事务不开启，也无法回滚。以为Spirng的默认的事务规则是遇到运行异常（RuntimeException）和程序错误（Error）才会回滚。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>question</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ工作模式——简单工作模式</title>
    <link href="/2020/06/12/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/12/RabbitMQ%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.qfeng.online/imgs/RabbitMQ/rabbitmq%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" alt></p><h1 id="RabbitMQ工作模式（一）HelloWorld"><a href="#RabbitMQ工作模式（一）HelloWorld" class="headerlink" title="RabbitMQ工作模式（一）HelloWorld"></a>RabbitMQ工作模式（一）HelloWorld</h1><p><img src="https://www.qfeng.online/imgs/RabbitMQ/RabbitMQ%E7%AE%80%E5%8D%95%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.jpg" srcset="/img/loading.gif" alt></p><div class="note note-primary">            <p>简单工作模式：生产者将消息发送到消息队列queue，消费者从该队列接受消息</p>          </div><blockquote><p>环境准备和依赖导入pom.xml文件中导入RabbitMQ的java客户端依赖<code>amqp-client</code>,配置编译插件</p></blockquote><p>pom.xml</p><div class="hljs"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;&lt;project xmlns=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>         xmlns:xsi=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>         xsi:schemaLocation=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.yang&lt;/groupId&gt;    &lt;artifactId&gt;rabiitmq-server&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!--导入rabbitmq  java客户端依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;            &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;            &lt;version&gt;5.9.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre></div><blockquote><p>Provider消息提供者，创建一个消息服务者的maven项目,pom.xnl中就导入上面文件中显示的。创建Provider类，用来向消息队列发送消息。</p></blockquote><p>Rabbitmq_Provider.java</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.provider;<span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/12 14:50</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbitmq_Provider</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;        <span class="hljs-comment">//1.创建Connection工厂</span>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//2.设置参数</span>        connectionFactory.setHost(<span class="hljs-string">"121.199.17.199"</span>);        connectionFactory.setPort(<span class="hljs-number">5672</span>);        connectionFactory.setVirtualHost(<span class="hljs-string">"/yang"</span>);  <span class="hljs-comment">//设置虚拟机，默认值是/</span>        connectionFactory.setUsername(<span class="hljs-string">"yang"</span>);        connectionFactory.setPassword(<span class="hljs-string">"yang"</span>);        <span class="hljs-comment">//3..创建connection</span>        Connection connection = connectionFactory.newConnection();        <span class="hljs-comment">//4.创建channel</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//创建exchange,由于是简单模式，不需要创建exchange，使用默认的即可</span>        <span class="hljs-comment">//5.创建queue</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *       Declare a queue</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> queue the name of the queue</span><span class="hljs-comment">         *              队列的名字</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</span><span class="hljs-comment">         *              是否持久化，当mq重启后数据还在</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</span><span class="hljs-comment">         *              如果声明独占队列(仅限于此连接)，只能有一个消费者监听此队列</span><span class="hljs-comment">         *              当connection关闭时是否自动删除</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span><span class="hljs-comment">         *             如果我们声明一个自动删除队列，自动删除为真(当它不再使用时，服务器将删除它)</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> arguments other properties (construction arguments) for the queue</span><span class="hljs-comment">         *              队列的其他属性(构造参数)</span><span class="hljs-comment">         *       <span class="hljs-doctag">@return</span> a declaration-confirm method to indicate the queue was successfully declared</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        channel.queueDeclare(<span class="hljs-string">"test-rabbitmq-provider"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">//6.发送消息</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> exchange the exchange to publish the message to</span><span class="hljs-comment">         *       交换机的名称，简单模式下使用的是默认的  “”</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> routingKey the routing key</span><span class="hljs-comment">         *       路由名称，默认的交换机这里需要和queue的名字一直</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> mandatory true if the 'mandatory' flag is to be set</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> immediate true if the 'immediate' flag is to be</span><span class="hljs-comment">         *       set. Note that the RabbitMQ server does not support this flag.</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> props other properties for the message - routing headers etc</span><span class="hljs-comment">         *       匹配信息</span><span class="hljs-comment">         *       <span class="hljs-doctag">@param</span> body the message body</span><span class="hljs-comment">         *       发送的数据</span><span class="hljs-comment">         *       <span class="hljs-doctag">@throws</span> java.io.IOException if an error is encountered</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        String message = <span class="hljs-string">"hello rabbitmq ...."</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;            channel.basicPublish(<span class="hljs-string">""</span>,<span class="hljs-string">"test-rabbitmq-provider"</span>,<span class="hljs-keyword">null</span>,message.getBytes());                    &#125;        <span class="hljs-comment">//释放资源</span>        channel.close();        connection.close();    &#125;&#125;</code></pre></div><p><strong>小结：</strong></p><ul><li>创建Connection工厂  <code>ConnectionFactory  factory =  new ConnectionFactory( );</code></li></ul><ul><li>设置Connection参数 <code>factory.setHosts (&quot;服务器名称/ip&quot;)</code> 、<code>factory.setPort(&quot;rabbitmq服务端口号&quot;)</code>、<code>connectionFactory.setVirtualHost(&quot;/yang&quot;); 设置虚拟机，默认值是/</code>、设置用户名<code>factory.setUsername(&quot;yang&quot;)</code>、设置密码<code>factory.setPassword(&quot;yang&quot;)</code></li></ul><ul><li>创建connection对象 <code>factory.newConnection()</code></li></ul><ul><li>创建channel对象<code>connection.createChannle()</code>,由于是简单工作模式，不需要创建exchange交换器，实际上使用的是默认的。</li></ul><ul><li>创建queue对象并声明queue的一些信息，缓存消息channle.queueDeclare（”消息队列名字”，durable 是否持久化，exclusive，autoDelete 是否自动删除，arguments其他属性参数）</li><li>发送消息 channel.basicPublish(exchange交换机的名字,routingKey 路由的名字，properties一些配置信息，byte[]发送的消息) <code>交换机的名字没写，“”使用默认的，routingKey和queue的名字对应</code></li></ul><blockquote><p>Consumer消费者，从queue中拿出消息</p></blockquote><p>Rabbitmq_Consumer.java</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.consumer;<span class="hljs-keyword">import</span> com.rabbitmq.client.*;<span class="hljs-keyword">import</span> com.rabbitmq.client.impl.AMQImpl;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/12 15:59</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rabbitmq_Consumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;        <span class="hljs-comment">//1.创建连接工厂</span>        ConnectionFactory factory = <span class="hljs-keyword">new</span> ConnectionFactory();        <span class="hljs-comment">//2.设置参数</span>        factory.setHost(<span class="hljs-string">"121.199.17.199"</span>);        factory.setPort(<span class="hljs-number">5672</span>);        factory.setVirtualHost(<span class="hljs-string">"/yang"</span>);  <span class="hljs-comment">//设置虚拟机，默认值是/</span>        factory.setUsername(<span class="hljs-string">"yang"</span>);        factory.setPassword(<span class="hljs-string">"yang"</span>);        <span class="hljs-comment">//创建connection</span>        Connection connection = factory.newConnection();        <span class="hljs-comment">//创建channel</span>        Channel channel = connection.createChannel();        <span class="hljs-comment">//获取queue</span>        channel.queueDeclare(<span class="hljs-string">"test-rabbitmq-provider"</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">null</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * queue： 队列名字</span><span class="hljs-comment">         * autoAsk: 是否自动确认</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        Consumer consumer = <span class="hljs-keyword">new</span> DefaultConsumer(channel)&#123;            <span class="hljs-comment">//回调方法，当确认收到消息后会自动执行该方法</span>            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;                <span class="hljs-comment">/**</span><span class="hljs-comment">                 * consumerTag 消息的标识</span><span class="hljs-comment">                 * envelope 获取一些信息</span><span class="hljs-comment">                 * properties 配置信息</span><span class="hljs-comment">                 * body 具体信息</span><span class="hljs-comment">                 */</span>                System.out.println(<span class="hljs-string">"consumerTag:"</span> + consumerTag);                System.out.println(<span class="hljs-string">"envelope:"</span> + envelope.getExchange());                System.out.println(<span class="hljs-string">"envelope:"</span> + envelope.getRoutingKey());                System.out.println(<span class="hljs-string">"properties:"</span> + properties);                System.out.println(<span class="hljs-string">"消息:"</span> + <span class="hljs-keyword">new</span> String(body));                System.out.println(<span class="hljs-string">"-----------------"</span>);            &#125;        &#125;;        <span class="hljs-comment">//消费消息</span>        channel.basicConsume(<span class="hljs-string">"test-rabbitmq-provider"</span>,<span class="hljs-keyword">true</span>,consumer);    &#125;&#125;</code></pre></div><p><strong>小结</strong></p><p>消费的方法调用基本和消息提供者的基本相似，注意当确认收到消息后要执行回调方法 <code>handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)</code></p><p>消费消息</p><p>channel.basicConsume(“queue名字”，autoAsk是否自动确认 ，consumer回调函数)</p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot整合RabbitMQ</title>
    <link href="/2020/06/12/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/"/>
    <url>/2020/06/12/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h1><div class="note note-primary">            <p>创建两个springboot工程，一个充当消息的提供者provider,另一个监听消息消费消息consumer</p>          </div><h2 id="1-创建生产者Provider"><a href="#1-创建生产者Provider" class="headerlink" title="1. 创建生产者Provider"></a>1. 创建生产者Provider</h2><p><strong>1.1  创建SpringBoot的项目</strong></p><p><strong>1.2 pom文件中导入spring-boot-starter-amqp启动器</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入rabbitmq依赖--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>完整依赖</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.yang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-rabbitmq<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--导入rabbitmq依赖--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p><strong>1.3 在application.yml中配置rabbitmq的基本属性</strong></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 配置rabbitmq的基本参数</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">121.199</span><span class="hljs-string">.xx.xxx</span>   <span class="hljs-comment"># 写自己rabbitmq运行的服务器ip</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/yang</span></code></pre></div><p><strong>1.4 编写配置类</strong></p><div class="note note-primary">            <p><strong>使用@Coonfiguration标注这个类是一个配置类</strong></p><p>在配置类中向容器中注入交换机组件Exchange，队列组件Queue、明确队列和交换机的绑定bind</p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.springbootrabbitmq.config;<span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/16 20:47</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootRabbitMQ</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String EXCHANGE_NAME = <span class="hljs-string">"springboot-rabbitmq-exchange"</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String QUEUE_NAME= <span class="hljs-string">"springboot-rabbitmq-queue"</span>;    <span class="hljs-comment">//注入交换机组件</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bootExchange"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Exchange <span class="hljs-title">bootExchange</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//构建交换机,指定交换机类型和名字</span>        <span class="hljs-keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="hljs-keyword">true</span>).build();    &#125;    <span class="hljs-comment">//注入队列</span>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">"bootQueue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">bootQueue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();    &#125;    <span class="hljs-comment">//交换机和队列绑定</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">bindQueueAndExchange</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">"bootQueue"</span>)</span> Queue queue, @<span class="hljs-title">Qualifier</span><span class="hljs-params">(<span class="hljs-string">"bootExchange"</span>)</span> Exchange exchange)</span>&#123;        <span class="hljs-comment">//指定哪个队列，哪个交换机，什么routingKey，参数啥的</span>        <span class="hljs-keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="hljs-string">"boot.#"</span>).noargs();    &#125;&#125;</code></pre></div><blockquote><p><strong>小结：</strong></p><p>通常将<code>队列名和交换机名</code>，定义成<code>静态常量</code>方便在其他类中使用</p><p>创建交换机的时候就制定了交换机的类型<code>ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(true).build();</code></p><p>构建队列<code>QueueBuilder.durable(QUEUE_NAME).build();</code></p><p>绑定队列和交换机</p><p> <code>BindingBuilder.bind(queue).to(exchange).with(&quot;boot.#&quot;).noargs();</code></p></blockquote><h2 id="2-创建消费者Consumer"><a href="#2-创建消费者Consumer" class="headerlink" title="2.创建消费者Consumer"></a>2.创建消费者Consumer</h2><p> <strong>2.1  创建SpringBoot的项目</strong></p><p><strong>2.2 pom文件中导入spring-boot-starter-amqp启动器</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.yang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-rabbitmq-consumer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-rabbitmq-consumer<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.amqp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-rabbit-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><p><strong>2.3 在application.yml中配置rabbitmq的基本属性</strong></p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 配置rabbitmq的基本参数</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">rabbitmq:</span>    <span class="hljs-attr">host:</span> <span class="hljs-number">121.199</span><span class="hljs-number">.17</span><span class="hljs-number">.199</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">yang</span>    <span class="hljs-attr">virtual-host:</span> <span class="hljs-string">/yang</span></code></pre></div><p><strong>2.4 编写消息监听器</strong></p><div class="note note-primary">            <p><code>@RabbitListener（queues=&quot;&quot;） 监听queue的方法</code></p><p><code>Message 包含了所有的信息包括队列信息，以及配置的属性，和消息体</code></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.springbootrabbitmqconsumer.consumer;<span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/16 21:22</span><span class="hljs-comment"> * 编写消息监听器</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span> </span>&#123;    <span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">"springboot-rabbitmq-queue"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ListenerQueue</span><span class="hljs-params">(Message message)</span></span>&#123;        System.out.println(message);        System.out.println(<span class="hljs-keyword">new</span> String(message.getBody()));    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ基础</title>
    <link href="/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ的基本概念"><a href="#RabbitMQ的基本概念" class="headerlink" title="RabbitMQ的基本概念"></a>RabbitMQ的基本概念</h1><h2 id="1-1-MQ概述"><a href="#1-1-MQ概述" class="headerlink" title="1.1 MQ概述"></a>1.1 MQ概述</h2><p>MQ全称Message Queue (消息队列)，是在消息的传输过程中<code>保存消息的容器</code>。多用于分布式系统之间进行通信。</p><div class="note note-primary">            <p>分布式系统中通信两种方式：直接远程调用和借助 第三方完成间接通信</p>          </div><p><img src="/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/C:%5CUsers%5Cwangy%5CDesktop%5Cmq%E6%A6%82%E5%BF%B5.jpg" srcset="/img/loading.gif" alt></p><h2 id="1-2-MQ的优劣势（理解）"><a href="#1-2-MQ的优劣势（理解）" class="headerlink" title="1.2 MQ的优劣势（理解）"></a>1.2 MQ的优劣势（理解）</h2><p><strong>MQ的优势</strong></p><ul><li>应用解耦： 提高系统容错性和可维护性</li><li>异步提速：提升用户体验和系统的吞吐量</li><li>削峰填谷：提高系统稳定性</li></ul><p><strong>MQ的劣势</strong></p><ul><li><p>系统的可用性降低</p><p>系统引入的外部依赖越多，系统的稳定性就越差。要保证每一部分都是完好的。一旦MQ宕机，就会对业务造成影响。就要考虑保证MQ的高可用？</p></li><li><p>系统的复杂性提高</p><p>要保证消息没有被重复消费？处理消息丢失情况？保证消息传递的顺序行？</p></li><li><p>一致性问题</p><p>A系统处理完业务，通过 MQ 给 B 、 C 、 D 三个系统发消息数据，如果 B 系统、 C 系统处理成功， D 系统处理失败。如何保证消息数据处理的一性？</p></li></ul><h2 id="1-3常见的MQ产品（了解）"><a href="#1-3常见的MQ产品（了解）" class="headerlink" title="1.3常见的MQ产品（了解）"></a>1.3常见的MQ产品（了解）</h2><p><img src="/2020/06/12/RabbitMQ%E5%9F%BA%E7%A1%80/C:%5CUsers%5Cwangy%5CDesktop%5C%E5%B8%B8%E8%A7%81MQ.jpg" srcset="/img/loading.gif" alt></p><h2 id="1-4-RabbitMQ简介"><a href="#1-4-RabbitMQ简介" class="headerlink" title="1.4 RabbitMQ简介"></a>1.4 RabbitMQ简介</h2><p><strong>小结</strong></p><blockquote><p>1、 RabbitMQ是基于AMQP协议使用Erlang语言开发的一款消息队列</p><p>2、RabbitMQ提供了6种工作模式</p><p>3、AMQP是协议，类比HTTP</p><p>4、JMS是API规范接口，类比JDBC</p></blockquote><h1 id="RabbitMQ的安装和配置"><a href="#RabbitMQ的安装和配置" class="headerlink" title="RabbitMQ的安装和配置"></a>RabbitMQ的安装和配置</h1><p>1、点击下载安装</p><p>2、点击Docker 镜像</p><p>3、找到最新的带界面的安装</p><p>二、拉取镜像<br>docker pull rabbitmq:3.8.0-management</p><p>三、运行镜像  4b23cfb64730  （5672是程序的端口，15672是web访问的端口）<br>docker run -d –name my-rabbitmq-management -p 5672:5672 -p 15672:15672 –hostname my-rabbitmq 4b23cfb64730<br>四、防火墙打开15672端口<br>1、放开端口</p><p>firewall-cmd –add-port=15672/tcp –permanent<br>2、重启防火墙</p><p>firewall-cmd –reload<br>五、到阿里云的安全策略组，打开15672端口</p><p>六、通过阿里云服务器的  ip:15672 就可以访问了！起始账号密码都是：guest</p><p>七、出于安全考虑，请及时修改账号密码哦！<br>1、进入docker 的 RabbitMQ 容器中</p><p>docker exec -it 647caf5c20c6 bash<br>2、查看用户</p><p>rabbitmqctl list_users<br>3、修改密码</p><p>rabbitmqctl change_password userName newPassword<br>4、如果不想要guest的账号也可以新增账号</p><p> rabbitmqctl add_user userName newPassword<br>5、看guest不爽，你还可以delete它</p><p>rabbitmqctl delete_user guest<br>6、最后别忘了给自己添加的账号增加超级管理员权限</p><p>rabbitmqctl set_user_tags userName administrator</p><h1 id="RabbitMQ快速入门"><a href="#RabbitMQ快速入门" class="headerlink" title="RabbitMQ快速入门"></a>RabbitMQ快速入门</h1><h2 id="3-1-入门程序"><a href="#3-1-入门程序" class="headerlink" title="3.1 入门程序"></a>3.1 入门程序</h2><blockquote><p>需求：使用简单模式完成消息传递</p></blockquote><h2 id="3-2-工作模式"><a href="#3-2-工作模式" class="headerlink" title="3.2 工作模式"></a>3.2 工作模式</h2><ul><li>简单工作模式</li></ul><p>​    </p><ul><li>work Queues 工作模式</li></ul><div class="hljs"><pre><code>* Pub/Sub订阅模式</code></pre></div><ul><li>Routing 路由模式</li></ul><ul><li>Topics 通配符模式</li></ul><h1 id="Spring-整合-RabbitMQ"><a href="#Spring-整合-RabbitMQ" class="headerlink" title="Spring 整合 RabbitMQ"></a>Spring 整合 RabbitMQ</h1><ul><li>生产者</li></ul><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis关闭保护模式</title>
    <link href="/2020/06/10/Redis%E5%85%B3%E9%97%AD%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/10/Redis%E5%85%B3%E9%97%AD%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>redis启动模式是在保护模式下的，保护模式下只支持回环地址连接服务。也就是只有和redis在同一个服务上，可以连接到redis。外部连接需要关闭保护模式。</p><blockquote><p><strong>关闭保护模式操作</strong></p></blockquote><p><strong>1、进入redis的安装目录在conf下找到<code>redis.conf</code>配置文件 vi redis.conf 注释<code>bind 127.0.0.1</code>这一行</strong></p><p><strong>2、启动redis 登入客户端 执行下面命令</strong></p><p> <code>config set protected-mode &quot;no&quot;</code></p><blockquote><p>小结： springboot整合redis</p><ol><li>导入依赖</li></ol><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol start="2"><li>进行相关配置（spring.redis.host   spring.redis.port  …）</li><li>注入RedisTemplate对象，使用相关的api操作</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker深入</title>
    <link href="/2020/06/09/Docker%E6%B7%B1%E5%85%A5/"/>
    <url>/2020/06/09/Docker%E6%B7%B1%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h2><h3 id="1、docker理念回顾"><a href="#1、docker理念回顾" class="headerlink" title="1、docker理念回顾"></a>1、docker理念回顾</h3><p>将应用和环境打包成一个镜像！</p><p><strong>问题：</strong> 如果数据都在容器中，那么我们容器删除了，数据就丢失了！比如MySql容器删除了，那么数据就丢失了。</p><p>需求:    数据可持久化（MySql数据可以存储到本地！）</p><p>因此容器之间可以有一个数据共享技术！Docker容器产生的数据，同步到本地！</p><p><code>这就是卷技术！目录的挂载,将我们容器的目录，挂载到Linux上面</code></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%8D%B7%E6%8A%80%E6%9C%AF.jpg" srcset="/img/loading.gif" alt></p><p><strong>总结容器数据卷就是：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><h3 id="1、数据卷的挂载"><a href="#1、数据卷的挂载" class="headerlink" title="1、数据卷的挂载"></a>1、数据卷的挂载</h3><blockquote><p><strong>方式一：使用命令来挂载    -v</strong>  问题：已经在运行的容器可以实现数据卷挂载吗？</p><p><strong>docker run -it -v /home/ceshi:/home centos</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 挂载 将宿主机的目录和容器的目录映射起来</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it -v /home/ceshi:/home centos</code></pre></div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 2. 查看是否挂载成功</span><span class="hljs-meta">#</span><span class="bash"> docker inspect 容器的id</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker inspect 6ff6055f21fb</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%8C%82%E8%BD%BD%E6%88%90%E5%8A%9F.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 3. 测试容器中的数据是否可以同步到宿主机</span><span class="hljs-meta">#</span><span class="bash"> 在容器中创建文件，测试是否同步到容器中</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%AE%B9%E5%99%A8%E5%88%B0%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%B5%8B%E8%AF%95.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 4. 停止容器后再重启容器，查看数据是否同步</span><span class="hljs-meta">#</span><span class="bash"> docker stop 容器id  或者 <span class="hljs-built_in">exit</span> 退出容器并停止容器</span><span class="hljs-meta">#</span><span class="bash"> docker start 容器id</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%AE%BF%E4%B8%BB%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E5%AE%B9%E5%99%A8%E4%B8%AD.jpg" srcset="/img/loading.gif" alt></p><h3 id="2、实践MySQL数据同步"><a href="#2、实践MySQL数据同步" class="headerlink" title="2、实践MySQL数据同步"></a>2、实践MySQL数据同步</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. 获取mysql镜像</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 2. 运行容器时数据挂载</span><span class="hljs-meta">#</span><span class="bash"> mysql 启动时设置密码</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 3. 测试连接是否成功</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%B5%8B%E8%AF%95mysql%E5%AE%B9%E5%99%A8.jpg" srcset="/img/loading.gif" alt></p><h3 id="3、具名挂载和匿名挂载"><a href="#3、具名挂载和匿名挂载" class="headerlink" title="3、具名挂载和匿名挂载"></a>3、具名挂载和匿名挂载</h3><div class="note note-primary">            <p>匿名挂载 </p><p>-v 容器内的路径!</p><p>docker run -d -P –name  nginx01 -v /etc/nginx nginx</p><p>这种就是匿名挂载，我们只在 -v 后面写了容器内的路径，没有写容器外的路径</p>          </div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 匿名挂载</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name nginx01 -v /etc/nginx nginx</code></pre></div><div class="note note-primary">            <p>docker  volume 对数据卷执行操作</p><p>Commands:<br>  create      Create a volume<br>  inspect     Display detailed information on one or more volumes<br>  ls          List volumes<br>  prune       Remove all unused local volumes<br>  rm          Remove one or more volumes</p>          </div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看所有的volume 情况</span>docker volume ls</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%8C%BF%E5%90%8D%E5%8D%B7%E6%8C%82%E8%BD%BD.jpg" srcset="/img/loading.gif" alt></p><div class="note note-primary">            <p><strong>-v 卷名：容器名</strong></p><p><code>docker volume inspect</code> [卷名]  来查看下这个卷的信息</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/volume-inspect.jpg" srcset="/img/loading.gif" alt></p><p>所有容器中卷在没有指定目录的情况下，都在<code>/var/lib/docker/volumes/XXX/_data</code></p><p>通过具名挂载我们可以方便得找到这个卷</p><p><strong>如何去区别是具名挂载还是匿名挂载，还是指定路径挂载</strong></p><div class="hljs"><pre><code class="hljs shell">-v 容器内路径   # 匿名挂载-v 卷名:容器内路径 # 具名挂载-v /宿主机的目录：容器内的目录  #指定路径挂载</code></pre></div><p><strong>扩展：</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过 -v 容器内路径：ro  rw 来改变读写权限</span>ro readonlly # 只读rw  readwrite # 可读可写<span class="hljs-meta">#</span><span class="bash"> 一旦设置了权限，那么容器中挂载出来的内容就有了限制，</span>docker run -d -P --name nginx01 -v /etc/nginx:ro nginx  # 在容器中只能读docker run -d -P --name nginx01 -v /etc/nginx:rw nginx  # 在容器中可读可写</code></pre></div><h3 id="4、初识Dockerfile"><a href="#4、初识Dockerfile" class="headerlink" title="4、初识Dockerfile"></a>4、初识Dockerfile</h3><p>Dockerfile 就是用来构建docker镜像的构建文件！命令脚本！</p><div class="note note-primary">            <p>方式二：通过Dockerfile来生成镜像</p>          </div><p><strong>编写dockerfile脚本文件</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过这个脚本可以生成镜像（指令都是大写）</span><span class="hljs-meta">#</span><span class="bash"> 这里的每条命令就是镜像的一层</span>FROM centosVOLUME ["volume01","volume02"]CMD echo "---end---"CMD /bin/bash</code></pre></div><p><strong>通过dockerfile脚本文件构建镜像</strong></p><div class="hljs"><pre><code class="hljs shell">docker build -f [dockerfile文件的路径] -t [要生成的目标镜像] .[root@iZbp1baf0xyn152a53kixrZ docker-test-volume]# docker build -f dockerfile -t wangyang/centos .</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/dockerfile%E7%94%9F%E6%88%90%E9%95%9C%E5%83%8F.jpg" srcset="/img/loading.gif" alt></p><p><strong>查看脚本生成的镜像</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8B%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E7%9A%84%E9%95%9C%E5%83%8F.jpg" srcset="/img/loading.gif" alt></p><p><strong>启动我们自己生成的容器</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker01.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker03.jpg" srcset="/img/loading.gif" alt></p><p>这个卷一定和外部的一个目录映射上了。是匿名挂载，在/var/bin/docker/可以找到这两个挂载得卷。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8B%E6%8C%82%E8%BD%BD%E7%9A%84%E9%95%9C%E5%83%8F.jpg" srcset="/img/loading.gif" alt></p><p><strong>在容器中挂载的目录下，新建个文件，测试对应的外部下是否同步了这个文件</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker00.jpg" srcset="/img/loading.gif" alt></p><h3 id="5、数据卷容器"><a href="#5、数据卷容器" class="headerlink" title="5、数据卷容器"></a>5、数据卷容器</h3><div class="note note-primary">            <p>数据卷容器就是个用来给其它容器同步数据的容器，其它容器的文件挂载到这个数据卷容器上，也就是父容器上。</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker04.jpg" srcset="/img/loading.gif" alt></p><p><strong>启动3个容器测试，通过我们刚才自己编写的镜像</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it --name docker01 6661964acee0</code></pre></div><p><strong>将docker02和docker01通过 –volumes-from同步</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it --name docker02 --volumes-from docker01 6661964acee0</code></pre></div><p><strong>在docker01的volume01中新建一个文件，查看dokcer02中是否存在</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker05.jpg" srcset="/img/loading.gif" alt></p><p><strong>再启动一个docker03和docke01同步，并在docke03中创建文件查看docker01中是否存</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it --name docker03 --volumes-from docker01 6661964acee0</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker06.jpg" srcset="/img/loading.gif" alt></p>{% note primary %}**结论：**容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。但是一旦持久化到本地，那么本地的数据不会删除。{% endnote %}<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1>{% note primary %}**dockerfile是用来构建docker镜像的文件！命令参数脚本**构建步骤：1、编写一个dockerfile文件2、docker build 构建成为一个镜像3、docker run 运行镜像4、docker push 发布镜像（DockerHub、阿里云镜像仓库）{% endnote %}<p><code>可以查看官方是怎么做的，模仿官方</code></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker07.jpg" srcset="/img/loading.gif" alt></p><p>很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！</p><h2 id="DockerFile的构建过程"><a href="#DockerFile的构建过程" class="headerlink" title="DockerFile的构建过程"></a>DockerFile的构建过程</h2><p><strong>基础知识</strong></p><ol><li><p>每个保留关键字（指令）都必须是大写</p></li><li><p>执行从上到下顺序执行</p></li><li><p>#表示注释</p></li><li><p>每一个指令都会创建提交一个新的镜像层，并提交。</p></li></ol><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/dockerFile08.jpg" srcset="/img/loading.gif" alt></p><p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p><p>DockerFile:  构建文件，定义了一切的步骤，</p><p>DockerImages：通过DockeFile构建生成的镜像，最终发布和运行的产品，原来是jar,war</p><p>Docker容器：是DockerImages运行起来，提供的服务。</p><h2 id="DockerFile指令"><a href="#DockerFile指令" class="headerlink" title="DockerFile指令"></a>DockerFile指令</h2><p>通过这些指令，自己写一个镜像</p>{% note primary %}`FROM`: 基础镜像，一切从这里开始构建`MAINTAINER`: 指定维护者信息`RUN`:镜像构建时需要运行的命令`ADD`:添加内容`WORKDIR`: 镜像的工作目录`VOLUME`: 挂载的目录`EXPOSE`：爆漏端口配置`CMD` :指定容器启动的时候要运行的命令,只有最后一个会生效，而且可以被替代`ENTRYPOINT` : 指定容器启动的时候要运行的命令,可以追加命令`COPY` :类似ADD，将我们文件拷贝到镜像中`ENV`： 构建时设置环境变量{% endnote %}<p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/dockerFile09%20%281%29.jpg" srcset="/img/loading.gif" alt></p><h2 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h2>{% note primary %}Docker Hub中 99%镜像都是这个基础镜像过来的 `FROM scratch`{% endnote %}<ul><li>编写dockerfile的文件</li></ul><div class="hljs"><pre><code class="hljs shell">FROM centosMAINTAINER wangyang&lt;975594867@qq.com&gt;ENV MYPATH /usr/localWORKDIR $MYPATHRUN yum -y install vimRUN yum -y install net-toolsEXPOSE 80CMD echo $MYPATHCMD echo "---end---"CMD /bin/bash</code></pre></div><ul><li>通过dockerfile文件构建对象(可能下载安装vim 会失败，可以直接注释掉)</li></ul><div class="note note-primary">            <p><code>命令 docker build -f dockerfile文件名 -t  镜像名:[tag]   .</code></p>          </div><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker build -f mydockerfile-centos -t mycentos:0.1 .</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docekr10.jpg" srcset="/img/loading.gif" alt></p><ul><li>启动 测试下（我们设置了WORKDIR 进来就在我们指定的工作目录下）</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker11.jpg" srcset="/img/loading.gif" alt></p><ul><li>可以通过 <code>docker history 镜像id</code>  来查看镜像的构建过程</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker12.jpg" srcset="/img/loading.gif" alt></p>{% note primary %}`CMD`和`ENTRYPOINT`的区别CMD 最后的命令只能替换entrypoint 可以在命令后面追加参数{% endnote %}<ul><li>测试CMD</li></ul><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ dockerfile]# vim dockerfile-test-cmd[root@iZbp1baf0xyn152a53kixrZ dockerfile]# cat dockerfile-test-cmd FROM centosCMD ["ls","-a"][root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker build -f dockerfile-test-cmd -t test-cmd .Sending build context to Docker daemon  3.072kBStep 1/2 : FROM centos<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>Step 2/2 : CMD ["ls","-a"]<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> f33a79b32463</span>Removing intermediate container f33a79b32463<span class="hljs-meta"> ---&gt;</span><span class="bash"> e5087b9ba8b4</span>Successfully built e5087b9ba8b4Successfully tagged test-cmd:latest<span class="hljs-meta">#</span><span class="bash"> 启动镜像 成功后 cmd命令执行了</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it e5087b9ba8b4.   .dockerenvdev  home  lib64       media  opt   root  sbinsys  usr..  binetc  lib   lost+found  mnt    proc  run   srvtmp  var<span class="hljs-meta">#</span><span class="bash"> 追加命令 报错</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it e5087b9ba8b4 -ldocker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused "exec: \"-l\": executable file not found in $PATH": unknown.</code></pre></div><ul><li>测试 ENTRYPOINT</li></ul><div class="hljs"><pre><code class="hljs shell">创建dockerfile文件[root@iZbp1baf0xyn152a53kixrZ dockerfile]# vim dockerfile-test-entryinport[root@iZbp1baf0xyn152a53kixrZ dockerfile]# cat dockerfile-test-entryinport FROM centosENTRYPOINT ["ls","-a"]<span class="hljs-meta">#</span><span class="bash"> 构建镜像</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker build -f dockerfile-test-entryinport -t test-entryinport .Sending build context to Docker daemon  4.096kBStep 1/2 : FROM centos<span class="hljs-meta"> ---&gt;</span><span class="bash"> 470671670cac</span>Step 2/2 : ENTRYPOINT ["ls","-a"]<span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 96f23afcc451</span>Removing intermediate container 96f23afcc451<span class="hljs-meta"> ---&gt;</span><span class="bash"> 1144a7b9bae1</span>Successfully built 1144a7b9bae1Successfully tagged test-entryinport:latest<span class="hljs-meta">#</span><span class="bash"> 通过镜像启动，测试命令，这里和cmd一样的结果</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it 1144a7b9bae1.   .dockerenvdev  home  lib64       media  opt   root  sbinsys  usr..  binetc  lib   lost+found  mnt    proc  run   srvtmp  var<span class="hljs-meta">#</span><span class="bash"> 测试追加命令，entrypoint 可以追加参数</span>[root@iZbp1baf0xyn152a53kixrZ dockerfile]# docker run -it 1144a7b9bae1 -ltotal 0drwxr-xr-x   1 root root   6 Jun 10 10:46 .drwxr-xr-x   1 root root   6 Jun 10 10:46 ..-rwxr-xr-x   1 root root   0 Jun 10 10:46 .dockerenvlrwxrwxrwx   1 root root   7 May 11  2019 bin -&gt; usr/bindrwxr-xr-x   5 root root 360 Jun 10 10:46 devdrwxr-xr-x   1 root root  66 Jun 10 10:46 etcdrwxr-xr-x   2 root root   6 May 11  2019 homelrwxrwxrwx   1 root root   7 May 11  2019 lib -&gt; usr/liblrwxrwxrwx   1 root root   9 May 11  2019 lib64 -&gt; usr/lib64drwx------   2 root root   6 Jan 13 21:48 lost+founddrwxr-xr-x   2 root root   6 May 11  2019 mediadrwxr-xr-x   2 root root   6 May 11  2019 mntdrwxr-xr-x   2 root root   6 May 11  2019 optdr-xr-xr-x 136 root root   0 Jun 10 10:46 procdr-xr-x---   2 root root 162 Jan 13 21:49 rootdrwxr-xr-x  11 root root 163 Jan 13 21:49 runlrwxrwxrwx   1 root root   8 May 11  2019 sbin -&gt; usr/sbindrwxr-xr-x   2 root root   6 May 11  2019 srvdr-xr-xr-x  13 root root   0 Jun 10 10:46 sysdrwxrwxrwt   7 root root 145 Jan 13 21:49 tmpdrwxr-xr-x  12 root root 144 Jan 13 21:49 usrdrwxr-xr-x  20 root root 262 Jan 13 21:49 var</code></pre></div><h2 id="实战-：Tomcat镜像"><a href="#实战-：Tomcat镜像" class="headerlink" title="实战 ：Tomcat镜像"></a>实战 ：Tomcat镜像</h2><ul><li>准备镜像文件tomcat 压缩包，jdk压缩包！</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker13.jpg" srcset="/img/loading.gif" alt></p><ul><li>编写dockerfile文件，官方命令 <code>Dockerfile</code></li></ul><h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><div class="note note-primary">            <p>发布镜像到DockerHub</p>          </div><p>1、<a href="https://hub.docker.com注册自己的账号！" target="_blank" rel="noopener">https://hub.docker.com注册自己的账号！</a></p><p>2、在我们的服务器上提交这个镜像</p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ buildTomcatImage]# docker login --helpUsage:docker login [OPTIONS] [SERVER]Log in to a Docker registry.If no server is specified, the default is defined by the daemon.Options:  -p, --password string   Password      --password-stdin    Take the password from stdin  -u, --username string   Username</code></pre></div><p>3、登录上 之后就可以提交镜像了，就是一步 docker push</p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ buildTomcatImage]# docker login -u wangyang22Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json.Configure a credential helper to remove this warning. Seehttps://docs.docker.com/engine/reference/commandline/login/#credentials-storeLogin Succeeded</code></pre></div><p>4、 提交镜像，带着版本号</p><p>docker tag 镜像id 镜像名:版本号</p><p><code>由于网络原因，可能会被拒绝</code></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ buildTomcatImage]# docker push wangyang/centos:1.0The push refers to repository [docker.io/wangyang/centos]0683de282177: Preparing denied: requested access to the resource is denied</code></pre></div><div class="note note-primary">            <p>发布镜像到阿里云镜像服务</p>          </div><p>1 .登录阿里云</p><p>2.找到容器镜像服务</p><p>3、创建命名空间</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker14.jpg" srcset="/img/loading.gif" alt></p><p>4、创建容器镜像</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker15.jpg" srcset="/img/loading.gif" alt></p><p>具体的操作参考阿里云</p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker16.jpg" srcset="/img/loading.gif" style="zoom:150%;"><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker17.jpg" srcset="/img/loading.gif" alt></p><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1><h2 id="理解Docker0"><a href="#理解Docker0" class="headerlink" title="理解Docker0"></a>理解Docker0</h2><div class="note note-primary">            <p><code>ip addr</code>查看网络连接信息</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/ip-addr.jpg" srcset="/img/loading.gif" alt></p><p><strong>docker是如何处理容器网络访问的</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%AE%B9%E5%99%A8%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1.jpg" srcset="/img/loading.gif" alt></p><ul><li>启动一个tomcat容器</li></ul><div class="hljs"><pre><code class="hljs shell">docker run -d -P --name tomcat01 tomcat</code></pre></div><blockquote><p>查看容器内部网络地址，发现容器启动时都会得到一个eth0@if65 ip地址，docker分配的</p></blockquote><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec tomcat01 ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever64: eth0@if65: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default     link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0       valid_lft forever preferred_lft forever<span class="hljs-meta">#</span><span class="bash"> 在宿主机上ping 一下这个容器，发现也是可以ping 通的</span>[root@iZbp1baf0xyn152a53kixrZ ~]# ping 172.17.0.2PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.086 ms64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.071 ms64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.070 ms64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.061 ms64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.061 ms64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.068 ms</code></pre></div><div class="note note-primary">            <p>原理：只要安装了docker,就会有一个docker0网卡，我们每启动一个docker容器，docker就会给docker容器分配一个ip。</p><p>桥接模式，使用的是veth-pair技术</p>          </div><ul><li>再次测试 ip addr 发现多了一个ip</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/veth-pair01.jpg" srcset="/img/loading.gif" alt></p><ul><li>再启动一个docker,发现又多了ip</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/veth-pair02.jpg" srcset="/img/loading.gif" alt></p><p><code>发现这些容器的网卡，都是一对一对的，这就veth-pair 一对虚拟的设备接口，都是成对出现的，一端连着协议，一端彼此相连。利用这个特性，连接各种虚拟网络设备</code></p><ul><li>测试Tomcat01 和tomcat02是否可以ping通</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%A1%A5%E6%8E%A5%E7%BD%91%E5%8D%A1.jpg" srcset="/img/loading.gif" alt></p><p><code>容器和容器之间是可以ping通的，tomcat01 和tomcat02是公用的一个路由器也就是docker0。所有的容器不指定网络的情况下，默认都是docker0路由的，docker0会给每一容器分配一个可以用的ip</code></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>docker 使用的是linux的桥接，宿主机中是一个Docker容器的网桥docker0</p><p>Docker 中所有的网络接口都是虚拟的。虚拟的转发效率高。只要容器删除，对应的一对veth-pair就会删除。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E7%BD%91%E6%A1%A5.jpg" srcset="/img/loading.gif" alt></p><h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><p>思考一个场景，编写一个微服务，database url=ip; 项目不重启，数据库ip换了，我们希望可以通过名字来访问容器。</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通过容器名来访问</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it tomcat02 ping tomcat01ping: tomcat01: Temporary failure in name resolution<span class="hljs-meta">#</span><span class="bash"> 解决不能通过容器名访问另一个容器的问题 --link</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name tomcat04 --link tomcat01 tomcat1320f2f4135933df7e11b8f8d3e8e8db10eab6959c65c2585cd24a1e1e4d2cb2[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it tomcat04 ping tomcat01PING tomcat01 (172.17.0.2) 56(84) bytes of data.64 bytes from tomcat01 (172.17.0.2): icmp_seq=1 ttl=64 time=0.153 ms64 bytes from tomcat01 (172.17.0.2): icmp_seq=2 ttl=64 time=0.089 ms64 bytes from tomcat01 (172.17.0.2): icmp_seq=3 ttl=64 time=0.103 ms64 bytes from tomcat01 (172.17.0.2): icmp_seq=4 ttl=64 time=0.086 ms<span class="hljs-meta">#</span><span class="bash"> 反向连接不可以ping通</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it tomcat01 ping tomcat04ping: tomcat04: Temporary failure in name resolution</code></pre></div><p>其实 就是 tomcat03在本地配置了tomcat02</p><p><strong>本质</strong>：–link就是在hosts配置中增加了一个172.17.0.3    tomcat02 f02eeee4ac8a</p><p>现在玩Docker已经<code>不建议使用 --link了！</code></p><p>docker0 不支持容器名访问</p><h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><div class="note note-primary">            <p>查看网卡信息 <code>docker network ls</code></p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/network.jpg" srcset="/img/loading.gif" alt></p><p><strong>网络模式</strong></p><p>bridge :  桥接模式（默认）</p><p>host： 和主机共享网络</p><p>none:  不配置网络</p><p><strong>测试</strong></p><blockquote><p>之前我们直接启动一个容器默认是带着 <code>--net bridge</code></p><p>docker run -d -P –name tomcat01 –net bridge tomcat </p><p>​                                        ||</p><p>docker run -d -P –name tomcat01 tomcat</p><p>docker0 特点： 是默认的，容器名不访问 ，可以使用–link 连同</p></blockquote><ul><li>创建自定义的网络</li></ul><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker network create -d bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet077ded555eba6506432dfcfd57db1c59e91ff792294702a7d8a6ad3c82d531af[root@iZbp1baf0xyn152a53kixrZ ~]# docker network lsNETWORK ID          NAME                DRIVER              SCOPEabe6f173e521        bridge              bridge              local45464866e7ab        host                host                local077ded555eba        mynet               bridge              local5e194fec7f08        none                null                local</code></pre></div><p><strong>我们自己创建的网络</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/mynet.jpg" srcset="/img/loading.gif" alt></p><p>使用自动以的网络启动两个容器</p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name tomcat-net-01 --net mynet tomcat[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d -P --name tomcat-net-02 --net mynet tomcat</code></pre></div><p><strong>查看自定义网卡下的详细信息</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker network inspect mynet[    &#123;        "Name": "mynet",        "Id": "077ded555eba6506432dfcfd57db1c59e91ff792294702a7d8a6ad3c82d531af",        "Created": "2020-06-11T14:27:09.90550936+08:00",        "Scope": "local",        "Driver": "bridge",        "EnableIPv6": false,        "IPAM": &#123;            "Driver": "default",            "Options": &#123;&#125;,            "Config": [                &#123;                    "Subnet": "192.168.0.0/16",                    "Gateway": "192.168.0.1"                &#125;            ]        &#125;,        "Internal": false,        "Attachable": false,        "Ingress": false,        "ConfigFrom": &#123;            "Network": ""        &#125;,        "ConfigOnly": false,        "Containers": &#123;            "3bb5cbb40854c9a9741de337607481400d6b4e36afc7495f8ad8be453904933b": &#123;                "Name": "tomcat-net-02",                "EndpointID": "9772aff8ea85e9c698bacc1941dd49bbf8af23c266131b8d46e09d34957c6692",                "MacAddress": "02:42:c0:a8:00:03",                "IPv4Address": "192.168.0.3/16",                "IPv6Address": ""            &#125;,            "4515121b30deb6836e85a9de3be8549c2466e8f7d1443e4c7ee239bd63fcdd55": &#123;                "Name": "tomcat-net-01",                "EndpointID": "469f2163f5d81a113114599b936407f71ee6681880ef9934d33871ac3c5c57e3",                "MacAddress": "02:42:c0:a8:00:02",                "IPv4Address": "192.168.0.2/16",                "IPv6Address": ""            &#125;        &#125;,        "Options": &#123;&#125;,        "Labels": &#123;&#125;    &#125;]</code></pre></div><p><strong>使用自定义的网络可以容器名ping通</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E5%8F%AF%E4%BB%A5%E5%AE%B9%E5%99%A8%E5%90%8Dping.jpg" srcset="/img/loading.gif" alt></p><h2 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h2><div class="note note-primary">            <p>不在同一个网络段的容器不能之间联通，必须使用 <code>docker network connect</code> 将他们联通</p>          </div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%90%91%E4%B8%80%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E8%BF%9E%E5%90%8C%E7%BD%91%E5%8D%A1%E5%92%8C%E5%AE%B9%E5%99%A8.jpg" srcset="/img/loading.gif" alt></p><p><strong>测试打通mynet 到 tomcat01</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker network connect mynet tomcat01</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/network%20connect%20ping%20%E9%80%9A%E4%BA%86%E5%AE%B9%E5%99%A8%E5%92%8Cmynet.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>连通之后查看发现，直接是将tomcat01放到mynet下</p><p>一个容器两个ip,就好比阿里云的 公网ip 和内网ip</p></blockquote><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/tomat01%E6%94%BE%E5%88%B0mynet%E4%B8%8B.jpg" srcset="/img/loading.gif" alt></p><h2 id="实战部署redis集群"><a href="#实战部署redis集群" class="headerlink" title="实战部署redis集群"></a>实战部署redis集群</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/redis%E9%9B%86%E7%BE%A4.jpg" srcset="/img/loading.gif" alt></p><h2 id="Spring-Boot-打包成Docker-镜像"><a href="#Spring-Boot-打包成Docker-镜像" class="headerlink" title="Spring Boot 打包成Docker 镜像"></a>Spring Boot 打包成Docker 镜像</h2><ol><li>创建springboot 应用</li><li>打包springboot</li><li>编写Dockerfile</li><li>上传大好的jar包和Dockerfile</li><li>构建docker镜像</li><li>发送到仓库</li></ol>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker基础</title>
    <link href="/2020/06/07/Docker%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/06/07/Docker%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>Docker 学习</p><ul><li><p>Docker概述</p></li><li><p>Docker安装</p></li><li><p>Docker命令</p><ul><li>镜像命令</li><li>容器命令</li><li>操作命令</li><li>…</li></ul></li><li><p>Docker镜像！</p></li><li><p>容器数据卷！</p></li><li><p>DockerFile</p></li><li><p>Docker网络原理</p></li><li><p>IDEA整合Docker</p></li><li><p>集群 DockerCompose</p></li><li><p>Docker Swarm</p></li><li><p>CI\CD Jenkins</p></li></ul><h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><h2 id="Docker为什么出现？"><a href="#Docker为什么出现？" class="headerlink" title="Docker为什么出现？"></a>Docker为什么出现？</h2><p>一款产品：开发–上线 两套环境！应用环境，应用配置</p><p>开发 —运维。经常会出现这种问题，在我的电脑上可以运行？到你那里就不可以运行了！版本更新，导致服务不可用！</p><p>环境配置是十分麻烦的，每一机器都要配置环境，特别麻烦浪费时间。</p><p>发布一个项目以前是发布一个jar,但是它需要运行环境。我们好需要去配置运行环境。</p><p>那么我们可以让jar + 开发环境（Redis Mysql jdk ES） 打包部署，就不需要麻烦的配置了。</p><p>之前服务器配置了一个应用环境Redis Mysql jdk ES Hadoop，配置起来很麻烦，而且还不能跨平台。那么 没换一个服务就又得重新配置一边。</p><p>传统开发： 开发jar ,运维来做部署！</p><p>现在，开发打包部署上线，一套流程做完！</p><p>我们使用java开发一个项目—&gt; 打包的时候带上环境（镜像）—&gt;将它放到Docker仓库—–&gt;下载我们发布的镜像—&gt;直接运行即可</p><p><strong>Docker 给以上的问题，提出了解决方案</strong></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker.jpg" srcset="/img/loading.gif" alt></p><p><code>Docker的思想就来源于集装箱！</code></p><p>隔离: Docker核心思想！打包装箱！每个箱子是相互隔离的。</p><p>Docker通过隔离机制，可以将服务器运用到极致。</p><h2 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h2><p>2010，几个搞IT的年轻人，在美国成立了一公司<code>dotCloud</code></p><p>做一些pass的云计算服务！linux中虚拟机有关的容器技术!</p><p>他们将自己的技术（容器化技术）命名就是Docker!</p><p>Docker刚刚诞生的时候，没有引起行业的注意！dotCloud，就活不下去了，他们想到了开源，<code>开放源代码</code>。</p><p>2013年，Docker开源！以至于越来越多的人了解，发现好用。就被广泛使用。发展的越来越好！</p><p><strong>Docker为什么这么火？</strong></p><p>虚拟机也是属于虚拟化技术，Docker容器技术，也是一种虚拟化技术。</p><p>在容器化技术发展起来的时候，我们一直使用的即使虚拟机技术。</p><p>虚拟机：在windows中装一个Vmware，通过这个软件让我们虚拟出来一个或多个电脑！但是它非常笨重。</p><div class="hljs"><pre><code class="hljs shell">vm ： linux centos原生镜像（一个电脑）几十个G的大小，启动时间久。docker ： 隔离，镜像（最核心的环境）十分的小巧，运行镜像就可以了！启动非常快</code></pre></div><blockquote><p>聊聊Docker</p></blockquote><p>Docker是基于Go语言开发的！开源项目！</p><p>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/Docs.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>之前的虚拟机技术</p></blockquote><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/mv.jpg" srcset="/img/loading.gif" alt></p><p><strong>虚拟机技术缺点：</strong></p><p>1、资源占用什么多</p><p>2、冗余步骤多</p><p>3、启动很慢</p><blockquote><p>容器化技术</p></blockquote><p>比较Docker和虚拟机技术的不同：</p><ul><li><p>传统虚拟机，直接虚拟出一个硬件，运行一个完成的操作系统，然后在这个系统上安装运行软件。</p></li><li><p>容器内的应用直接运行在宿主机的内核上，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了很多</p></li><li><p>每个容器间是相互隔离的，每个容器内都有一个属于自己的文件系统，互不影响。</p></li></ul><blockquote><p>DevOps（开发运维）使用Docker后的好处</p></blockquote><p><strong>应用更快捷的交付和部署</strong></p><p>传统：运维时，要看一堆帮助文档，安装程序</p><p>Docker:  打包镜像发布测试，一键运行</p><p><strong>更便捷的升级和扩容</strong></p><p>项目打包成一个镜像，扩展服务器A ！服务器B</p><p><strong>更简单的系统运维</strong></p><p>容器化后，我们的开发，测试环境都高度的一致</p><p><strong>更高效的计算资源利用</strong></p><p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的实例容器，服务器的性能可以内利用到极致。</p><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><p>Docker的基本组成</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="Docker架构图"></p><p><strong>镜像（image）</strong></p><p>docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，可以创建多个容器，最终项目就运行在这些容器中</p><p><strong>容器（container）</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建。</p><p>目前可以把容器理解为是一个简易的linux系统</p><p><strong>仓库（repository）</strong></p><p>仓库就是来存放镜像的地方</p><p>仓库可以分为公有仓库和私有仓库</p><p>Docker Hub</p><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><blockquote><p>环境准备</p><p>1.需要回点Linux基础</p><p>2.CentOS7</p><p>3.使用Xshell连接远程服务进行操作</p></blockquote><blockquote><p>环境查看 uname -r</p></blockquote><p><strong>查看系统内核版本</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# uname -r4.18.0-147.8.1.el8_1.x86_64</code></pre></div><p><strong>查看linux系统版本</strong></p><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# cat /etc/os-releaseNAME="CentOS Linux"VERSION="8 (Core)"ID="centos"ID_LIKE="rhel fedora"VERSION_ID="8"PLATFORM_ID="platform:el8"PRETTY_NAME="CentOS Linux 8 (Core)"ANSI_COLOR="0;31"CPE_NAME="cpe:/o:centos:centos:8"HOME_URL="https://www.centos.org/"BUG_REPORT_URL="https://bugs.centos.org/"CENTOS_MANTISBT_PROJECT="CentOS-8"CENTOS_MANTISBT_PROJECT_VERSION="8"REDHAT_SUPPORT_PRODUCT="centos"REDHAT_SUPPORT_PRODUCT_VERSION="8"</code></pre></div><blockquote><p>安装</p></blockquote> <div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.卸载旧的版本</span>yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine                  <span class="hljs-meta">#</span><span class="bash"> 2.需要的安装包</span>yum install -y yum-utils<span class="hljs-meta">#</span><span class="bash"> 3.设置仓库的镜像</span><span class="hljs-meta">#</span><span class="bash"> 默认使用的是国外的，访问很慢，我们使用阿里云的</span>yum-config-manager \    --add-repo \http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 建议更新yum软件索引包</span>yum makecache fast<span class="hljs-meta">#</span><span class="bash"> 4.安装docker ce 社区版 ee 企业版</span>yum install docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 5.启动docker</span>systemctl start docker</code></pre></div><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 6.查看是否安装成功</span>docker version</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%9F%A5%E7%9C%8Bdocker%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 7.测试 通过运行hello-world 映像来验证是否正确安装了Docker Engine </span>docker run hello-world</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker-helloworld.jpg" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 8.查看一下下载的这个镜像</span>docker images</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/hello-image.jpg" srcset="/img/loading.gif" alt></p><blockquote><p><strong>了解</strong>  卸载docker  docker的默认工作路径<strong>/var/lib/docker</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.删除docker依赖</span>yum remove docker-ce docker-ce-cli containerd.io<span class="hljs-meta">#</span><span class="bash"> 2.删除目录</span>rm -rf /var/lib/docker</code></pre></div><h2 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h2><h3 id="1-登录阿里云找到镜像服务"><a href="#1-登录阿里云找到镜像服务" class="headerlink" title="1. 登录阿里云找到镜像服务"></a>1. 登录阿里云找到镜像服务</h3><h3 id="2-找到每个人的镜像加速地址"><a href="#2-找到每个人的镜像加速地址" class="headerlink" title="2. 找到每个人的镜像加速地址"></a>2. 找到每个人的镜像加速地址</h3><h3 id="3-在镜像中心找到镜像加速器，配置使用"><a href="#3-在镜像中心找到镜像加速器，配置使用" class="headerlink" title="3. 在镜像中心找到镜像加速器，配置使用"></a>3. 在镜像中心找到镜像加速器，配置使用</h3><blockquote><p>每个人都有自己的地址</p></blockquote><div class="hljs"><pre><code class="hljs shell">sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;  "registry-mirrors": ["https://xxxxxxxx.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre></div><h2 id="回顾HelloWord流程"><a href="#回顾HelloWord流程" class="headerlink" title="回顾HelloWord流程"></a>回顾HelloWord流程</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/hello-world%E6%B5%81%E7%A8%8B.jpg" srcset="/img/loading.gif" alt="Hello world流程"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker-run.jpg" srcset="/img/loading.gif" alt="docker run"></p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p><strong>Docker 是怎么工作的？</strong></p><p>Docekr是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！（类似mysql）</p><p>DockerServer接收到Docker-Clinet的指令，就会执行这个命令。</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E5%8E%9F%E7%90%86.jpg" srcset="/img/loading.gif" alt></p><p><strong>Docker为什么比VM快？</strong></p><p>1、Docker有着比虚拟机更少的抽象层</p><p>2、Docker利用的是宿主机的内核，vm需要自己的Guest OS</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/vm--docker%E5%8C%BA%E5%88%AB.jpg" srcset="/img/loading.gif" alt></p><p>所以说，新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载Guest OS 分钟级别的。而Docker是利用宿主机的操作系统，省略了这个复杂的过程，启动时秒机的。</p><h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><div class="hljs"><pre><code class="hljs shell">docekr version  # 查看docekr的版本信息docker info# 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help  # 帮助命令</code></pre></div><p><a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">命令帮助文档</a></p><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p><strong>docker images</strong>  查看所有本地主机上的镜像</p></blockquote><div class="hljs"><pre><code class="hljs shell">root@iZbp1baf0xyn152a53kixrZ ~]# docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEhello-world         latest              bf756fb1ae65        5 months ago        13.3kB<span class="hljs-meta">#</span><span class="bash"> 解释</span>REPOSITORY 仓库名字TAG        标签指定版本IMAGE ID   镜像idCREATED    创建时间SIZE       大小<span class="hljs-meta">#</span><span class="bash"> 可选项</span>Options:  -a, --all             Show all images (default hides intermediate images) ## 常用  查看所有      --digests         Show digests  -f, --filter filter   Filter output based on conditions provided      --format string   Pretty-print images using a Go template      --no-trunc        Don't truncate output  -q, --quiet           Only show numeric IDs   ## 常用  查看id</code></pre></div><blockquote><p><strong>docker search 搜索镜像</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker search 镜像名字</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search mysqlNAME     DESCRIPTION      STARS    OFFICIAL    AUTOMATEDmysql    MySQL is a widely used, open-source relation… 9587 [OK]mariadb   MariaDB is a community-developed fork of MyS…   3486   [OK]<span class="hljs-meta">#</span><span class="bash"> 按照星数过滤</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search mysql --filter=STARS=3000NAME                DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDmysql               MySQL is a widely used, open-source relation…   9587                [OK]                mariadb             MariaDB is a community-developed fork of MyS…   3486                [OK]</code></pre></div><blockquote><p>docker  pull 下载镜像</p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysqlUsing default tag: latest  # 如果不写tag ,默认是下载最先版的latest: Pulling from library/mysqlafb6ec6fdc1c: Pull complete  # 分层下载 docker image 核心0bdc5971ba40: Pull complete 97ae94a2c729: Pull complete f777521d340e: Pull complete 1393ff7fc871: Pull complete a499b89994d9: Pull complete 7ebe8eefbafe: Pull complete 597069368ef1: Pull complete ce39a5501878: Pull complete 7d545bca14bf: Pull complete 211e5bb2ae7b: Pull complete 5914e537c077: Pull complete Digest: sha256:a31a277d8d39450220c722c1302a345c84206e7fd4cdb619e7face046e89031d # 防伪签名Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest  <span class="hljs-meta">#</span><span class="bash">  真实地址  docker pull mysql 等价于 docker pull docker.io/library/mysql:latest</span><span class="hljs-meta">#</span><span class="bash"> 指定版本下载</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull mysql:5.75.7: Pulling from library/mysqlafb6ec6fdc1c: Already exists  # 已经存在的分层0bdc5971ba40: Already exists 97ae94a2c729: Already exists f777521d340e: Already exists 1393ff7fc871: Already exists a499b89994d9: Already exists 7ebe8eefbafe: Already exists 4eec965ae405: Pull complete a531a782d709: Pull complete 270aeddb45e3: Pull complete b25569b61008: Pull complete Digest: sha256:d16d9ef7a4ecb29efcd1ba46d5a82bda3c28bd18c0f1e3b86ba54816211e1ac4Status: Downloaded newer image for mysql:5.7docker.io/library/mysql:5.7<span class="hljs-meta">#</span><span class="bash"> 查看帮助命令</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull --helpUsage:docker pull [OPTIONS] NAME[:TAG|@DIGEST]Pull an image or a repository from a registryOptions:  -a, --all-tags                Download all tagged images in the repository      --disable-content-trust   Skip image verification (default true)      --platform string         Set platform if server is multi-platform capable  -q, --quiet                   Suppress verbose output</code></pre></div><blockquote><p><strong>docker rmi</strong> 删除docker image </p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除指定的镜像</span>docekr rmi -f 镜像id<span class="hljs-meta">#</span><span class="bash"> 删除多个镜像</span>docker  rmi -f 镜像id 镜像id 镜像id 镜像id<span class="hljs-meta">#</span><span class="bash"> 批量删除   $(docker images -aq)作为参数</span>docker rmi -f $(docker images -aq)</code></pre></div><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><code>我们有了镜像之后，才可以创建容器，使用linux下载一个镜像来学习测试</code></p><div class="hljs"><pre><code class="hljs shell">docker pull centos</code></pre></div><blockquote><p>新建容器并启动 <code>docker run -it centos /bin/bash</code></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动容器，并进入容器</span>docker run -it centos /bin/bash[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -it centos /bin/bash[root@e214ca179c15 /]# lsbin  etc   lib  lost+found  mnt  proc  run   srv  tmp  vardev  home  lib64  media       opt  root  sbin  sys  usr<span class="hljs-meta">#</span><span class="bash"> 容器停止并退出</span>[root@e214ca179c15 /]# exitexit</code></pre></div><blockquote><p><strong>退出容器</strong></p><p>容器停止并退出<br>[root@e214ca179c15 /]# exit<br>exit</p><p>容器不停止退出容器</p><p>Ctrl + P + Q</p></blockquote><blockquote><p>查看正在运行的容器 <code>docker ps</code></p><p>查看曾经运行过的容器 <code>docker ps -a</code></p><p>参数</p><p>​    无参：    列出当前正在运行的容器</p><p>​    -a :             列出当前正在运行的容器，以及停止运行的容器</p><p>​    -n=?         显示最近运行的容器 ？ 指定个数</p><p>​    -q            只显示容器编号</p></blockquote><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker psCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</code></pre></div><blockquote><p><strong>删除容器</strong></p></blockquote><div class="hljs"><pre><code class="hljs shell">docker rm 容器id  # 删除指定容器docker rm  -f $(docker ps -aq)   #删除所有容器 docker ps -a -q | xargs docker rm -f  # 删除所有的容器</code></pre></div><blockquote><p>启动和停止容器</p></blockquote><div class="hljs"><pre><code class="hljs shell">docker start 容器id# 启动容器docker restart 容器id# 重启容器docker stop 容器id# 停止当前正在容器docker kill 容器id        # 强制停止当前运行的容器</code></pre></div><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="1、后台启动命令"><a href="#1、后台启动命令" class="headerlink" title="1、后台启动命令"></a>1、后台启动命令</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker run -d 镜像名    后台启动容器</span><span class="hljs-meta">#</span><span class="bash"> 问题 docker ps， 发现容器停止了</span><span class="hljs-meta">#</span><span class="bash"> dockek容器使用后台运行，就必须要有一个前台进程，docker发现没有应用就会自动停止。</span></code></pre></div><h3 id="2、查看日志"><a href="#2、查看日志" class="headerlink" title="2、查看日志"></a>2、查看日志</h3><div class="hljs"><pre><code class="hljs shell">docker logs -ft --tail n  # 查看日志的后几条<span class="hljs-meta">#</span><span class="bash"> 显示日志</span>-tf     # 时间戳和格式--tail number    #显示日志后几条</code></pre></div><h3 id="3、查看容器中的进程命令"><a href="#3、查看容器中的进程命令" class="headerlink" title="3、查看容器中的进程命令"></a>3、查看容器中的进程命令</h3><div class="hljs"><pre><code class="hljs shell">[root@iZbp1baf0xyn152a53kixrZ ~]# docker top 1b4cdaa8b5aeUID    PID   PPID   C   STIME    TTY    TIME   CMDroot  20878   20862  0  08:48   pts/0 00:00:00  /bin/bash</code></pre></div><h3 id="4、查看容器的元数据"><a href="#4、查看容器的元数据" class="headerlink" title="4、查看容器的元数据"></a>4、查看容器的元数据</h3><div class="hljs"><pre><code class="hljs shell">docker inspect 容器id[root@iZbp1baf0xyn152a53kixrZ ~]# docker inspect 1b4cdaa8b5ae[    &#123;        "Id": "1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee",        "Created": "2020-06-06T07:20:02.258890351Z",        "Path": "/bin/bash",        "Args": [],        "State": &#123;            "Status": "running",            "Running": true,            "Paused": false,            "Restarting": false,            "OOMKilled": false,            "Dead": false,            "Pid": 20878,            "ExitCode": 0,            "Error": "",            "StartedAt": "2020-06-07T00:48:12.344223612Z",            "FinishedAt": "2020-06-06T07:23:34.064971347Z"        &#125;,        "Image": "sha256:470671670cac686c7cf0081e0b37da2e9f4f768ddc5f6a26102ccd1c6954c1ee",        "ResolvConfPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/resolv.conf",        "HostnamePath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/hostname",        "HostsPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/hosts",        "LogPath": "/var/lib/docker/containers/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee/1b4cdaa8b5ae4811dd04a3eac5782ee5aefe2edc22afa2e434728cf873d433ee-json.log",        "Name": "/heuristic_davinci",        "RestartCount": 0,        "Driver": "overlay2",        "Platform": "linux",        "MountLabel": "",        "ProcessLabel": "",        "AppArmorProfile": "",        "ExecIDs": null,        "HostConfig": &#123;            "Binds": null,            "ContainerIDFile": "",            "LogConfig": &#123;                "Type": "json-file",                "Config": &#123;&#125;            &#125;,            "NetworkMode": "default",            "PortBindings": &#123;&#125;,            "RestartPolicy": &#123;                "Name": "no",                "MaximumRetryCount": 0            &#125;,            "AutoRemove": false,            "VolumeDriver": "",            "VolumesFrom": null,            "CapAdd": null,            "CapDrop": null,            "Capabilities": null,            "Dns": [],            "DnsOptions": [],            "DnsSearch": [],            "ExtraHosts": null,            "GroupAdd": null,            "IpcMode": "private",            "Cgroup": "",            "Links": null,            "OomScoreAdj": 0,            "PidMode": "",            "Privileged": false,            "PublishAllPorts": false,            "ReadonlyRootfs": false,            "SecurityOpt": null,            "UTSMode": "",            "UsernsMode": "",            "ShmSize": 67108864,            "Runtime": "runc",            "ConsoleSize": [                0,                0            ],            "Isolation": "",            "CpuShares": 0,            "Memory": 0,            "NanoCpus": 0,            "CgroupParent": "",            "BlkioWeight": 0,            "BlkioWeightDevice": [],            "BlkioDeviceReadBps": null,            "BlkioDeviceWriteBps": null,            "BlkioDeviceReadIOps": null,            "BlkioDeviceWriteIOps": null,            "CpuPeriod": 0,            "CpuQuota": 0,            "CpuRealtimePeriod": 0,            "CpuRealtimeRuntime": 0,            "CpusetCpus": "",            "CpusetMems": "",            "Devices": [],            "DeviceCgroupRules": null,            "DeviceRequests": null,            "KernelMemory": 0,            "KernelMemoryTCP": 0,            "MemoryReservation": 0,            "MemorySwap": 0,            "MemorySwappiness": null,            "OomKillDisable": false,            "PidsLimit": null,            "Ulimits": null,            "CpuCount": 0,            "CpuPercent": 0,            "IOMaximumIOps": 0,            "IOMaximumBandwidth": 0,            "MaskedPaths": [                "/proc/asound",                "/proc/acpi",                "/proc/kcore",                "/proc/keys",                "/proc/latency_stats",                "/proc/timer_list",                "/proc/timer_stats",                "/proc/sched_debug",                "/proc/scsi",                "/sys/firmware"            ],            "ReadonlyPaths": [                "/proc/bus",                "/proc/fs",                "/proc/irq",                "/proc/sys",                "/proc/sysrq-trigger"            ]        &#125;,        "GraphDriver": &#123;            "Data": &#123;                "LowerDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72-init/diff:/var/lib/docker/overlay2/5a6f50a98473d927999ddc03f2b6b8670059cceef16c833cafb050a59fcc479c/diff",                "MergedDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/merged",                "UpperDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/diff",                "WorkDir": "/var/lib/docker/overlay2/5a75127c4e03a2258e6b936ab52019f2addf074f8f0411064a80cd57dc033b72/work"            &#125;,            "Name": "overlay2"        &#125;,        "Mounts": [],        "Config": &#123;            "Hostname": "1b4cdaa8b5ae",            "Domainname": "",            "User": "",            "AttachStdin": true,            "AttachStdout": true,            "AttachStderr": true,            "Tty": true,            "OpenStdin": true,            "StdinOnce": true,            "Env": [                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"            ],            "Cmd": [                "/bin/bash"            ],            "Image": "centos",            "Volumes": null,            "WorkingDir": "",            "Entrypoint": null,            "OnBuild": null,            "Labels": &#123;                "org.label-schema.build-date": "20200114",                "org.label-schema.license": "GPLv2",                "org.label-schema.name": "CentOS Base Image",                "org.label-schema.schema-version": "1.0",                "org.label-schema.vendor": "CentOS",                "org.opencontainers.image.created": "2020-01-14 00:00:00-08:00",                "org.opencontainers.image.licenses": "GPL-2.0-only",                "org.opencontainers.image.title": "CentOS Base Image",                "org.opencontainers.image.vendor": "CentOS"            &#125;        &#125;,        "NetworkSettings": &#123;            "Bridge": "",            "SandboxID": "438bb0e752375594c48f8ba55f4374214bd3b36cf1e9ebbc06bb8cb471f79381",            "HairpinMode": false,            "LinkLocalIPv6Address": "",            "LinkLocalIPv6PrefixLen": 0,            "Ports": &#123;&#125;,            "SandboxKey": "/var/run/docker/netns/438bb0e75237",            "SecondaryIPAddresses": null,            "SecondaryIPv6Addresses": null,            "EndpointID": "f9881ae9d0d82f56ce686875465a0b919929bf4b6a094a90f3eecf95418be7d7",            "Gateway": "172.17.0.1",            "GlobalIPv6Address": "",            "GlobalIPv6PrefixLen": 0,            "IPAddress": "172.17.0.2",            "IPPrefixLen": 16,            "IPv6Gateway": "",            "MacAddress": "02:42:ac:11:00:02",            "Networks": &#123;                "bridge": &#123;                    "IPAMConfig": null,                    "Links": null,                    "Aliases": null,                    "NetworkID": "abe6f173e52133983efc00c41f8b3125612c37489f7eba4898ef1fc1b1a570b5",                    "EndpointID": "f9881ae9d0d82f56ce686875465a0b919929bf4b6a094a90f3eecf95418be7d7",                    "Gateway": "172.17.0.1",                    "IPAddress": "172.17.0.2",                    "IPPrefixLen": 16,                    "IPv6Gateway": "",                    "GlobalIPv6Address": "",                    "GlobalIPv6PrefixLen": 0,                    "MacAddress": "02:42:ac:11:00:02",                    "DriverOpts": null                &#125;            &#125;        &#125;    &#125;]</code></pre></div><h3 id="5、进入当前正在运行的容器（重要）"><a href="#5、进入当前正在运行的容器（重要）" class="headerlink" title="5、进入当前正在运行的容器（重要）"></a>5、进入当前正在运行的容器（<code>重要</code>）</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 通常容器都是使用后台方式运行的，我们需要进入容器，修改一些配置</span><span class="hljs-meta">#</span><span class="bash"> 方式一</span>docker exec -it 容器id /bin/bashroot@iZbp1baf0xyn152a53kixrZ ~]# docker exec -it 1b4cdaa8b5ae /bin/bash[root@1b4cdaa8b5ae /]# lsbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var[root@1b4cdaa8b5ae /]# read escape sequence<span class="hljs-meta">#</span><span class="bash"> 方式二</span>docker attach 容器id[root@iZbp1baf0xyn152a53kixrZ ~]# docker attach 1b4cdaa8b5ae[root@1b4cdaa8b5ae /]# ls<span class="hljs-meta">#</span><span class="bash"> 区别</span><span class="hljs-meta">#</span><span class="bash"> docker <span class="hljs-built_in">exec</span>  进入容器后开启一个新的终端，再在里面操作（常用）</span><span class="hljs-meta">#</span><span class="bash"> docker attach  进入容器正在执行的终端</span></code></pre></div><h3 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h3><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> docker cp 容器id:/文件所在的路径  /要复制到主机的哪个位置</span><span class="hljs-meta">#</span><span class="bash"> 注意复制时 需要退出容器</span></code></pre></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93.jpg" srcset="/img/loading.gif" alt></p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="1、部署Nginx"><a href="#1、部署Nginx" class="headerlink" title="1、部署Nginx"></a>1、部署Nginx</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、搜索镜像 建议去docker Hub上搜索，可以看见版本号</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker search nginx --filter=stars=10000NAME                DESCRIPTION                STARS               OFFICIAL            AUTOMATEDnginx               Official build of Nginx.   13299               [OK]<span class="hljs-meta">#</span><span class="bash"> 2、下载镜像</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker pull nginxUsing default tag: latestlatest: Pulling from library/nginxafb6ec6fdc1c: Pull complete dd3ac8106a0b: Pull complete 8de28bdda69b: Pull complete a2c431ac2669: Pull complete e070d03fd1b5: Pull complete Digest: sha256:c870bf53de0357813af37b9500cb1c2ff9fb4c00120d5fe1d75c21591293c34dStatus: Downloaded newer image for nginx:latestdocker.io/library/nginx:latest<span class="hljs-meta">#</span><span class="bash"> 3、启动容器 docker run -d --name nginx01 -p 3344:80 nginx</span><span class="hljs-meta">#</span><span class="bash"> -d 后台运行</span><span class="hljs-meta">#</span><span class="bash"> --name 给容器起名字</span><span class="hljs-meta">#</span><span class="bash"> -p 宿主机端口：容器内部端口</span>[root@iZbp1baf0xyn152a53kixrZ ~]# docker run -d --name nginx01 -p 3344:80 nginx2f2205692302e8d08a27d2a6476fa50034dd2eaa3114fd422de025febe072930[root@iZbp1baf0xyn152a53kixrZ ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES2f2205692302        nginx               "/docker-entrypoint.…"   6 seconds ago       Up 4 seconds        0.0.0.0:3344-&gt;80/tcp   nginx01 <span class="hljs-meta">#</span><span class="bash"> curl localhost:端口号查看是否启动成功</span>[root@iZbp1baf0xyn152a53kixrZ ~]# curl localhost:3344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Welcome to nginx!&lt;/title&gt;&lt;style&gt;    body &#123;        width: 35em;        margin: 0 auto;        font-family: Tahoma, Verdana, Arial, sans-serif;    &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;&lt;p&gt;If you see this page, the nginx web server is successfully installed andworking. Further configuration is required.&lt;/p&gt;&lt;p&gt;For online documentation and support please refer to&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;Commercial support is available at&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></div><h2 id="2、部署Tomcat"><a href="#2、部署Tomcat" class="headerlink" title="2、部署Tomcat"></a>2、部署Tomcat</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.搜素镜像</span>docker search tomcat<span class="hljs-meta">#</span><span class="bash"> 2.下载镜像</span>docker pull tomcat:9.0<span class="hljs-meta">#</span><span class="bash"> 3.创建容器，并启动，主机和容器的端口映射</span>docker run -d -name tomcat01 -p 3355:8080 tomcat:9.0<span class="hljs-meta">#</span><span class="bash"> 4.测试</span>curl localhost:8080<span class="hljs-meta">#</span><span class="bash"> 在外网访问 容器中的tomcat 会报404，解决：可以将webapps.dist下的文件复制到 webapps 下</span><span class="hljs-meta">#</span><span class="bash"> 发现问题</span><span class="hljs-meta">#</span><span class="bash"> a.容器中Tomcat的命令少了</span><span class="hljs-meta">#</span><span class="bash"> b.没有webapps.这是由于阿里云镜像的原因，默认是最小的镜像，剔除了不必要的，只保证最小的可运行环境，是一个阉割版的Tomcat</span></code></pre></div><h2 id="3、部署-ES-Kibana"><a href="#3、部署-ES-Kibana" class="headerlink" title="3、部署 ES + Kibana"></a>3、部署 ES + Kibana</h2><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> es 暴露的端口很多</span><span class="hljs-meta">#</span><span class="bash"> es 十分耗内存</span><span class="hljs-meta">#</span><span class="bash"> es 的数据一般需要放置到安全目录！挂载</span><span class="hljs-meta">#</span><span class="bash"> 启动</span><span class="hljs-meta">$</span><span class="bash"> docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e <span class="hljs-string">"discovery.type=single-node"</span> elasticsearch:7.7.1</span><span class="hljs-meta">#</span><span class="bash"> 启动就很卡 docker stats 查看 cpu状态</span><span class="hljs-meta">#</span><span class="bash"> 测试完就赶紧停掉，他是非常吃内存的</span><span class="hljs-meta">#</span><span class="bash">修改配置文件 -e 环境配置</span>docker run -d --name elasticsearch02  -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" -e ES_JAVA_OPTS="-Xms64m -Xmx512m" elasticsearch:7.7.1</code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/ES%2BKibana.jpg" srcset="/img/loading.gif" alt></p><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><ul><li>portainer(先使用这)</li></ul><div class="hljs"><pre><code class="hljs shell">docker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</code></pre></div><ul><li>Rancher(CI/CD再用)</li></ul><p><strong>什么是portainer?</strong></p><p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p><div class="hljs"><pre><code class="hljs shell">docker run -d -p 8088:9000 \--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code></pre></div><p>访问测试 ：<a href="http://ip:8088" target="_blank" rel="noopener">http://ip:8088</a></p><ul><li>登录页面</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer%E7%99%BB%E5%BD%95.jpg" srcset="/img/loading.gif" alt="portainer登录"></p><ul><li>进入之后选择local</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer%E9%80%89%E6%8B%A9local.jpg" srcset="/img/loading.gif" alt="portainer选择local"></p><ul><li>进来之后就可以看见我们安装的一些容器，镜像</li></ul><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer01.jpg" srcset="/img/loading.gif" alt="portainer01"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer02.jpg" srcset="/img/loading.gif" alt="portainer02"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/portainer03.jpg" srcset="/img/loading.gif" alt="portainer03"></p><h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><p><code>镜像就是一种轻量级、可执行的独软件包</code>。用来打包软件运行环境和基于运行环境开的软件，它包含运行某个如那件所需要的所有内容，包括代码、运行时库、环境变量和配置文件。</p><p>所有的应用直接打包成docker镜像，就直接跑起来了。</p><p><strong>如何得到镜像：</strong></p><ul><li>从远程仓库下载</li><li>别人拷给你</li><li>自己制作一个DockerFile</li></ul><h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><h2 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h2><blockquote><p>特点</p></blockquote><p>Docker 镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/docker%E9%95%9C%E5%83%8F%E5%88%86%E5%B1%82.jpg" srcset="/img/loading.gif" alt="docker镜像分层"></p><h2 id="如何提交一个自己的镜像commit-镜像"><a href="#如何提交一个自己的镜像commit-镜像" class="headerlink" title="如何提交一个自己的镜像commit 镜像"></a>如何提交一个自己的镜像commit 镜像</h2><div class="hljs"><pre><code class="hljs shell">docker commit 提交容器称为一个新的镜像docker commit -m="提价的描述信息" -a="作者" 容器id 目标镜像名:[tag]</code></pre></div><p><strong>实战测试</strong> </p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动一个默认的tomcat</span><span class="hljs-meta">#</span><span class="bash"> 发现这个默认的tomcat webapps中的文件夹是空的，原因是官方镜像剔除了不必要的文件</span><span class="hljs-meta">#</span><span class="bash"> 将webapps.dist 中的拷贝到webapps中</span><span class="hljs-meta">#</span><span class="bash"> 将我们操作过的镜像通过commit提交为一个镜像</span></code></pre></div><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E6%8F%90%E4%BA%A4%E8%87%AA%E5%B7%B1%E7%9A%84image.jpg" srcset="/img/loading.gif" alt="提交自己的image"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E4%BF%AE%E6%94%B9%E8%BF%87%E7%9A%84image.jpg" srcset="/img/loading.gif" alt="修改过的image"></p><p><img src="https://www.qfeng.online/imgs/docker/docker-leaning/%E5%88%86%E5%B1%82%E6%93%8D%E4%BD%9C.jpg" srcset="/img/loading.gif" alt="分层操作"></p><div class="note note-primary">            <p><strong>到这里 才是入门docker</strong></p>          </div>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot整合Druid</title>
    <link href="/2020/06/05/SpringBoot%E6%95%B4%E5%90%88Druid/"/>
    <url>/2020/06/05/SpringBoot%E6%95%B4%E5%90%88Druid/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot整合Druid"><a href="#Spring-Boot整合Druid" class="headerlink" title="Spring Boot整合Druid"></a>Spring Boot整合Druid</h1><div class="note note-primary">            <p>配置数据源</p>          </div><p><strong>1、添加Druid依赖（新版本有starter）</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>2、在配置文件yml中配置数据源的链接属性</strong></p><blockquote><p>springboot 默认是使用的<code>Hikari</code>数据源,可以通过<code>spring.datasource.type</code> 切换数据源,指定数据源</p></blockquote><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 配置jdbc数据源</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span>    <span class="hljs-comment"># 设置时区 serverTimeZone</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/springcloud?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=UTF-8</span>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span>    <span class="hljs-comment"># 自定义数据源</span>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span>    <span class="hljs-comment">#Spring Boot 默认是不注入这些属性值的，需要自己绑定</span>    <span class="hljs-comment">#druid 数据源专有配置</span>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#配置监控统计拦截的filters，stat:监控统计、log4j：日志记录、wall：防御sql注入</span>    <span class="hljs-comment">#如果允许时报错  java.lang.ClassNotFoundException: org.apache.log4j.Priority</span>    <span class="hljs-comment">#则导入 log4j 依赖即可，Maven 地址：https://mvnrepository.com/artifact/log4j/log4j</span>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall,log4j</span>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span></code></pre></div><p><strong>3、导入log4j的依赖</strong></p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><blockquote><p>在resource下添加log4j配置文件 log4j.properties</p></blockquote><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">DEBUG, stdout</span><span class="hljs-comment"># Console output...</span><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%5p [%t] - %m%n</span></code></pre></div><p><strong>4、自己为DruidDataSource 绑定全局配置文件中的参数，在添加到容器中，不在使用Spring Boot 自动生成了，自己添加DruidDataSources到组件到容器中，并绑定属性</strong></p><div class="note note-primary">            <ol><li><p>配置DruidDataSource数据源</p></li><li><p>配置Druid数据监控</p><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看，类似安装 路由器 时，人家也提供了一个默认的 web 页面。</p><p>所以第一步需要设置 Druid 的后台管理页面，比如 登录账号、密码 等；配置后台管理；</p></li></ol>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yang.sprinngboot.config;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSource;<span class="hljs-keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;<span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<span class="hljs-keyword">import</span> org.springframework.boot.web.servlet.ServletRegistrationBean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> WangYang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020/6/16 13:19</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;    <span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"spring.datasource"</span>)    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">new</span> DruidDataSource();    &#125;    <span class="hljs-comment">//配置 Druid 监控管理后台的Servlet；</span>    <span class="hljs-comment">//内置 Servlet 容器时没有web.xml文件，所以使用 Spring Boot 的注册 Servlet 方式</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">//配置一个servler 并设置映射路径</span>        ServletRegistrationBean bean = <span class="hljs-keyword">new</span> ServletRegistrationBean(<span class="hljs-keyword">new</span> StatViewServlet(),<span class="hljs-string">"/druid/*"</span>);        <span class="hljs-comment">//设置后台的登录账号密码 key是固定的</span>        <span class="hljs-comment">// 这些参数可以在 com.alibaba.druid.support.http.StatViewServlet</span>        <span class="hljs-comment">// 的父类 com.alibaba.druid.support.http.ResourceServlet 中找到</span>        Map&lt;String,String&gt;  initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        initParams.put(<span class="hljs-string">"loginUsername"</span>,<span class="hljs-string">"root"</span>);        initParams.put(<span class="hljs-string">"loginPassword"</span>,<span class="hljs-string">"root"</span>);        <span class="hljs-comment">//后台允许谁可以访问</span>        <span class="hljs-comment">//initParams.put("allow", "localhost")：表示只有本机可以访问</span>        <span class="hljs-comment">//initParams.put("allow", "")：为空或者为null时，表示允许所有访问</span>        initParams.put(<span class="hljs-string">"allow"</span>, <span class="hljs-string">""</span>);        <span class="hljs-comment">//deny：Druid 后台拒绝谁访问</span>        <span class="hljs-comment">//initParams.put("deny", "192.168.1.20");表示禁止此ip访问</span>        <span class="hljs-comment">//设置初始化参数</span>        bean.setInitParameters(initParams);        <span class="hljs-keyword">return</span> bean;    &#125;&#125;</code></pre></div><p>启动Spring Boot后，<code>localhost:8080/druid/login.html</code>登录查看</p><p><img src="https://www.qfeng.online/imgs/Spring-Boot/druid-web-login.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/Spring-Boot/druid-web.jpg" srcset="/img/loading.gif" alt></p><div class="note note-primary">            <p>​    <strong>配置 Druid web 监控 filter 过滤器</strong></p>          </div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//配置 Druid 监控 之  web 监控的 filter</span><span class="hljs-comment">//WebStatFilter：用于配置Web和Druid数据源之间的管理关联监控统计</span><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">webStatFilter</span><span class="hljs-params">()</span> </span>&#123;    FilterRegistrationBean bean = <span class="hljs-keyword">new</span> FilterRegistrationBean();    bean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());    <span class="hljs-comment">//exclusions：设置哪些请求进行过滤排除掉，从而不进行统计</span>    Map&lt;String, String&gt; initParams = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    initParams.put(<span class="hljs-string">"exclusions"</span>, <span class="hljs-string">"*.js,*.css,/druid/*,/jdbc/*"</span>);    bean.setInitParameters(initParams);    <span class="hljs-comment">//"/*" 表示过滤所有请求</span>    bean.setUrlPatterns(Arrays.asList(<span class="hljs-string">"/*"</span>));    <span class="hljs-keyword">return</span> bean;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot完整笔记</title>
    <link href="/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/04/Spring-Boot%E5%AE%8C%E6%95%B4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Spring-Boot-入门"><a href="#一、Spring-Boot-入门" class="headerlink" title="一、Spring Boot 入门"></a>一、Spring Boot 入门</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><blockquote><p>Spring Boot来简化Spring应用开发的框架</p><p>整个Spring技术栈的一个大整合</p><p>J2EE开发的一站式解决方案</p></blockquote><h2 id="2、微服务"><a href="#2、微服务" class="headerlink" title="2、微服务"></a>2、微服务</h2><p>微服务：一种架构风格</p><p>一个应用应该是一组小型服务；可以通过HTTP的方法是进行互通；</p><p>每一个功能元素最终都是一个可独立替换和独立升级的软禁单元；</p><h2 id="3、Hello-World"><a href="#3、Hello-World" class="headerlink" title="3、Hello World"></a>3、Hello World</h2><p>浏览器发送hello请求，服务器接收请求并处理，响应Hello World字符串。</p><h3 id="1、创建一个maven工程"><a href="#1、创建一个maven工程" class="headerlink" title="1、创建一个maven工程"></a>1、创建一个maven工程</h3><h3 id="2、导入Spring相关依赖"><a href="#2、导入Spring相关依赖" class="headerlink" title="2、导入Spring相关依赖"></a>2、导入Spring相关依赖</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><h3 id="3、编写一个主程序，启动Spring应用"><a href="#3、编写一个主程序，启动Spring应用" class="headerlink" title="3、编写一个主程序，启动Spring应用"></a>3、编写一个主程序，启动Spring应用</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//来标注一个主程序类，表示这是一个Spring Boot的应用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Spring 应用启动起来</span>        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><h3 id="4、编写相关的Controller、Service"><a href="#4、编写相关的Controller、Service" class="headerlink" title="4、编写相关的Controller、Service"></a>4、编写相关的Controller、Service</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Spring Boot"</span>;    &#125;&#125;</code></pre></div><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><h3 id="6、简化部署"><a href="#6、简化部署" class="headerlink" title="6、简化部署"></a>6、简化部署</h3><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--简化部署，这个插件可以将应用打包成一个可执行的jar包--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><h2 id="4、Hello-World-分析"><a href="#4、Hello-World-分析" class="headerlink" title="4、Hello World 分析"></a>4、Hello World 分析</h2><h3 id="1、POM"><a href="#1、POM" class="headerlink" title="1、POM"></a>1、POM</h3><h4 id="1、父项目"><a href="#1、父项目" class="headerlink" title="1、父项目"></a>1、父项目</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span></code></pre></div><blockquote><p>​    上面的项目的父项目</p></blockquote><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>在这个项目里面真正管理了Spring Boot应用的所有依赖版本</code></pre></div><blockquote><p>Spring Boot的版本仲裁中心</p><p>以后我们导入项目默认是不需要写版本号的，当然没有在dependencies中管理的依赖还是需要声明版本号的</p></blockquote><h4 id="2、导入的依赖，启动器"><a href="#2、导入的依赖，启动器" class="headerlink" title="2、导入的依赖，启动器"></a>2、导入的依赖，启动器</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>Spring-boot-starter-web</strong></p><p>​        spirng-boot-starter ：spring-boot场景启动器；帮我们导入了web模块正常运行所需要的依赖组件</p><p> Spring Boot将所有的功能场景都抽取出来了，做成了一个个的starter(启动器)，只需要在项目里引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器。</p><h3 id="2、主程序类、主入口类"><a href="#2、主程序类、主入口类" class="headerlink" title="2、主程序类、主入口类"></a>2、主程序类、主入口类</h3><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>  <span class="hljs-comment">//来标注一个主程序类，表示这是一个Spring Boot的应用</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//Spring 应用启动起来</span>        SpringApplication.run(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre></div><p><code>@SpringBootApplication</code> : SpringBootApplication标注在某个类上面，就表示这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动Spring应用 </p><h2 id="5、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#5、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="5、使用Spring Initializer快速创建Spring Boot项目"></a>5、使用Spring Initializer快速创建Spring Boot项目</h2><h1 id="二、Spring-Boot-配置"><a href="#二、Spring-Boot-配置" class="headerlink" title="二、Spring Boot 配置"></a>二、Spring Boot 配置</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><blockquote><p>SpringBoot 使用一个全局的配置文件，配置文件的名是固定的</p></blockquote><p><code>application.properties</code></p><p><code>application.yml</code></p><p>配置文件的作用：修改SpringBoot自动配置的默认值；</p><p>YAML（YANL Ain’t Markup Languge）</p><p>标记语言</p><p>​        以前的配置文件；大多都使用的是 xxx.xml文件；</p><p>​        YAML ：以数据为中心，比json,xml等更加合适做配置文件</p><p>YAML:</p><div class="hljs"><pre><code class="hljs xml">server:  port: 8003</code></pre></div><p>XML:</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>        8003    <span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre></div><h2 id="2、YAML基本语法"><a href="#2、YAML基本语法" class="headerlink" title="2、YAML基本语法"></a>2、YAML基本语法</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><p>k: （空格)v ：表示一对键值对（空格必须有）</p><p>一<strong>空格</strong>的缩进来控制层级关系；只要是左对其的一列数据，都是同一个层级</p><div class="hljs"><pre><code class="hljs xml">serverport: 8081path: /hello</code></pre></div><p><code>属性和值也是大小写敏感的</code></p><h3 id="2、指的写法"><a href="#2、指的写法" class="headerlink" title="2、指的写法"></a>2、指的写法</h3><p><strong>字面量 : 普通的值（数字，字符串，布尔）</strong></p><p>​        k:v ：字面直接来写；</p><p>​                字符串默认不用加上单引号或者双引号</p><p>​                “” : 双引号；会转义转义字符串里面的特殊字符</p><p>​                                name:    “wangyang\n lisi”    输出 wangyang 换行 lisi</p><p>​                ‘’：单引号；不会转义字符串里面的特殊字符，会原样输出字符串中的内容</p><p>​                                name:    “wangyang\n lisi”    输出 wangyang\n lisi</p><p><strong>对象、Map(属性和值) (键值对)</strong></p><p>​        k:    v ： 在下一行来写对象的属性和值的关系；注意缩进</p><p>​                对象还是K : v的方式</p><div class="hljs"><pre><code class="hljs xml">student: name: zhangsanage: 20</code></pre></div><p><strong>行内写法：</strong></p><div class="hljs"><pre><code class="hljs xml">student: &#123;name: zhangsan,age: 20&#125;</code></pre></div><p><strong>数组（List、Set）</strong>    </p><p>值表示数组中的一个元素</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">pets:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span><span class="hljs-bullet">-</span> <span class="hljs-string">dog</span><span class="hljs-bullet">-</span> <span class="hljs-string">pig</span></code></pre></div><p>行内写法</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">pets:</span> <span class="hljs-string">[cat,dog,pig]</span></code></pre></div><h3 id="3、配置文件值注入"><a href="#3、配置文件值注入" class="headerlink" title="3、配置文件值注入"></a>3、配置文件值注入</h3><p>配置文件</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">person:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">wangyang</span>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span>  <span class="hljs-attr">salary:</span> <span class="hljs-number">20000</span>  <span class="hljs-attr">map:</span>    <span class="hljs-attr">k1:</span> <span class="hljs-string">v1</span>    <span class="hljs-attr">k2:</span> <span class="hljs-string">v2</span>  <span class="hljs-attr">list:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">a</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">b</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">c</span>  <span class="hljs-attr">dog:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">hehe</span>    <span class="hljs-attr">age:</span> <span class="hljs-number">3</span></code></pre></div><p>JavaBean</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;        ...getter setter&#125;</code></pre></div><p>可以导入一个配置文件处理器，以后编写配置文件就会有提示了</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="1、properties配置文件在idea中默认utf-8可能会乱码"><a href="#1、properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="1、properties配置文件在idea中默认utf-8可能会乱码"></a>1、properties配置文件在idea中默认utf-8可能会乱码</h4><h4 id="2、-value和ConfigurationProperties获取值比较、Environment"><a href="#2、-value和ConfigurationProperties获取值比较、Environment" class="headerlink" title="2、@value和ConfigurationProperties获取值比较、Environment"></a>2、@value和ConfigurationProperties获取值比较、Environment</h4><p><strong>@value获取配置文件中的值</strong>(简单类型的数据绑定)</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.name&#125;"</span>)<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.age&#125;"</span>)<span class="hljs-keyword">private</span> Integer age;<span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;person.salary&#125;"</span>) <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;</code></pre></div><p><strong>@ConfigurationProperties获取属性值，（批量注入配置文件中的属性）</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;        ...getter setter&#125;</code></pre></div><table><thead><tr><th align="center"></th><th align="center">@ConfigUrationProperties</th><th align="center">@value</th></tr></thead><tbody><tr><td align="center">功能</td><td align="center">批量注入配置文件中的属性</td><td align="center">一个一个注入</td></tr><tr><td align="center">松散绑定</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">SqEl</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">JSR303数据校验</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center"></td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><blockquote><p>如果是在业务逻辑中只需要获取一下配置文件中某项的值那么就使用@Value</p><p>如果我们专门编写了一个javabean来和配置文件映射，我们就直接使用@ConfigurationProperties</p></blockquote><h4 id="3、配置文件注入值校验"><a href="#3、配置文件注入值校验" class="headerlink" title="3、配置文件注入值校验"></a>3、配置文件注入值校验</h4><p><code>使用@ConfigurationProperties获取配置文件值，并校验@Validated写在需要校验的属性上</code></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)<span class="hljs-meta">@Validated</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;   <span class="hljs-comment">//lastName必须是邮箱格式</span>    <span class="hljs-meta">@Email</span>    <span class="hljs-comment">//@Value("$&#123;person.last-name&#125;")</span>    <span class="hljs-keyword">private</span> String lastName;    <span class="hljs-comment">//@Value("#&#123;11*2&#125;")</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">//@Value("true")</span>    <span class="hljs-keyword">private</span> Boolean boss;    <span class="hljs-keyword">private</span> Date birth;    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; maps;    <span class="hljs-keyword">private</span> List&lt;Object&gt; lists;    <span class="hljs-keyword">private</span> Dog dog;</code></pre></div><h4 id="4、-PropertySource-amp-ImportSource"><a href="#4、-PropertySource-amp-ImportSource" class="headerlink" title="4、@PropertySource &amp;@ImportSource"></a>4、@PropertySource &amp;@ImportSource</h4><p><strong>@PropertiesSource</strong> : 加载指定的配置文件</p><blockquote><p><strong>@PropertiesSource</strong> 只能对properties 配置文件进行数据绑定**</p></blockquote><div class="hljs"><pre><code class="hljs prop"># person对象person.name&#x3D;wangyangperson.age&#x3D;18person.salary&#x3D;20000person.map.k1&#x3D;v1person.map.k2&#x3D;v2person.list&#x3D;a,b,cperson.dog.name&#x3D;heheperson.dog.age&#x3D;3</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource</span>(value = <span class="hljs-string">"classpath:person.properties"</span>)<span class="hljs-meta">@Controller</span>   <span class="hljs-comment">//只有这个类是容器中的组件才可以使用容器提供的ConfigurationProperties功能</span><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">"person"</span>)  <span class="hljs-comment">//告诉springboot 将本类中的所有属性和配置文件中相关的配置进行绑定</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; map;    <span class="hljs-keyword">private</span> List list;    <span class="hljs-keyword">private</span>  Dog dog;</code></pre></div><p><strong>@ImportSource</strong> :   导入Spring的配置文件，让配置文件内容生效；</p><blockquote><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别</p><p>需要在主配置类上添加@ImportSource 导入我们编写的Spring的配置类，才能让它生效</p></blockquote><p>Spring Boot 推荐的给容器中添加组件的方式，使用全注解的方式</p><p><code>配置类 === 配置文件</code></p><p>@Configuration 用来表示当前类就是一个配置类</p><p>使用@Bean给容器中添加组件（将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@Configuration</span> : 用来标记 该类是个配置类</span><span class="hljs-comment"> * <span class="hljs-doctag">@Bean</span> : 将方法的返回值，作为bean对象，添加到容器中，方法名就是Bean对象在容器中的id</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> HelloService <span class="hljs-title">helloService</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"配置类@Bean给容器中添加组件"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HelloService();    &#125;&#125;</code></pre></div><h3 id="4、配置文件占位符"><a href="#4、配置文件占位符" class="headerlink" title="4、配置文件占位符"></a>4、配置文件占位符</h3><h4 id="4-1-随机数"><a href="#4-1-随机数" class="headerlink" title="4.1 随机数"></a>4.1 随机数</h4><div class="hljs"><pre><code class="hljs java">$&#123;random.value&#125;、$&#123;random.<span class="hljs-keyword">int</span>&#125;、$&#123;random.<span class="hljs-keyword">long</span>&#125;$&#123;random.<span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>)&#125;、$&#123;random.<span class="hljs-keyword">int</span>[<span class="hljs-number">1024</span>,<span class="hljs-number">65536</span>]&#125;</code></pre></div><h4 id="4-2-占位符获取之前配置的值，如果没有可以通过-：-指定默认值"><a href="#4-2-占位符获取之前配置的值，如果没有可以通过-：-指定默认值" class="headerlink" title="4.2 占位符获取之前配置的值，如果没有可以通过 ： 指定默认值"></a>4.2 占位符获取之前配置的值，如果没有可以通过 ： 指定默认值</h4><div class="hljs"><pre><code class="hljs properties"><span class="hljs-meta">person.name</span>=<span class="hljs-string">wangyang$&#123;random.int&#125;</span><span class="hljs-meta">person.age</span>=<span class="hljs-string">18</span><span class="hljs-meta">person.salary</span>=<span class="hljs-string">20000</span><span class="hljs-meta">person.map.k1</span>=<span class="hljs-string">v1</span><span class="hljs-meta">person.map.k2</span>=<span class="hljs-string">v2</span><span class="hljs-meta">person.list</span>=<span class="hljs-string">a,b,c</span><span class="hljs-meta">person.dog.name</span>=<span class="hljs-string">$&#123;person.name:wang&#125;_hehe</span><span class="hljs-meta">person.dog.age</span>=<span class="hljs-string">3</span></code></pre></div><h3 id="5、profile"><a href="#5、profile" class="headerlink" title="5、profile"></a>5、profile</h3><blockquote><p>多环境配制的支持。</p><p>Profile是Spring对不同环境提供不同配置功能的支持，通过激活、指定参数等方式快速切换环境。</p></blockquote><h4 id="5-1-多profile文件形式"><a href="#5-1-多profile文件形式" class="headerlink" title="5.1     多profile文件形式"></a>5.1     多profile文件形式</h4><p>在主配置文件编写时，文件名可以是 application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h4 id="5-2-yml多文档块方式"><a href="#5-2-yml多文档块方式" class="headerlink" title="5.2    yml多文档块方式"></a>5.2    yml多文档块方式</h4><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8003</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span>    <span class="hljs-attr">active:</span> <span class="hljs-string">test</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8004</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8009</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span> <span class="hljs-comment"># 指定属于哪个环境</span></code></pre></div><h4 id="3-2-激活指定profile"><a href="#3-2-激活指定profile" class="headerlink" title="3.2    激活指定profile"></a>3.2    激活指定profile</h4><ul><li><p>在配置文件中指定<code>spring.profiles.active=dev</code></p></li><li><p>命令行：<code>--spring.profiles.active=dev</code></p><p>​                    <code>java -jar spring-boot-xxxx.jar  --spring.profiles.active=dev</code></p></li><li><p>虚拟机参数：<code>-Dspring.profiles.active=dev</code></p></li></ul><h3 id="6、配置文件加载位置"><a href="#6、配置文件加载位置" class="headerlink" title="6、配置文件加载位置"></a>6、配置文件加载位置</h3><p>spring boot 启动会扫描一下位置的application.properties或者application.yml文件作为spring boot的默认配置文件</p><p>-file:./config/</p><p>-file:./       当前项目的根路径下</p><p>-classpath:/config/</p><p>-classpath:/      类路径下</p><blockquote><p>按照以上优先级从高到低的顺序加载配置文件，高优先级的配置会低优先级的配置</p><p>可以通过配置<code>spring.config.location</code>来改变默认配置</p></blockquote><p>spring boot 会从这四个位置全部加载配置文件：互补配置（相同的配置内容按照优先级的高级覆盖，不同的内容互补）</p><h3 id="7、外部配置加载顺序"><a href="#7、外部配置加载顺序" class="headerlink" title="7、外部配置加载顺序"></a>7、外部配置加载顺序</h3><p><code>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</code></p><p><strong><code>1.命令行参数</code></strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p>==<strong>由jar包外向jar包内进行寻找；</strong>==</p><p>==<strong>优先加载带profile</strong>==</p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p>==<strong>再来加载不带profile</strong>==</p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><h3 id="8、自动配置原理"><a href="#8、自动配置原理" class="headerlink" title="8、自动配置原理"></a>8、自动配置原理</h3><p>配置文件到底能写什么？怎么写？自动配置原理</p><p><a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><p><strong>自动配置原理</strong></p><h2 id="三、SpringBoot与日志"><a href="#三、SpringBoot与日志" class="headerlink" title="三、SpringBoot与日志"></a>三、SpringBoot与日志</h2><h3 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h3><h3 id="2、SLF4j使用"><a href="#2、SLF4j使用" class="headerlink" title="2、SLF4j使用"></a>2、SLF4j使用</h3><h4 id="2-1-如何在系统中使用SLF4j"><a href="#2-1-如何在系统中使用SLF4j" class="headerlink" title="2.1    如何在系统中使用SLF4j"></a>2.1    如何在系统中使用SLF4j</h4><h4 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2 遗留问题"></a>2.2 遗留问题</h4><p>不同框架使用的是不一样的日志框架</p><p>此时统一日志记录，所有框架统一起使用SLF4j进行输出</p><p><strong>如何让系统中的所有日志都统一到SLF4j;</strong></p><ol><li><p>将系统中的其他日志框架先排除出去；（不能只做排除，因为框架的底层还在使用就日志中的类）</p></li><li><p>用中间包来替换原有的日志框架</p></li><li><p>导入slf4j的实现</p></li></ol><h3 id="3、Spring-Boot-日志关系"><a href="#3、Spring-Boot-日志关系" class="headerlink" title="3、Spring Boot 日志关系"></a>3、Spring Boot 日志关系</h3><p><img src="https://www.qfeng.online/imgs/Spring-Boot/springboot-log.jpg" srcset="/img/loading.gif" alt="springboot logging"></p><p>总结：</p><p>​        1)、Spring Boot底层也是使用的slf4j+logback</p><p>​        2)、spring boot  把其他日志都改成了SLF4j</p><p>​        3)、中间转换包</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"rawtypes"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFactory</span> </span>&#123;    <span class="hljs-keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="hljs-string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;    <span class="hljs-keyword">static</span> LogFactory logFactory = <span class="hljs-keyword">new</span> SLF4JLogFactory();</code></pre></div><p><img src="https://www.qfeng.online/imgs/Spring-Boot/slf4j.jpg" srcset="/img/loading.gif" alt></p><p>4)、如果引入其他框架的。一定要把这个框架的默认日志依赖排除掉？</p><p>Spring 框架用的是commons-logging；</p><div class="hljs"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h3 id="4、使用日志"><a href="#4、使用日志" class="headerlink" title="4、使用日志"></a>4、使用日志</h3><p>使用</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//记录器</span>    Logger logger = LoggerFactory.getLogger(getClass());    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//日志级别</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * trace&lt;debug&lt;info&lt;warn&lt;error</span><span class="hljs-comment">         * 由低到高，打印的信息越来越少</span><span class="hljs-comment">         * Spring boot 默认试用的是infO级别的</span><span class="hljs-comment">         */</span>        logger.trace(<span class="hljs-string">"这是trace日志。。。"</span>);        logger.debug(<span class="hljs-string">"这是debug日志。。。"</span>);        logger.info(<span class="hljs-string">"这是info日志。。。"</span>);        logger.warn(<span class="hljs-string">"这是warn日志。。。"</span>);        logger.error(<span class="hljs-string">"这是error日志。。"</span>);    &#125;</code></pre></div><p>日志文件可以在application.properties中配置</p><div class="hljs"><pre><code class="hljs properties"><span class="hljs-comment"># spring boot 默认的日志级别是info,我们自定义设置指定包日志的级别</span><span class="hljs-meta">logging.level.com.yang</span>=<span class="hljs-string">trace</span><span class="hljs-comment"># 设置日志的文件名,默认是在项目的根路径下</span><span class="hljs-meta">logging.file.name</span>=<span class="hljs-string">D:/myLogging</span><span class="hljs-comment"># 设置日志文件的路径</span><span class="hljs-comment"># logging.file.path</span><span class="hljs-comment"># 设置日志在控制台输出的样式</span><span class="hljs-meta">logging.pattern.console</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><span class="hljs-comment"># 设置日志在文件中输出的样式</span><span class="hljs-meta">logging.pattern.file</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></code></pre></div><h4 id="4-2自定义配置"><a href="#4-2自定义配置" class="headerlink" title="4.2自定义配置"></a>4.2自定义配置</h4><p>给类路径下放上每个日志框架自己的配置文件，按照指定的配置名，spring boot就不使用自己默认的配置了</p><table><thead><tr><th align="left">Logging System</th><th align="left">Customization</th></tr></thead><tbody><tr><td align="left">Logback</td><td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td align="left">Log4j2</td><td align="left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td align="left">JDK (Java Util Logging)</td><td align="left"><code>logging.properties</code></td></tr></tbody></table><p>logback.xml: 直接就被日志框架识别了</p><p>logback-spring.xml: 日志框架就能直接加载日志配置文件了，由spring boot解析日志配置，并且可以使用spring boot的高级Profile功能</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"staging"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span>  可以指定某段配置只在某个环境下生效<span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span></code></pre></div><p>如：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"stdout"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span>        <span class="hljs-comment">&lt;!--</span><span class="hljs-comment">        日志输出格式：</span><span class="hljs-comment">%d表示日期时间，</span><span class="hljs-comment">%thread表示线程名，</span><span class="hljs-comment">%-5level：级别从左显示5个字符宽度</span><span class="hljs-comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span><span class="hljs-comment">%msg：日志消息，</span><span class="hljs-comment">%n是换行符</span><span class="hljs-comment">        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">layout</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"!dev"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span></code></pre></div><p>如果使用logback.xml作为日志框架的配置，还要使用Profile功能，就会报错</p><p><code>no applicable action for [springProfile]</code></p><h3 id="5、日志切换"><a href="#5、日志切换" class="headerlink" title="5、日志切换"></a>5、日志切换</h3><p>按照slf4j的日志适配图，进行切换。</p><h2 id="四、Spring-Boot-与Web开发"><a href="#四、Spring-Boot-与Web开发" class="headerlink" title="四、Spring Boot 与Web开发"></a>四、Spring Boot 与Web开发</h2><div class="hljs"><pre><code>### 1、使用Spring Boot</code></pre></div><p>1)    创建Spring Boot 应用，选中我们需要的模块</p><p>2）Spring Boot 已经默认将这么常见配置好了，只需要 在配置文件中配置少量的配置，就可以运行起来</p><p>3）自己编写业务</p><p><strong>自动配置原理</strong></p><p>这个场景spring Boot 帮我们配置了什么? 能不能修改？能修改哪些配置？能不能扩展？</p><div class="hljs"><pre><code class="hljs xml">xxxxxAutoConfiguration: 帮我们给容器自动配置组件xxxxxProperties: 配置类来封装配置文件的内容</code></pre></div><h3 id="2、SpringBoot对静态资源的映射规则"><a href="#2、SpringBoot对静态资源的映射规则" class="headerlink" title="2、SpringBoot对静态资源的映射规则"></a>2、SpringBoot对静态资源的映射规则</h3><p><strong>1）所有/webjars/</strong> ，都去classpath:/META-INF/resources/webjars/找资源**</p><p>可以 ctrl+shift +t 去WebMvcAutoConfiguration类下查看</p><p><code>webjars: 以jar包的方式引入静态资源</code></p><p>在webjars 官网找到项目需要的依赖，在pom文件中引入</p><p><img src="https://www.qfeng.online/imgs/Spring-Boot/webjars.jpg" srcset="/img/loading.gif" alt></p><p>访问路径 <a href="http://localhost:8080/webjars/jquery/3.5.1/jquery.js" target="_blank" rel="noopener">http://localhost:8080/webjars/jquery/3.5.1/jquery.js</a></p><div class="hljs"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p><strong>2）”/“ 访问当前项目的任何资源，（静态文件的文件夹）</strong></p><div class="hljs"><pre><code class="hljs xml">“classpath：/META-INF/resources/”"calsspath：/rescources/""classpath：/static/""classpath: /public/""/": 当前项目的根路径</code></pre></div><p>导入准备好的静态资源到static文件夹下 clean一下就可以访问到<a href="http://localhost:8080/asserts/js/Chart.min.js" target="_blank" rel="noopener">http://localhost:8080/asserts/js/Chart.min.js</a></p><p><strong>3）欢迎页：静态资源文件下的所有index.htm，被”/</strong>“ 映射**</p><p><code>localhost:8080/ 找index页面</code></p><p><strong>4) 所有的**</strong>/favicon.ico 都在静态资源文件下找**</p><p>没有出现图标执行 Ctrl + f5 刷新浏览器页面就出现了</p><h3 id="3、模板引擎"><a href="#3、模板引擎" class="headerlink" title="3、模板引擎"></a>3、模板引擎</h3><p><img src="https://www.qfeng.online/imgs/Spring-Boot/thymeleaf.jpg" srcset="/img/loading.gif" alt></p><p>Spring Boot 推荐 thymeleaf</p><h4 id="3-1-引入thymeleaf"><a href="#3-1-引入thymeleaf" class="headerlink" title="3.1    引入thymeleaf"></a>3.1    引入thymeleaf</h4><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入thymeleaf--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><h4 id="3-2-Thymeleaf-使用"><a href="#3-2-Thymeleaf-使用" class="headerlink" title="3.2    Thymeleaf 使用"></a>3.2    Thymeleaf 使用</h4><blockquote><p>只需要将HTML页面放在classpath:/templates/，thymeleaf就能自动渲染</p></blockquote><p>使用：</p><h5 id="1、导入thymeleaf的名称空间"><a href="#1、导入thymeleaf的名称空间" class="headerlink" title="1、导入thymeleaf的名称空间"></a>1、导入thymeleaf的名称空间</h5><div class="hljs"><pre><code class="hljs html">xmlns:th="http://www.thymeleaf.org"</code></pre></div><h5 id="2、使用thymeleaf语法；"><a href="#2、使用thymeleaf语法；" class="headerlink" title="2、使用thymeleaf语法；"></a>2、使用thymeleaf语法；</h5><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">"http://www.thymeleaf.org"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>使用thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-comment">&lt;!--th:text将div中的内容设置为java代码绑定的数据--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">"$&#123;hello&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h5 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h5><p>1）、th:text    改变元素中的内容</p><p><code>使用th:html任意属性来替换原生属性的值</code></p><h5 id="2）、表达式"><a href="#2）、表达式" class="headerlink" title="2）、表达式"></a>2）、表达式</h5><table><thead><tr><th align="center">语法</th><th align="center">名称</th><th align="center">描述</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">${…}</td><td align="center">Variable Expressions</td><td align="center">变量表达式</td><td align="center">取出上下文变量的值</td></tr><tr><td align="center">*{…}</td><td align="center">Selection Variable Expressions</td><td align="center">选择变量表达式</td><td align="center">取出选择的对象的属性值</td></tr><tr><td align="center">#{…}</td><td align="center">Message Expressions</td><td align="center">消息表达式</td><td align="center">使文字消息国际化，I18N</td></tr><tr><td align="center">@{…}</td><td align="center">Link URL Expressions</td><td align="center">链接表达式</td><td align="center">用于表示各种超链接地址</td></tr><tr><td align="center">~{…}</td><td align="center">Fragment Expressions</td><td align="center">片段表达式</td><td align="center">引用一段公共的代码片段</td></tr></tbody></table><h3 id="4-Spring-MVC的自动配置"><a href="#4-Spring-MVC的自动配置" class="headerlink" title="4.Spring MVC的自动配置"></a>4.Spring MVC的自动配置</h3><h4 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h4><p>Spring Boot 自动配置好了SpringMVC</p><p>以下是SpringBoot对SpringMVC的默认配置:<strong>==（WebMvcAutoConfiguration）==</strong></p><ul><li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p><ul><li>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</li><li>ContentNegotiatingViewResolver：组合所有的视图解析器的；</li><li>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</li></ul></li><li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p></li><li><p>Static <code>index.html</code> support. 静态首页访问</p></li><li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p></li></ul><ul><li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p><ul><li>Converter：转换器；  public String hello(User user)：类型转换使用Converter</li><li><code>Formatter</code>  格式化器；  2017.12.17===Date；</li></ul></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">"spring.mvc"</span>, name = <span class="hljs-string">"date-format"</span>)<span class="hljs-comment">//在文件中配置日期格式化的规则</span><span class="hljs-function"><span class="hljs-keyword">public</span> Formatter&lt;Date&gt; <span class="hljs-title">dateFormatter</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DateFormatter(<span class="hljs-keyword">this</span>.mvcProperties.getDateFormat());<span class="hljs-comment">//日期格式化组件</span>&#125;</code></pre></div><p>​    ==自己添加的格式化器转换器，我们只需要放在容器中即可==</p><ul><li><p>Support for <code>HttpMessageConverters</code> (see below).</p><ul><li><p>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User—Json；</p></li><li><p><code>HttpMessageConverters</code> 是从容器中确定；获取所有的HttpMessageConverter；</p><p>==自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中（@Bean,@Component）==</p></li></ul></li></ul><ul><li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p></li><li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p><p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p><div class="hljs"><pre><code class="hljs diff">初始化WebDataBinder；请求数据<span class="hljs-comment">=====JavaBean；</span></code></pre></div></li></ul><p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p><p>If you want to keep Spring Boot MVC features, and you just want to add additional <a href="https://docs.spring.io/spring/docs/4.3.14.RELEASE/spring-framework-reference/htmlsingle#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers etc.) you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurerAdapter</code>, but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code> or <code>ExceptionHandlerExceptionResolver</code> you can declare a <code>WebMvcRegistrationsAdapter</code> instance providing such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p><h4 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h4><blockquote><p><strong>1.0的是继承WebMvcConfigurerAdapter类</strong></p><p><strong>2.0+是实现WebMvcConfigurer接口</strong></p></blockquote><div class="hljs"><pre><code class="hljs xm">&lt;mvc:view-controller path&#x3D;&quot;&#x2F;hello&quot; view-name&#x3D;&quot;success&quot;&#x2F;&gt;    &lt;mvc:interceptors&gt;        &lt;mvc:interceptor&gt;            &lt;mvc:mapping path&#x3D;&quot;&#x2F;hello&quot;&#x2F;&gt;            &lt;bean&gt;&lt;&#x2F;bean&gt;        &lt;&#x2F;mvc:interceptor&gt;    &lt;&#x2F;mvc:interceptors&gt;</code></pre></div><p><code>编写一个配置类（@Configuration）,是WebMvcConfigurer类型；不能标注@EnableWebMvc</code></p><p>既保留了所有的自动配置，也能用我们的扩展配置</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//添加自定义的视图解析器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送/he请求到success页面</span>        registry.addViewController(<span class="hljs-string">"/he"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>​    1）、WebMvcAutoConfiguration是SpringMVC的自动配置类</p><p>​    2）、在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p><div class="hljs"><pre><code class="hljs java">   <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite(); <span class="hljs-comment">//从容器中获取所有的WebMvcConfigurer</span>     <span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;         <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;             <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);           <span class="hljs-comment">//一个参考实现；将所有的WebMvcConfigurer相关配置都来一起调用；  </span>           <span class="hljs-meta">@Override</span>            <span class="hljs-comment">// public void addViewControllers(ViewControllerRegistry registry) &#123;</span>             <span class="hljs-comment">//    for (WebMvcConfigurer delegate : this.delegates) &#123;</span>              <span class="hljs-comment">//       delegate.addViewControllers(registry);</span>              <span class="hljs-comment">//   &#125;</span>             &#125;         &#125;&#125;</code></pre></div><p>​    3）、容器中所有的WebMvcConfigurer都会一起起作用；</p><p>​    4）、我们的配置类也会被调用；</p><p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p><h4 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h4><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p><p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><span class="hljs-meta">@EnableWebMvc</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;       <span class="hljs-comment">// super.addViewControllers(registry);</span>        <span class="hljs-comment">//浏览器发送 /atguigu 请求来到 success</span>        registry.addViewController(<span class="hljs-string">"/atguigu"</span>).setViewName(<span class="hljs-string">"success"</span>);    &#125;&#125;</code></pre></div><p>原理：</p><p>为什么@EnableWebMvc自动配置就失效了；</p><p>1）@EnableWebMvc的核心</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Import</span>(DelegatingWebMvcConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> @<span class="hljs-title">interface</span> <span class="hljs-title">EnableWebMvc</span> </span>&#123;</code></pre></div><p>2）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;</code></pre></div><p>3）、</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-meta">@ConditionalOnWebApplication</span><span class="hljs-meta">@ConditionalOnClass</span>(&#123; Servlet<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">DispatcherServlet</span>.<span class="hljs-title">class</span>,</span><span class="hljs-class"><span class="hljs-title">WebMvcConfigurerAdapter</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class">//容器中没有这个组件的时候，这个自动配置类才生效</span><span class="hljs-class">@<span class="hljs-title">ConditionalOnMissingBean</span>(<span class="hljs-title">WebMvcConfigurationSupport</span>.<span class="hljs-title">class</span>)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureOrder</span>(<span class="hljs-title">Ordered</span>.<span class="hljs-title">HIGHEST_PRECEDENCE</span> + 10)</span><span class="hljs-class">@<span class="hljs-title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span><span class="hljs-class"><span class="hljs-title">ValidationAutoConfiguration</span>.<span class="hljs-title">class</span> &#125;)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;</code></pre></div><p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p><p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p><h3 id="5、如何修改SpringBoot的默认配置"><a href="#5、如何修改SpringBoot的默认配置" class="headerlink" title="5、如何修改SpringBoot的默认配置"></a>5、如何修改SpringBoot的默认配置</h3><p>只需要把要修改的配置添加到容器中，就能被spring boot 使用到</p><p>模式：</p><p>1）Sprig Boot 在自动配置很多组件的时候，先看容器中有没有用户配置的（@Bean、@Component）如果有就使用用户配置的，没有，才自动配置；有些 组件还可以有多个（比如viewResolver）将用户的配置和自己的默认配置组合起来。</p><p> 2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p><p>3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p><h3 id="6、RestfulCRUD"><a href="#6、RestfulCRUD" class="headerlink" title="6、RestfulCRUD"></a>6、RestfulCRUD</h3><p>准备工作：将静态资源导入工程中。引入需要的webjars，修改模板文件的引用地址。</p><h4 id="1、默认访问首页"><a href="#1、默认访问首页" class="headerlink" title="1、默认访问首页"></a>1、默认访问首页</h4><blockquote><p>可以直接在Controller中写映射，也可以在配置类中定义</p></blockquote><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-comment">//添加自定义的视图解析器</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送/he请求到success页面</span>        registry.addViewController(<span class="hljs-string">"/he"</span>).setViewName(<span class="hljs-string">"success"</span>);        <span class="hljs-comment">//默认访问登录页面</span>        registry.addViewController(<span class="hljs-string">"/"</span>).setViewName(<span class="hljs-string">"login"</span>);        registry.addViewController(<span class="hljs-string">"/login.html"</span>).setViewName(<span class="hljs-string">"login"</span>);    &#125;&#125;</code></pre></div><h4 id="2、国际化"><a href="#2、国际化" class="headerlink" title="2、国际化"></a>2、国际化</h4><h5 id="1）、编写国际化配置文件"><a href="#1）、编写国际化配置文件" class="headerlink" title="1）、编写国际化配置文件"></a>1）、编写国际化配置文件</h5><h5 id="2）、使用ResourceBundleMessage管理国际化资源文件"><a href="#2）、使用ResourceBundleMessage管理国际化资源文件" class="headerlink" title="2）、使用ResourceBundleMessage管理国际化资源文件"></a>2）、使用ResourceBundleMessage管理国际化资源文件</h5><h5 id="3）、在页面中使用ftm-message取出国际化内容"><a href="#3）、在页面中使用ftm-message取出国际化内容" class="headerlink" title="3）、在页面中使用ftm:message取出国际化内容"></a>3）、在页面中使用ftm:message取出国际化内容</h5><p>步骤：</p><h5 id="1）、编写国际化配置文件，抽取页面需要显示的国际化信息"><a href="#1）、编写国际化配置文件，抽取页面需要显示的国际化信息" class="headerlink" title="1）、编写国际化配置文件，抽取页面需要显示的国际化信息"></a>1）、编写国际化配置文件，抽取页面需要显示的国际化信息</h5>]]></content>
    
    
    <categories>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Health思路</title>
    <link href="/2020/05/31/Health%E6%80%9D%E8%B7%AF/"/>
    <url>/2020/05/31/Health%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="Health总结"><a href="#Health总结" class="headerlink" title="Health总结"></a>Health总结</h1><h2 id="会员统计"><a href="#会员统计" class="headerlink" title="会员统计"></a>会员统计</h2><p>设计年龄段，0-6岁为婴儿，7-12岁为少儿，13-17岁为青少年，18-45岁为青年、46-69岁为中年、&gt;69岁为老年，为达到一目了然各个年龄段的人数高低，选择柱状图展示。</p><blockquote><p><strong>心得</strong></p><p>使用ECharts很容易达到效果，使用时我们不需要关系样式怎么设置，直接去<a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">ECharts官网</a>找到合适的案例，粘贴到页面上即可。重要的是根据案例中的数据，构造出合适的数据模型动态的赋值。</p></blockquote><h4 id="前端调用实现"><a href="#前端调用实现" class="headerlink" title="前端调用实现"></a>前端调用实现</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span>        <span class="hljs-keyword">var</span> myChart1 = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'chart1'</span>));        axios.get(<span class="hljs-string">"/report/getMemberAgeReport.do"</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;            <span class="hljs-comment">// 指定图表的配置项和数据</span>            myChart1.setOption(                &#123;                    title: &#123;                        text: <span class="hljs-string">'会员年龄分布统计'</span>                    &#125;,                    tooltip: &#123;&#125;,                    legend: &#123;                        data:[<span class="hljs-string">'年龄段人数'</span>]                    &#125;,                    xAxis: &#123;                        data: res.data.data.ageStages                    &#125;,                    yAxis: &#123;&#125;,                    series: [&#123;                        name: <span class="hljs-string">'年龄段人数'</span>,                        type: <span class="hljs-string">'bar'</span>,                        data: res.data.data.ageCountNum                    &#125;]                &#125;                );        &#125;);</code></pre></div><h4 id="后台逻辑"><a href="#后台逻辑" class="headerlink" title="后台逻辑"></a>后台逻辑</h4><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/getMemberAgeReport"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">getMemberAgeReport</span><span class="hljs-params">()</span> </span>&#123;        List&lt;Map&lt;String,Object&gt;&gt; ageStagesMapList = memberService.findMemberCountByBirthdy();        Map&lt;String, Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        List&lt;String&gt; ageStages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();               <span class="hljs-comment">//纵坐标数据,统计每个年龄段的人数</span>        List&lt;Long&gt; ageCountNum = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">if</span>(ageStagesMapList != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">for</span> (Map&lt;String, Object&gt; stringObjectMap : ageStagesMapList) &#123;                <span class="hljs-comment">//拿到map集合&#123;name=青少年, num=12&#125;</span>                String str = (String) stringObjectMap.get(<span class="hljs-string">"name"</span>);                <span class="hljs-comment">//年龄段表示字段 x</span>                ageStages.add(str);                Long value = (Long) stringObjectMap.get(<span class="hljs-string">"num"</span>);                <span class="hljs-comment">//年龄段的值 y</span>                ageCountNum.add(value);            &#125;            <span class="hljs-comment">//将横纵坐标的list 接入map 集合</span>            data.put(<span class="hljs-string">"ageStages"</span>, ageStages);            data.put(<span class="hljs-string">"ageCountNum"</span>,ageCountNum);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">true</span>, <span class="hljs-string">"查询成功"</span>, data);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-keyword">false</span>, <span class="hljs-string">"查询失败"</span>);    &#125;</code></pre></div><div class="hljs"><pre><code>#### SQL</code></pre></div><div class="hljs"><pre><code class="hljs mysql">&lt;select id&#x3D;&quot;findMemberCountByBirthdy&quot; resultType&#x3D;&quot;map&quot;&gt;        SELECT t.name,COUNT(1) as num FROM (SELECT  CASE        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt; 0 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;  6  THEN &#39;婴幼儿&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;7 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   12  THEN &#39;少儿&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;13 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   17  THEN &#39;青少年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;18 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   45  THEN &#39;青年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;46 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   69  THEN &#39;中年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;79 AND ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&lt;   89  THEN &#39;老年&#39;        WHEN  ROUND(DATEDIFF(CURDATE(), birthday)&#x2F;365.2422)&gt;&#x3D;90 THEN &#39;90以上&#39;        ELSE &#39;未知&#39; END as name FROM t_member) as t GROUP BY t.name;    &lt;&#x2F;select&gt;</code></pre></div><blockquote><p><img src="http://www.qfeng.online/imgs/test-02.PNG" srcset="/img/loading.gif" alt><strong>SQL分析</strong></p><p>年龄采取四舍五入的方式，如出生日期2018-08-02，如果今天是2018-09-01差一天满，将处理为1岁显示。</p><p>如果不需要四舍五入则使用： <code>TIMESTAMPDIFF(YEAR, @birthday, CURDATE())</code></p><p>round():     函数 用于四舍五入。</p><p>DATEDIFF()：返回两个日期之间的天数。</p><p>CURDATE() 函数返回当前的日期。</p><p>注意大于号和小于号在mybatis 中转义，不转义会和标签的 &lt;&gt;混淆。</p></blockquote><blockquote><p>​    需要分析的sql</p><p>统计会员年龄分布sql ： findMemberCountByBirthdy</p></blockquote><div class="hljs"><pre><code class="hljs md">&#123;% note success %&#125;文字 或者 <span class="hljs-code">`markdown`</span> 均可&#123;% endnote %&#125;</code></pre></div><p><a href="http://www.qfeng.online/imgs/test-02.PNG" target="_blank" rel="noopener">http://www.qfeng.online/imgs/test-02.PNG</a></p><p class="class note-success">法发大水发生发放</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx</title>
    <link href="/2020/05/20/Nginx/"/>
    <url>/2020/05/20/Nginx/</url>
    
    <content type="html"><![CDATA[<h1 id="1、Nginx基本概念"><a href="#1、Nginx基本概念" class="headerlink" title="1、Nginx基本概念"></a>1、Nginx基本概念</h1><h2 id="Nginx-是什么"><a href="#Nginx-是什么" class="headerlink" title="Nginx 是什么"></a>Nginx 是什么</h2><p>Nginx是一个高性能的Http和反向代理服务器，特点是占有内存少，并发能力强，事实上Nginx的并发能力确实是在同类型的网页服务器中表现较好</p><p>Nginx能支持高达50000个并发连接数。</p><ul><li>常用命令</li></ul><table><thead><tr><th align="center">操作</th><th align="center">命令</th></tr></thead><tbody><tr><td align="center">启动</td><td align="center">./nginx</td></tr><tr><td align="center">停止</td><td align="center">./nginx -s stop  或者pkill -9 nginx</td></tr><tr><td align="center">重启</td><td align="center">./nginx -s reload</td></tr><tr><td align="center">查看版本信息</td><td align="center">./nginx  -v</td></tr></tbody></table><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><ul><li>在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问。</li></ul><p><img src="https://www.qfeng.online/imgs/nginx/nginx-2020-06-18_20-10-04.jpg" srcset="/img/loading.gif" alt></p><h3 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a><code>反向代理</code></h3><p>我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><p><img src="https://www.qfeng.online/imgs/nginx/nginx-2020-06-18_20-32-30.jpg" srcset="/img/loading.gif" alt></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>将请求分发到各个服务器上，原先请求集中到单个服务器上的情况改为请求分发到多个服务器，将负载分发到不同的服务器，也就是所说的负载均衡。</p><p><img src="https://www.qfeng.online/imgs/nginx/nginx-2020-06-19_08-54-46.jpg" srcset="/img/loading.gif" alt></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>为了加快网站的解析速度，可以把动态页面和静态页面又不同的服务器解析，加快解析速度。降低单个服务器的压力。</p><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-19_22-36-27.jpg" srcset="/img/loading.gif" alt></p><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-19_22-38-46.jpg" srcset="/img/loading.gif" alt></p><h1 id="2、安装Nginx、常用命令和配置文件"><a href="#2、安装Nginx、常用命令和配置文件" class="headerlink" title="2、安装Nginx、常用命令和配置文件"></a>2、安装Nginx、常用命令和配置文件</h1><p>1.这为了安装方便快捷，使用了docker,在docker中启动了个nginx容器。关于docker可以去我的博客查看详细的步骤：</p><p><a href="https://wangyang-y.github.io/2020/06/07/Docker%E5%9F%BA%E7%A1%80/" target="_blank" rel="noopener">Docker运行Nginx</a></p><p>注意：要么关闭防火墙</p><p>要么设置开放的端口</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看开发的端口号</span>firewall-cmd --list-all<span class="hljs-meta">#</span><span class="bash"> 设置开放的端口号</span>firewall-cmd --add-service=http -permanentsudo firewall-cmd --add-port=80/tcp --permanent<span class="hljs-meta">#</span><span class="bash"> 重启防火墙</span>firewall-cmd --reload</code></pre></div><h2 id="在linux系统中安装Nginx"><a href="#在linux系统中安装Nginx" class="headerlink" title="在linux系统中安装Nginx"></a>在linux系统中安装Nginx</h2><h2 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h2><blockquote><p>使用nginx操作命令必须进入nginx目录</p><p><code>/usr/local/nginx/sbin</code></p></blockquote><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1.使用nginx 前提必须进入nginx目录</span>cd /usr/local/nginx/sbin<span class="hljs-meta">#</span><span class="bash"> 2.查看nginx 版本号</span>./nginx -v<span class="hljs-meta">#</span><span class="bash"> 3.启动nginx</span>./nginx<span class="hljs-meta">#</span><span class="bash"> 4.关闭ngixn</span>./nginx -s stop<span class="hljs-meta">#</span><span class="bash"> 重新加载nginx(修改了配置文件，不需要停止再启动配置文件，直接重新加载nginx就生效了)</span>./nginx -s  reload</code></pre></div><h2 id="nginx-配置文件"><a href="#nginx-配置文件" class="headerlink" title="nginx 配置文件"></a>nginx 配置文件</h2><p>配置文件有三部分组成</p><ul><li>全局块</li></ul><p>从配置文件开始到events 块之间的内容，主要设置一些影响nginx服务器整体运行的配置指令</p><p>比如 <code>worker_process 1</code> worker_process 值越大，可以支持的并发处理量越大</p><ul><li>events块</li></ul><p>events 块涉及的指令主要影响ngixn服务器与用户的网络连接</p><p>比如<code>worker_connections 1024</code>; 支持的最大连接数</p><ul><li>http块</li></ul><p>nginx服务器配置中最频繁的部分</p><p>​    </p><h1 id="3、nginx配置实例1-反向代理"><a href="#3、nginx配置实例1-反向代理" class="headerlink" title="3、nginx配置实例1-反向代理"></a>3、nginx配置实例1-反向代理</h1><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-20_00-30-39.jpg" srcset="/img/loading.gif" alt></p><blockquote><p>DNS解析先是在我们自己的hosts找看有没有对应的ip ,如果没有再去网络中解析</p></blockquote><div class="note note-primary">            <p><strong>第一步要在windows的hosts 文件里配置dns解析 <a href="http://www.wangy.com" target="_blank" rel="noopener">www.wangy.com</a>  192.168.255.128</strong></p>          </div><ul><li>安装tomcat 在tomcat的bin目录下，通过<code>./startup.sh</code>启动tomcat</li></ul><p>linux上的端口默认是没有开放的，我们需要手动设置要开放的端口</p><blockquote><p>查看已经开放的端口号</p></blockquote><ul><li><code>firewall-cmd --list-all</code></li></ul><blockquote><p>对外开放访问端口</p><p>偷懒的话直接关闭防火墙</p></blockquote><p><code>firewall-cmd -add-port=8080/tcp --permanent</code></p><p><code>firewall-cmd --reload</code></p><blockquote><p>通过windows的浏览器访问tomcat查看是否放完成功</p></blockquote><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-20_14-08-28.jpg" srcset="/img/loading.gif" alt></p><ul><li>nginx.conf配置文件的修改</li></ul><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-20_14-23-25.jpg" srcset="/img/loading.gif" alt></p><ul><li>修改了配置文件，重新载入配置文件</li></ul><div class="hljs"><pre><code class="hljs shell">./nginx -s reload</code></pre></div><ul><li>在浏览器中访问<a href="http://www.wangy.com" target="_blank" rel="noopener">www.wangy.com</a></li></ul><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-20_14-30-22.jpg" srcset="/img/loading.gif" alt></p><h2 id="3-2-反向代理实例2"><a href="#3-2-反向代理实例2" class="headerlink" title="3.2 反向代理实例2"></a>3.2 反向代理实例2</h2><h3 id="3-2-1-实现需求"><a href="#3-2-1-实现需求" class="headerlink" title="3.2.1    实现需求"></a>3.2.1    实现需求</h3><p>使用nginx反向代理，根据访问的路径跳转到不同的服务器中</p><p>nginx 监听端口为 9001</p><p>访问 <a href="http://192.168.255.128:9001/dev/" target="_blank" rel="noopener">http://192.168.255.128:9001/dev/</a> 直接跳转到192.168.255.128:8081</p><p>访问 <a href="http://192.168.255.128:9001/test/" target="_blank" rel="noopener">http://192.168.255.128:9001/test/</a> 直接跳转到</p><p>192.168.255.128:8082</p><h3 id="3-2-2-环境准备"><a href="#3-2-2-环境准备" class="headerlink" title="3.2.2     环境准备"></a>3.2.2     环境准备</h3><p>1)    准备两个tomcat服务器，一个8081端口，一个8082端口(注意修改server.xml中的端口号)</p><p>2)    创建文件夹和测试页面  server {<br>        listen       9001;<br>        # listen       somename:8080;<br>        server_name    192.168.255.128;</p><div class="hljs"><pre><code>    location ~ /dev/ {        root   html;        proxy_pass   http://192.168.255.128:8081;            index  index.html index.htm;    }    location ~ /test/ {        root   html;        proxy_pass   http://192.168.255.128:8082;            index  index.html index.htm;    }    }</code></pre></div><p>3）在nginx.conf文件中配置</p><div class="hljs"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;      <span class="hljs-attribute">listen</span>       <span class="hljs-number">9001</span>;      <span class="hljs-attribute">server_name</span><span class="hljs-number">192.168.255.128</span>;      <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /dev/</span> &#123;          <span class="hljs-attribute">root</span>   html;          <span class="hljs-attribute">proxy_pass</span>   http://192.168.255.128:8081;          <span class="hljs-attribute">index</span>  index.html index.htm;       &#125;      <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ /test/</span> &#123;          <span class="hljs-attribute">root</span>   html;          <span class="hljs-attribute">proxy_pass</span>   http://192.168.255.128:8082;          <span class="hljs-attribute">index</span>  index.html index.htm;       &#125;  &#125;</code></pre></div><h1 id="4、nginx配置实例2-负载均衡"><a href="#4、nginx配置实例2-负载均衡" class="headerlink" title="4、nginx配置实例2-负载均衡"></a>4、nginx配置实例2-负载均衡</h1><h3 id="4-1-实现效果"><a href="#4-1-实现效果" class="headerlink" title="4.1 实现效果"></a>4.1 实现效果</h3><p>1)    首先准备两个同时启动的Tomcat</p><p>2）在nginx.conf中进行配置</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 在server 外边配置 upstream</span>upstream myServer&#123;server 192.168.255.128:8081 weight 10;server 192.168.255.128:8082 weight 10;        &#125;<span class="hljs-meta">#</span><span class="bash"> server 里面</span>        location / &#123;            root   html;    # proxy_passhttp://192.168.255.128:8080;    proxy_passhttp://myserver;            index  index.html index.htm;        &#125;</code></pre></div><blockquote><p><strong>Nginx中提供了几种分配策略</strong></p><p>1、<code>轮询（默认）</code></p><p>​        每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><p>2、<code>weight 权重</code></p><p>​        weight代表权重，默认是1，权重越高被分配的客户端越多</p><p>upstream server_pool {</p><p>ip_hash</p><p>server 192.168.255.128:8080 weight 10;</p><p>server 192.168.255.129:8080 weight 10;</p><p>}</p><p>3、<code>ip_hash</code></p><p>​        每个请求按照访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p><p>upstream server_pool {</p><p>ip_hash</p><p>server 192.168.255.128:8080;</p><p>server 192.168.255.129:8080;</p><p>}</p><p>4 、<code>fair（第三方）</code></p><p>​        按照后台服务器的响应时间来分配，响应时间短的优先分配。</p><p>upstream server_pool {</p><p>fair</p><p>server 192.168.255.128:8080;</p><p>server 192.168.255.129:8080;</p><p>}</p></blockquote><h1 id="5、nginx-配置实例3-动静分离"><a href="#5、nginx-配置实例3-动静分离" class="headerlink" title="5、nginx 配置实例3-动静分离"></a>5、nginx 配置实例3-动静分离</h1><h3 id="5-1-动静分离概念"><a href="#5-1-动静分离概念" class="headerlink" title="5.1  动静分离概念"></a>5.1  动静分离概念</h3><p>动静分离简单来说就是把动态跟静态请求分开，不要理解成只是单纯的将动态页面和静态页面物理分离。</p><p>动静分离目前实现来说大致分为<strong>两种</strong>，①<code>一种是直接把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流的推荐的方案</code>。②<code>另外一种方法就是动态跟静态文件混合在一起发布，通过Nginx来分开，通过location指定不同的后缀名实现不同的请求转发</code>。通过expires参数设置，可以在浏览器缓存过期时间，减少与服务器之间的请求和流量（发送一个请求对比服务器该文件最后更新时间，没有变化就不会从服务器抓取返回304）。缓存304   服务器重新下载，返回状态码200。资源经常发生变化，不建议使用。</p><p><img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-21_13-27-58.jpg" srcset="/img/loading.gif" alt></p><h3 id="5-2-具体配置"><a href="#5-2-具体配置" class="headerlink" title="5.2 具体配置"></a>5.2 具体配置</h3><p>在nignx.conf中进行配置</p><div class="hljs"><pre><code class="hljs shell">server&#123;listen    80;server_name     192.168.255.128;location /www/&#123;root /data/;index index.html index.htm;&#125;location /image/&#123;root /data/;autoindex on;&#125;&#125;</code></pre></div><h1 id="6、nginx配置高可用的集群"><a href="#6、nginx配置高可用的集群" class="headerlink" title="6、nginx配置高可用的集群"></a>6、nginx配置高可用的集群</h1><h3 id="6-1-高可用"><a href="#6-1-高可用" class="headerlink" title="6.1 高可用"></a>6.1 高可用</h3><p>一台nginx宕机了，请求还能成功响应，就是高可用。配置高可用，使用虚拟ip 和keepalived实现    当主服务器挂掉了，备份服务器就顶上去。<img src="https://www.qfeng.online/imgs/nginx/nginx_2020-06-21_16-06-01.jpg" srcset="/img/loading.gif" alt></p><ul><li>在两台装上linux，都装上keepalived</li></ul><div class="hljs"><pre><code class="hljs shell">yum install keepalived -y</code></pre></div><ul><li>安装完keepalived后，将keepalived的配置放到 /etc/keepalived 目录下</li></ul><blockquote><p>keepalive文件</p></blockquote><ul><li>在 /usr/local/src下添加脚本文件</li></ul><ul><li><strong>总结：   提供两台服务器，主服务器和备份服务器，都装上keepalived 和nginx 绑定了虚拟ip,虚拟ip就是对外访问的ip,正常情况下都是访问的主服务器，当主服务器宕机了，keepalived通过脚本会检查到，给我们切换到备份服务器。</strong></li></ul><h1 id="7、nginx执行原理"><a href="#7、nginx执行原理" class="headerlink" title="7、nginx执行原理"></a>7、nginx执行原理</h1>]]></content>
    
    
    <categories>
      
      <category>Linux&amp;Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下安装jdk</title>
    <link href="/2020/05/20/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/"/>
    <url>/2020/05/20/linux%E4%B8%8B%E5%AE%89%E8%A3%85jdk/</url>
    
    <content type="html"><![CDATA[<h3 id="一、下载jdk"><a href="#一、下载jdk" class="headerlink" title="一、下载jdk"></a>一、下载jdk</h3><p>下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Oracle官网</a></p><p>选择下载tar包</p><h3 id="二、卸载已有jdk"><a href="#二、卸载已有jdk" class="headerlink" title="二、卸载已有jdk"></a>二、卸载已有jdk</h3><p>1、查看已安装jdk <code>rpm -qa | grep java</code></p><div class="hljs"><pre><code class="hljs shell">[root@slave1 sbin]# rpm -qa | grep javajavapackages-tools-3.4.1-11.el7.noarchjava-1.8.0-openjdk-1.8.0.242.b08-1.el7.x86_64tzdata-java-2019c-1.el7.noarchjava-1.8.0-openjdk-headless-1.8.0.242.b08-1.el7.x86_64java-1.7.0-openjdk-1.7.0.251-2.6.21.1.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.251-2.6.21.1.el7.x86_64python-javapackages-3.4.1-11.el7.noarch</code></pre></div><p>2、卸载已有的jdk</p><p><code>rpm -e --nodeps javapackages-tools-3.4.1-11.el7.noarch</code></p><div class="hljs"><pre><code class="hljs shell">[root@slave1 sbin]# rpm -e --nodeps javapackages-tools-3.4.1-11.el7.noarch java-1.8.0-openjdk-1.8.0.242.b08-1.el7.x86_64 tzdata-java-2019c-1.el7.noarch java-1.8.0-openjdk-headless-1.8.0.242.b08-1.el7.x86_64 java-1.7.0-openjdk-1.7.0.251-2.6.21.1.el7.x86_64 java-1.7.0-openjdk-headless-1.7.0.251-2.6.21.1.el7.x86_64 python-javapackages-3.4.1-11.el7.noarch</code></pre></div>{% note primary %}**注意：** 如果使用rpm -qa | grep java 命令没有查到jdk包，但是使用java -version 命令却可以看到jdk版本，可以使用which java 命令查看java命令的执行路径，然后找到对应的jdk文件删除。{% endnote %}<h3 id="三、安装jdk"><a href="#三、安装jdk" class="headerlink" title="三、安装jdk"></a>三、安装jdk</h3><ol><li>将下载好的安装包 jdk-8u151-linux-x64.tar.gz 上传到服务器指定目录下,我的是 /usr/local/yang/；</li><li>解压安装包 <code>tar -zxvf jdk-8u151-linux-x64.tar.gz</code></li></ol><p><img src="https://www.qfeng.online/imgs/jdk/jdk_2020-06-20_10-54-05.jpg" srcset="/img/loading.gif" alt></p><ol start="3"><li>添加环境变量： 编辑/etc/profile 文件 ： vim /etc/profile ,添加如下内容</li></ol><div class="hljs"><pre><code class="hljs shell">JAVA_HOME=/usr/local/yang/jdk1.8.0_151CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH</code></pre></div><ol start="4"><li>重新加载配置文件 <code>source /etc/profile</code></li></ol><div class="hljs"><pre><code class="hljs shell">[root@slave1 lib]# source /etc/profile</code></pre></div><ol start="5"><li>使用<code>java -version</code> 查看是否安装成功</li></ol><div class="hljs"><pre><code class="hljs shell">[root@slave1 lib]# java -versionjava version "1.8.0_151"Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</code></pre></div><blockquote><p>安装成功</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>environment</category>
      
    </categories>
    
    
    <tags>
      
      <tag>learning note</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/19/hello-world/"/>
    <url>/2020/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="hljs"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="hljs"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="hljs"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="hljs"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
